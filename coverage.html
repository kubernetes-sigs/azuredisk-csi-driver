
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>azuredisk: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azure_common.go (100.0%)</option>
				
				<option value="file1">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azure_common_linux.go (62.6%)</option>
				
				<option value="file2">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azure_controller_common.go (71.6%)</option>
				
				<option value="file3">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azure_managedDiskController.go (84.7%)</option>
				
				<option value="file4">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azuredisk.go (66.8%)</option>
				
				<option value="file5">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/azuredisk_option.go (97.8%)</option>
				
				<option value="file6">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/controllerserver.go (68.2%)</option>
				
				<option value="file7">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/fake_azuredisk.go (95.1%)</option>
				
				<option value="file8">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/identityserver.go (81.8%)</option>
				
				<option value="file9">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/mockcorev1/interface.go (0.0%)</option>
				
				<option value="file10">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/mockkubeclient/interface.go (0.0%)</option>
				
				<option value="file11">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/mockpersistentvolume/interface.go (0.0%)</option>
				
				<option value="file12">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/nodeserver.go (80.2%)</option>
				
				<option value="file13">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/trace.go (0.0%)</option>
				
				<option value="file14">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/util.go (92.9%)</option>
				
				<option value="file15">sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk/version.go (92.9%)</option>
				
				<option value="file16">sigs.k8s.io/azuredisk-csi-driver/pkg/azurediskplugin/hooks/prestop.go (14.3%)</option>
				
				<option value="file17">sigs.k8s.io/azuredisk-csi-driver/pkg/azurediskplugin/main.go (28.0%)</option>
				
				<option value="file18">sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils/azure_disk_utils.go (89.6%)</option>
				
				<option value="file19">sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils/azure_snapshot_utils.go (98.2%)</option>
				
				<option value="file20">sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils/fake_hostutil.go (100.0%)</option>
				
				<option value="file21">sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils/fake_iohandler.go (90.6%)</option>
				
				<option value="file22">sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils/osiohandler.go (100.0%)</option>
				
				<option value="file23">sigs.k8s.io/azuredisk-csi-driver/pkg/csi-common/driver.go (100.0%)</option>
				
				<option value="file24">sigs.k8s.io/azuredisk-csi-driver/pkg/csi-common/fake_driver.go (100.0%)</option>
				
				<option value="file25">sigs.k8s.io/azuredisk-csi-driver/pkg/csi-common/utils.go (91.4%)</option>
				
				<option value="file26">sigs.k8s.io/azuredisk-csi-driver/pkg/filewatcher/filewatcher.go (82.6%)</option>
				
				<option value="file27">sigs.k8s.io/azuredisk-csi-driver/pkg/mounter/fake_safe_mounter.go (84.8%)</option>
				
				<option value="file28">sigs.k8s.io/azuredisk-csi-driver/pkg/mounter/safe_mounter_unix.go (100.0%)</option>
				
				<option value="file29">sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/device_perf.go (100.0%)</option>
				
				<option value="file30">sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/device_perf_helper.go (94.9%)</option>
				
				<option value="file31">sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/device_perf_linux.go (95.2%)</option>
				
				<option value="file32">sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/mockoptimization/interface.go (0.0%)</option>
				
				<option value="file33">sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/skus.go (94.3%)</option>
				
				<option value="file34">sigs.k8s.io/azuredisk-csi-driver/pkg/tool/gen-disk-skus-map.go (76.1%)</option>
				
				<option value="file35">sigs.k8s.io/azuredisk-csi-driver/pkg/util/util.go (93.8%)</option>
				
				<option value="file36">sigs.k8s.io/azuredisk-csi-driver/test/utils/credentials/credentials.go (78.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "strings"
)

func strFirstLetterToUpper(str string) string <span class="cov8" title="1">{
        if len(str) &lt; 2 </span><span class="cov8" title="1">{
                return str
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(string(str[0])) + str[1:]</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">//go:build linux
// +build linux

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/container-storage-interface/spec/lib/go/csi"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "k8s.io/klog/v2"
        "k8s.io/kubernetes/pkg/volume"
        mount "k8s.io/mount-utils"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
)

const sysClassBlockPath = "/sys/class/block/"

// exclude those used by azure as resource and OS root in /dev/disk/azure, /dev/disk/azure/scsi0
// "/dev/disk/azure/scsi0" dir is populated in Standard_DC4s/DC2s on Ubuntu 18.04
func listAzureDiskPath(io azureutils.IOHandler) []string <span class="cov8" title="1">{
        var azureDiskList []string
        azureResourcePaths := []string{"/dev/disk/azure/", "/dev/disk/azure/scsi0/"}
        for _, azureDiskPath := range azureResourcePaths </span><span class="cov8" title="1">{
                if dirs, err := io.ReadDir(azureDiskPath); err == nil </span><span class="cov0" title="0">{
                        for _, f := range dirs </span><span class="cov0" title="0">{
                                name := f.Name()
                                diskPath := filepath.Join(azureDiskPath, name)
                                if link, linkErr := io.Readlink(diskPath); linkErr == nil </span><span class="cov0" title="0">{
                                        sd := link[(strings.LastIndex(link, "/") + 1):]
                                        azureDiskList = append(azureDiskList, sd)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">klog.V(12).Infof("Azure sys disks paths: %v", azureDiskList)
        return azureDiskList</span>
}

// getDiskLinkByDevName get disk link by device name from devLinkPath, e.g. /dev/disk/azure/, /dev/disk/by-id/
func getDiskLinkByDevName(io azureutils.IOHandler, devLinkPath, devName string) (string, error) <span class="cov8" title="1">{
        dirs, err := io.ReadDir(devLinkPath)
        klog.V(12).Infof("azureDisk - begin to find %s from %s", devName, devLinkPath)
        if err == nil </span><span class="cov0" title="0">{
                for _, f := range dirs </span><span class="cov0" title="0">{
                        diskPath := devLinkPath + f.Name()
                        klog.V(12).Infof("azureDisk - begin to Readlink: %s", diskPath)
                        link, linkErr := io.Readlink(diskPath)
                        if linkErr != nil </span><span class="cov0" title="0">{
                                klog.Warningf("azureDisk - read link (%s) error: %v", diskPath, linkErr)
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.HasSuffix(link, devName) </span><span class="cov0" title="0">{
                                return diskPath, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("device name(%s) is not found under %s", devName, devLinkPath)</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("read %s error: %v", devLinkPath, err)</span>
}

func scsiHostRescan(io azureutils.IOHandler, _ *mount.SafeFormatAndMount) <span class="cov8" title="1">{
        scsiPath := "/sys/class/scsi_host/"
        if dirs, err := io.ReadDir(scsiPath); err == nil </span><span class="cov8" title="1">{
                for _, f := range dirs </span><span class="cov8" title="1">{
                        name := scsiPath + f.Name() + "/scan"
                        data := []byte("- - -")
                        if err = io.WriteFile(name, data, 0666); err != nil </span><span class="cov0" title="0">{
                                klog.Warningf("failed to rescan scsi host %s", name)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                klog.Warningf("failed to read %s, err %v", scsiPath, err)
        }</span>
}

func findDiskByLun(lun int, io azureutils.IOHandler, _ *mount.SafeFormatAndMount) (string, error) <span class="cov8" title="1">{
        azureDisks := listAzureDiskPath(io)
        device, err := findDiskByLunWithConstraint(lun, io, azureDisks)
        if err == nil &amp;&amp; device != "" </span><span class="cov8" title="1">{
                return device, nil
        }</span>

        <span class="cov0" title="0">devPaths := []string{
                fmt.Sprintf("/dev/disk/azure/scsi1/lun%d", lun),
                fmt.Sprintf("/dev/disk/azure/data/by-lun/%d", lun),
        }
        klog.Warningf("failed to find disk by lun %d, err %v, fall back to search in following device path: %s", lun, err, devPaths)
        for _, devPath := range devPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(devPath); err == nil </span><span class="cov0" title="0">{
                        if device, err := io.Readlink(devPath); err == nil </span><span class="cov0" title="0">{
                                klog.V(2).Infof("found device path %s linked to %s by lun %d", devPath, device, lun)
                                return devPath, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return "", fmt.Errorf("failed to find disk by lun %d", lun)</span>
}

func formatAndMount(source, target, fstype string, options []string, m *mount.SafeFormatAndMount) error <span class="cov8" title="1">{
        if newOptions, exists := azureutils.RemoveOptionIfExists(options, "directmount"); exists </span><span class="cov0" title="0">{
                klog.V(2).Infof("formatAndMount - skip format for %s, old options: %v, new options: %v", target, options, newOptions)
                return m.Mount(source, target, fstype, newOptions)
        }</span>
        <span class="cov8" title="1">return m.FormatAndMount(source, target, fstype, options)</span>
}

// finds a device mounted to "current" node
func findDiskByLunWithConstraint(lun int, io azureutils.IOHandler, azureDisks []string) (string, error) <span class="cov8" title="1">{
        var err error
        sysPath := "/sys/bus/scsi/devices"
        if dirs, err := io.ReadDir(sysPath); err == nil </span><span class="cov8" title="1">{
                for _, f := range dirs </span><span class="cov8" title="1">{
                        name := f.Name()
                        // look for path like /sys/bus/scsi/devices/3:0:0:1
                        arr := strings.Split(name, ":")
                        if len(arr) &lt; 4 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if len(azureDisks) == 0 </span><span class="cov8" title="1">{
                                klog.V(4).Infof("/dev/disk/azure is not populated, now try to parse %v directly", name)
                                target, err := strconv.Atoi(arr[0])
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("failed to parse target from %v (%v), err %v", arr[0], name, err)
                                        continue</span>
                                }
                                // as observed, targets 0-3 are used by OS disks. Skip them
                                <span class="cov8" title="1">if target &lt;= 3 </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                        }

                        // extract LUN from the path.
                        // LUN is the last index of the array, i.e. 1 in /sys/bus/scsi/devices/3:0:0:1
                        <span class="cov8" title="1">l, err := strconv.Atoi(arr[3])
                        if err != nil </span><span class="cov0" title="0">{
                                // unknown path format, continue to read the next one
                                klog.V(4).Infof("azure disk - failed to parse lun from %v (%v), err %v", arr[3], name, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">if lun == l </span><span class="cov8" title="1">{
                                // find the matching LUN
                                // read vendor and model to ensure it is a VHD disk
                                vendorPath := filepath.Join(sysPath, name, "vendor")
                                vendorBytes, err := io.ReadFile(vendorPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("failed to read device vendor, err: %v", err)
                                        continue</span>
                                }
                                <span class="cov8" title="1">vendor := strings.TrimSpace(string(vendorBytes))
                                if strings.ToUpper(vendor) != "MSFT" </span><span class="cov0" title="0">{
                                        klog.V(4).Infof("vendor doesn't match VHD, got %s", vendor)
                                        continue</span>
                                }

                                <span class="cov8" title="1">modelPath := filepath.Join(sysPath, name, "model")
                                modelBytes, err := io.ReadFile(modelPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("failed to read device model, err: %v", err)
                                        continue</span>
                                }
                                <span class="cov8" title="1">model := strings.TrimSpace(string(modelBytes))
                                if strings.ToUpper(model) != "VIRTUAL DISK" </span><span class="cov0" title="0">{
                                        klog.V(4).Infof("model doesn't match VHD, got %s", model)
                                        continue</span>
                                }

                                // find a disk, validate name
                                <span class="cov8" title="1">dir := filepath.Join(sysPath, name, "block")
                                if dev, err := io.ReadDir(dir); err == nil </span><span class="cov8" title="1">{
                                        found := false
                                        devName := dev[0].Name()
                                        for _, diskName := range azureDisks </span><span class="cov0" title="0">{
                                                klog.V(12).Infof("azureDisk - validating disk %q with sys disk %q", devName, diskName)
                                                if devName == diskName </span><span class="cov0" title="0">{
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                                devLinkPaths := []string{"/dev/disk/azure/scsi1/", "/dev/disk/by-id/"}
                                                for _, devLinkPath := range devLinkPaths </span><span class="cov8" title="1">{
                                                        diskPath, err := getDiskLinkByDevName(io, devLinkPath, devName)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                klog.V(4).Infof("azureDisk - found %s by %s under %s", diskPath, devName, devLinkPath)
                                                                return diskPath, nil
                                                        }</span>
                                                        <span class="cov8" title="1">klog.Warningf("azureDisk - getDiskLinkByDevName by %s under %s failed, error: %v", devName, devLinkPath, err)</span>
                                                }
                                                <span class="cov8" title="1">return "/dev/" + devName, nil</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">return "", err</span>
}

func preparePublishPath(_ string, _ *mount.SafeFormatAndMount) error <span class="cov8" title="1">{
        return nil
}</span>

func CleanupMountPoint(path string, m *mount.SafeFormatAndMount, extensiveCheck bool) error <span class="cov8" title="1">{
        return mount.CleanupMountPoint(path, m, extensiveCheck)
}</span>

func getDevicePathWithMountPath(mountPath string, m *mount.SafeFormatAndMount) (string, error) <span class="cov8" title="1">{
        args := []string{"-o", "source", "--noheadings", "--mountpoint", mountPath}
        output, err := m.Exec.Command("findmnt", args...).Output()
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not determine device path(%s), error: %v", mountPath, err)
        }</span>

        <span class="cov8" title="1">devicePath := strings.TrimSpace(string(output))
        if len(devicePath) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not get valid device for mount path: %q", mountPath)
        }</span>

        <span class="cov8" title="1">return devicePath, nil</span>
}

func getBlockSizeBytes(devicePath string, m *mount.SafeFormatAndMount) (int64, error) <span class="cov8" title="1">{
        output, err := m.Exec.Command("blockdev", "--getsize64", devicePath).Output()
        if err != nil </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("error when getting size of block volume at path %s: output: %s, err: %v", devicePath, string(output), err)
        }</span>
        <span class="cov8" title="1">strOut := strings.TrimSpace(string(output))
        gotSizeBytes, err := strconv.ParseInt(strOut, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to parse size %s into int a size", strOut)
        }</span>
        <span class="cov8" title="1">return gotSizeBytes, nil</span>
}

func resizeVolume(devicePath, volumePath string, m *mount.SafeFormatAndMount) error <span class="cov8" title="1">{
        _, err := mount.NewResizeFs(m.Exec).Resize(devicePath, volumePath)
        return err
}</span>

// needResizeVolume check whether device needs resize
func needResizeVolume(devicePath, volumePath string, m *mount.SafeFormatAndMount) (bool, error) <span class="cov8" title="1">{
        return mount.NewResizeFs(m.Exec).NeedResize(devicePath, volumePath)
}</span>

// rescanVolume rescan device for detecting device size expansion
// devicePath e.g. `/dev/sdc`
func rescanVolume(io azureutils.IOHandler, devicePath string) error <span class="cov0" title="0">{
        klog.V(6).Infof("rescanVolume - begin to rescan %s", devicePath)
        deviceName := filepath.Base(devicePath)
        rescanPath := filepath.Join(sysClassBlockPath, deviceName, "device/rescan")
        return io.WriteFile(rescanPath, []byte("1"), 0666)
}</span>

// rescanAllVolumes rescan all sd* devices under /sys/class/block/sd* starting from sdc
func rescanAllVolumes(io azureutils.IOHandler) error <span class="cov8" title="1">{
        dirs, err := io.ReadDir(sysClassBlockPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, device := range dirs </span><span class="cov8" title="1">{
                deviceName := device.Name()
                if strings.HasPrefix(deviceName, "sd") &amp;&amp; deviceName &gt;= "sdc" </span><span class="cov0" title="0">{
                        path := filepath.Join(sysClassBlockPath, deviceName)
                        if err := rescanVolume(io, path); err != nil </span><span class="cov0" title="0">{
                                klog.Warningf("rescanVolume - rescan %s failed with %v", path, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *Driver) GetVolumeStats(_ context.Context, m *mount.SafeFormatAndMount, _, target string, hostutil hostUtil) ([]*csi.VolumeUsage, error) <span class="cov8" title="1">{
        var volUsages []*csi.VolumeUsage
        _, err := os.Stat(target)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.NotFound, "path %s does not exist", target)
                }</span>
                <span class="cov0" title="0">return volUsages, status.Errorf(codes.Internal, "failed to stat file %s: %v", target, err)</span>
        }

        <span class="cov8" title="1">isBlock, err := hostutil.PathIsDevice(target)
        if err != nil </span><span class="cov8" title="1">{
                return volUsages, status.Errorf(codes.NotFound, "failed to determine whether %s is block device: %v", target, err)
        }</span>
        <span class="cov8" title="1">if isBlock </span><span class="cov8" title="1">{
                bcap, err := getBlockSizeBytes(target, m)
                if err != nil </span><span class="cov0" title="0">{
                        return volUsages, status.Errorf(codes.Internal, "failed to get block capacity on path %s: %v", target, err)
                }</span>
                <span class="cov8" title="1">return []*csi.VolumeUsage{
                        {
                                Unit:  csi.VolumeUsage_BYTES,
                                Total: bcap,
                        },
                }, nil</span>
        }

        <span class="cov8" title="1">volumeMetrics, err := volume.NewMetricsStatFS(target).GetMetrics()
        if err != nil </span><span class="cov0" title="0">{
                return volUsages, err
        }</span>

        <span class="cov8" title="1">available, ok := volumeMetrics.Available.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform volume available size(%v)", volumeMetrics.Available)
        }</span>
        <span class="cov8" title="1">capacity, ok := volumeMetrics.Capacity.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform volume capacity size(%v)", volumeMetrics.Capacity)
        }</span>
        <span class="cov8" title="1">used, ok := volumeMetrics.Used.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform volume used size(%v)", volumeMetrics.Used)
        }</span>

        <span class="cov8" title="1">inodesFree, ok := volumeMetrics.InodesFree.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform disk inodes free(%v)", volumeMetrics.InodesFree)
        }</span>
        <span class="cov8" title="1">inodes, ok := volumeMetrics.Inodes.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform disk inodes(%v)", volumeMetrics.Inodes)
        }</span>
        <span class="cov8" title="1">inodesUsed, ok := volumeMetrics.InodesUsed.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return volUsages, status.Errorf(codes.Internal, "failed to transform disk inodes used(%v)", volumeMetrics.InodesUsed)
        }</span>

        <span class="cov8" title="1">return []*csi.VolumeUsage{
                {
                        Unit:      csi.VolumeUsage_BYTES,
                        Available: available,
                        Total:     capacity,
                        Used:      used,
                },
                {
                        Unit:      csi.VolumeUsage_INODES,
                        Available: inodesFree,
                        Total:     inodes,
                        Used:      inodesUsed,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "errors"
        "fmt"
        "math"
        "strings"
        "sync"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"

        "k8s.io/apimachinery/pkg/types"
        kwait "k8s.io/apimachinery/pkg/util/wait"
        cloudprovider "k8s.io/cloud-provider"
        volerr "k8s.io/cloud-provider/volume/errors"
        "k8s.io/klog/v2"
        "k8s.io/utils/ptr"

        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        "sigs.k8s.io/cloud-provider-azure/pkg/azclient"
        azcache "sigs.k8s.io/cloud-provider-azure/pkg/cache"
        "sigs.k8s.io/cloud-provider-azure/pkg/consts"
        "sigs.k8s.io/cloud-provider-azure/pkg/provider"
)

const (
        // Disk Caching is not supported for disks 4 TiB and larger
        // https://docs.microsoft.com/en-us/azure/virtual-machines/premium-storage-performance#disk-caching
        diskCachingLimit = 4096 // GiB

        maxLUN                 = 64 // max number of LUNs per VM
        errStatusCode400       = "statuscode=400"
        errInvalidParameter    = `code="invalidparameter"`
        errTargetInstanceIDs   = `target="instanceids"`
        sourceSnapshot         = "snapshot"
        sourceVolume           = "volume"
        attachDiskMapKeySuffix = "attachdiskmap"
        detachDiskMapKeySuffix = "detachdiskmap"

        // default initial delay in milliseconds for batch disk attach/detach
        defaultAttachDetachInitialDelayInMs = 1000

        // WriteAcceleratorEnabled support for Azure Write Accelerator on Azure Disks
        // https://docs.microsoft.com/azure/virtual-machines/windows/how-to-enable-write-accelerator
        WriteAcceleratorEnabled = "writeacceleratorenabled"

        // see https://docs.microsoft.com/en-us/rest/api/compute/disks/createorupdate#create-a-managed-disk-by-copying-a-snapshot.
        diskSnapshotPath = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/snapshots/%s"

        // see https://docs.microsoft.com/en-us/rest/api/compute/disks/createorupdate#create-a-managed-disk-from-an-existing-managed-disk-in-the-same-or-different-subscription.
        managedDiskPath = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/disks/%s"
)

var defaultBackOff = kwait.Backoff{
        Steps:    7,
        Duration: 2 * time.Second,
        Factor:   1.5,
        Jitter:   0.0,
}

type controllerCommon struct {
        diskStateMap  sync.Map // &lt;diskURI, attaching/detaching state&gt;
        lockMap       *lockMap
        cloud         *provider.Cloud
        clientFactory azclient.ClientFactory
        // disk queue that is waiting for attach or detach on specific node
        // &lt;nodeName, map&lt;diskURI, *provider.AttachDiskOptions/DetachDiskOptions&gt;&gt;
        attachDiskMap sync.Map
        detachDiskMap sync.Map
        // DisableDiskLunCheck whether disable disk lun check after disk attach/detach
        DisableDiskLunCheck bool
        // AttachDetachInitialDelayInMs determines initial delay in milliseconds for batch disk attach/detach
        AttachDetachInitialDelayInMs int
        ForceDetachBackoff           bool
        WaitForDetach                bool
        CheckDiskCountForBatching    bool
        // a timed cache for disk attach hitting max data disk count, &lt;nodeName, ""&gt;
        hitMaxDataDiskCountCache azcache.Resource
}

// ExtendedLocation contains additional info about the location of resources.
type ExtendedLocation struct {
        // Name - The name of the extended location.
        Name string `json:"name,omitempty"`
        // Type - The type of the extended location.
        Type string `json:"type,omitempty"`
}

// AttachDisk attaches a disk to vm
// occupiedLuns is used to avoid conflict with other disk attach in k8s VolumeAttachments
// return (lun, error)
func (c *controllerCommon) AttachDisk(ctx context.Context, diskName, diskURI string, nodeName types.NodeName,
        cachingMode armcompute.CachingTypes, disk *armcompute.Disk, occupiedLuns []int) (int32, error) <span class="cov8" title="1">{
        diskEncryptionSetID := ""
        writeAcceleratorEnabled := false

        // there is possibility that disk is nil when GetDisk is throttled
        // don't check disk state when GetDisk is throttled
        if disk != nil </span><span class="cov8" title="1">{
                if disk.ManagedBy != nil &amp;&amp; (disk.Properties == nil || disk.Properties.MaxShares == nil || *disk.Properties.MaxShares &lt;= 1) </span><span class="cov8" title="1">{
                        vmset, err := c.cloud.GetNodeVMSet(ctx, nodeName, azcache.CacheReadTypeUnsafe)
                        if err != nil </span><span class="cov0" title="0">{
                                return -1, err
                        }</span>
                        <span class="cov8" title="1">klog.V(4).Infof("found disk(%s) is already attached to node %s", diskURI, *disk.ManagedBy)
                        attachedNode, err := vmset.GetNodeNameByProviderID(ctx, *disk.ManagedBy)
                        if err != nil </span><span class="cov0" title="0">{
                                return -1, err
                        }</span>
                        <span class="cov8" title="1">if strings.EqualFold(string(nodeName), string(attachedNode)) </span><span class="cov8" title="1">{
                                klog.Warningf("volume %s is actually attached to current node %s, invalidate vm cache and return error", diskURI, nodeName)
                                // update VM(invalidate vm cache)
                                if errUpdate := c.UpdateVM(ctx, nodeName); errUpdate != nil </span><span class="cov0" title="0">{
                                        return -1, errUpdate
                                }</span>
                                <span class="cov8" title="1">lun, _, err := c.GetDiskLun(ctx, diskName, diskURI, nodeName)
                                return lun, err</span>
                        }

                        <span class="cov0" title="0">attachErr := fmt.Sprintf(
                                "disk(%s) already attached to node(%s), could not be attached to node(%s)",
                                diskURI, *disk.ManagedBy, nodeName)
                        klog.V(2).Infof("found dangling volume %s attached to node %s, could not be attached to node(%s)", diskURI, attachedNode, nodeName)
                        return -1, volerr.NewDanglingError(attachErr, attachedNode, "")</span>
                }

                <span class="cov8" title="1">if disk.Properties != nil </span><span class="cov8" title="1">{
                        if disk.Properties.DiskSizeGB != nil &amp;&amp; *disk.Properties.DiskSizeGB &gt;= diskCachingLimit &amp;&amp; cachingMode != armcompute.CachingTypesNone </span><span class="cov8" title="1">{
                                // Disk Caching is not supported for disks 4 TiB and larger
                                // https://docs.microsoft.com/en-us/azure/virtual-machines/premium-storage-performance#disk-caching
                                cachingMode = armcompute.CachingTypesNone
                                klog.Warningf("size of disk(%s) is %dGB which is bigger than limit(%dGB), set cacheMode as None",
                                        diskURI, *disk.Properties.DiskSizeGB, diskCachingLimit)
                        }</span>

                        <span class="cov8" title="1">if disk.Properties.Encryption != nil &amp;&amp;
                                disk.Properties.Encryption.DiskEncryptionSetID != nil </span><span class="cov8" title="1">{
                                diskEncryptionSetID = *disk.Properties.Encryption.DiskEncryptionSetID
                        }</span>

                        <span class="cov8" title="1">if disk.Properties.DiskState != nil &amp;&amp; *disk.Properties.DiskState != armcompute.DiskStateUnattached &amp;&amp; (disk.Properties.MaxShares == nil || *disk.Properties.MaxShares &lt;= 1) </span><span class="cov8" title="1">{
                                return -1, fmt.Errorf("state of disk(%s) is %s, not in expected %s state", diskURI, *disk.Properties.DiskState, armcompute.DiskStateUnattached)
                        }</span>
                }
                <span class="cov8" title="1">if disk.SKU != nil &amp;&amp; disk.SKU.Name != nil &amp;&amp; *disk.SKU.Name == armcompute.DiskStorageAccountTypesPremiumV2LRS </span><span class="cov0" title="0">{
                        klog.V(2).Infof("disk(%s) is PremiumV2LRS and only supports None caching mode", diskURI)
                        cachingMode = armcompute.CachingTypesNone
                }</span>

                <span class="cov8" title="1">if v, ok := disk.Tags[WriteAcceleratorEnabled]; ok </span><span class="cov8" title="1">{
                        if v != nil &amp;&amp; strings.EqualFold(*v, "true") </span><span class="cov8" title="1">{
                                writeAcceleratorEnabled = true
                        }</span>
                }
        }

        <span class="cov8" title="1">options := provider.AttachDiskOptions{
                Lun:                     -1,
                DiskName:                diskName,
                CachingMode:             armcompute.CachingTypes(cachingMode),
                DiskEncryptionSetID:     diskEncryptionSetID,
                WriteAcceleratorEnabled: writeAcceleratorEnabled,
        }
        node := strings.ToLower(string(nodeName))
        diskuri := strings.ToLower(diskURI)
        requestNum, err := c.insertAttachDiskRequest(diskuri, node, &amp;options)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov8" title="1">var waitForDetachHappened bool
        if c.WaitForDetach &amp;&amp; c.isMaxDataDiskCountExceeded(ctx, string(nodeName)) </span><span class="cov8" title="1">{
                // wait for disk detach to finish first on the same node
                if err = kwait.PollUntilContextTimeout(ctx, 2*time.Second, 30*time.Second, true, func(context.Context) (bool, error) </span><span class="cov8" title="1">{
                        detachDiskReqeustNum, err := c.getDetachDiskRequestNum(node)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">if detachDiskReqeustNum == 0 </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">klog.V(4).Infof("there are still %d detach disk requests on node %s, wait for detach to finish, current disk: %s", detachDiskReqeustNum, node, diskName)
                        waitForDetachHappened = true
                        return false, nil</span>
                }); err != nil <span class="cov0" title="0">{
                        klog.Errorf("current disk: %s, wait for detach disk requests on node %s failed: %v", diskName, node, err)
                }</span>
        }

        <span class="cov8" title="1">c.lockMap.LockEntry(node)
        defer c.lockMap.UnlockEntry(node)

        if !waitForDetachHappened &amp;&amp; c.AttachDetachInitialDelayInMs &gt; 0 &amp;&amp; requestNum == 1 </span><span class="cov0" title="0">{
                klog.V(2).Infof("wait %dms for more requests on node %s, current disk attach: %s", c.AttachDetachInitialDelayInMs, node, diskURI)
                time.Sleep(time.Duration(c.AttachDetachInitialDelayInMs) * time.Millisecond)
        }</span>

        <span class="cov8" title="1">numDisksAllowed := math.MaxInt
        if c.CheckDiskCountForBatching </span><span class="cov0" title="0">{
                _, instanceType, err := GetNodeInfoFromLabels(ctx, string(nodeName), c.cloud.KubeClient)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("failed to get node info from labels: %v", err)
                }</span> else<span class="cov0" title="0"> if instanceType != "" </span><span class="cov0" title="0">{
                        maxNumDisks, instanceExists := GetMaxDataDiskCount(instanceType)
                        if instanceExists </span><span class="cov0" title="0">{
                                attachedDisks, _, err := c.GetNodeDataDisks(ctx, nodeName, azcache.CacheReadTypeDefault)
                                if err != nil </span><span class="cov0" title="0">{
                                        return -1, err
                                }</span>
                                <span class="cov0" title="0">numDisksAttached := len(attachedDisks)
                                if int(maxNumDisks) &gt; numDisksAttached </span><span class="cov0" title="0">{
                                        numDisksAllowed = int(maxNumDisks) - numDisksAttached
                                }</span> else<span class="cov0" title="0"> {
                                        numDisksAllowed = 0
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">diskMap, err := c.cleanAttachDiskRequests(node)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        // Remove some disks from the batch if the number is more than the max number of disks allowed
        <span class="cov8" title="1">removeDisks := len(diskMap) - numDisksAllowed
        if removeDisks &gt; 0 </span><span class="cov0" title="0">{
                klog.V(2).Infof("too many disks to attach, remove %d disks from the request", removeDisks)
                for diskURI, options := range diskMap </span><span class="cov0" title="0">{
                        if removeDisks == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if options != nil </span><span class="cov0" title="0">{
                                klog.V(2).Infof("remove disk(%s) from attach request from node(%s)", diskURI, nodeName)
                                delete(diskMap, diskURI)
                        }</span>
                        <span class="cov0" title="0">removeDisks--</span>
                }
        }

        <span class="cov8" title="1">lun, err := c.SetDiskLun(ctx, nodeName, diskuri, diskMap, occupiedLuns)
        if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("Trying to attach volume %s lun %d to node %s, diskMap len:%d, %+v", diskURI, lun, nodeName, len(diskMap), diskMap)
        if len(diskMap) == 0 </span><span class="cov0" title="0">{
                if !c.DisableDiskLunCheck </span><span class="cov0" title="0">{
                        // always check disk lun after disk attach complete
                        diskLun, vmState, errGetLun := c.GetDiskLun(ctx, diskName, diskURI, nodeName)
                        if errGetLun != nil </span><span class="cov0" title="0">{
                                return -1, fmt.Errorf("disk(%s) could not be found on node(%s), vmState: %s, error: %w", diskURI, nodeName, ptr.Deref(vmState, ""), errGetLun)
                        }</span>
                        <span class="cov0" title="0">lun = diskLun</span>
                }
                <span class="cov0" title="0">return lun, nil</span>
        }

        <span class="cov8" title="1">vmset, err := c.cloud.GetNodeVMSet(ctx, nodeName, azcache.CacheReadTypeUnsafe)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">c.diskStateMap.Store(disk, "attaching")
        defer c.diskStateMap.Delete(disk)

        defer func() </span><span class="cov8" title="1">{
                // invalidate the cache if there is error in disk attach
                if err != nil </span><span class="cov0" title="0">{
                        _ = vmset.DeleteCacheForNode(ctx, string(nodeName))
                }</span>
        }()

        <span class="cov8" title="1">err = vmset.AttachDisk(ctx, nodeName, diskMap)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), util.MaximumDataDiskExceededMsg) </span><span class="cov0" title="0">{
                        klog.Warningf("hit max data disk count when attaching disk %s, set cache for node(%s)", diskName, nodeName)
                        c.hitMaxDataDiskCountCache.Set(node, "")
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "OperationPreempted") </span><span class="cov0" title="0">{
                        klog.Errorf("Retry VM Update on node (%s) due to error (%v)", nodeName, err)
                        err = vmset.UpdateVM(ctx, nodeName)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return -1, err
                }</span>
        }

        <span class="cov8" title="1">if !c.DisableDiskLunCheck </span><span class="cov0" title="0">{
                // always check disk lun after disk attach complete
                diskLun, vmState, errGetLun := c.GetDiskLun(ctx, diskName, diskURI, nodeName)
                if errGetLun != nil </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("disk(%s) could not be found on node(%s), vmState: %s, error: %w", diskURI, nodeName, ptr.Deref(vmState, ""), errGetLun)
                }</span>
                <span class="cov0" title="0">lun = diskLun</span>
        }
        <span class="cov8" title="1">return lun, nil</span>
}

// insertAttachDiskRequest return (attachDiskRequestQueueLength, error)
func (c *controllerCommon) insertAttachDiskRequest(diskURI, nodeName string, options *provider.AttachDiskOptions) (int, error) <span class="cov8" title="1">{
        var diskMap map[string]*provider.AttachDiskOptions
        attachDiskMapKey := nodeName + attachDiskMapKeySuffix
        c.lockMap.LockEntry(attachDiskMapKey)
        defer c.lockMap.UnlockEntry(attachDiskMapKey)
        v, ok := c.attachDiskMap.Load(nodeName)
        if ok </span><span class="cov8" title="1">{
                if diskMap, ok = v.(map[string]*provider.AttachDiskOptions); !ok </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("convert attachDiskMap failure on node(%s)", nodeName)
                }</span>
        } else<span class="cov8" title="1"> {
                diskMap = make(map[string]*provider.AttachDiskOptions)
                c.attachDiskMap.Store(nodeName, diskMap)
        }</span>
        // insert attach disk request to queue
        <span class="cov8" title="1">_, ok = diskMap[diskURI]
        if ok </span><span class="cov8" title="1">{
                klog.V(2).Infof("azureDisk - duplicated attach disk(%s) request on node(%s)", diskURI, nodeName)
        }</span> else<span class="cov8" title="1"> {
                diskMap[diskURI] = options
        }</span>
        <span class="cov8" title="1">return len(diskMap), nil</span>
}

// clean up attach disk requests
// return original attach disk requests
func (c *controllerCommon) cleanAttachDiskRequests(nodeName string) (map[string]*provider.AttachDiskOptions, error) <span class="cov8" title="1">{
        var diskMap map[string]*provider.AttachDiskOptions

        attachDiskMapKey := nodeName + attachDiskMapKeySuffix
        c.lockMap.LockEntry(attachDiskMapKey)
        defer c.lockMap.UnlockEntry(attachDiskMapKey)
        v, ok := c.attachDiskMap.Load(nodeName)
        if !ok </span><span class="cov8" title="1">{
                return diskMap, nil
        }</span>
        <span class="cov8" title="1">if diskMap, ok = v.(map[string]*provider.AttachDiskOptions); !ok </span><span class="cov0" title="0">{
                return diskMap, fmt.Errorf("convert attachDiskMap failure on node(%s)", nodeName)
        }</span>
        <span class="cov8" title="1">c.attachDiskMap.Store(nodeName, make(map[string]*provider.AttachDiskOptions))
        return diskMap, nil</span>
}

// DetachDisk detaches a disk from VM
func (c *controllerCommon) DetachDisk(ctx context.Context, diskName, diskURI string, nodeName types.NodeName) error <span class="cov8" title="1">{
        if _, err := c.cloud.InstanceID(ctx, nodeName); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloudprovider.InstanceNotFound) </span><span class="cov0" title="0">{
                        // if host doesn't exist, no need to detach
                        klog.Warningf("azureDisk - failed to get azure instance id(%s), DetachDisk(%s) will assume disk is already detached",
                                nodeName, diskURI)
                        return nil
                }</span>
                <span class="cov8" title="1">klog.Warningf("failed to get azure instance id (%v)", err)
                return fmt.Errorf("failed to get azure instance id for node %q: %w", nodeName, err)</span>
        }

        <span class="cov8" title="1">vmset, err := c.cloud.GetNodeVMSet(ctx, nodeName, azcache.CacheReadTypeUnsafe)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">node := strings.ToLower(string(nodeName))
        disk := strings.ToLower(diskURI)
        requestNum, err := c.insertDetachDiskRequest(diskName, disk, node)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.lockMap.LockEntry(node)
        defer c.lockMap.UnlockEntry(node)

        if c.AttachDetachInitialDelayInMs &gt; 0 &amp;&amp; requestNum == 1 </span><span class="cov0" title="0">{
                klog.V(2).Infof("wait %dms for more requests on node %s, current disk detach: %s", c.AttachDetachInitialDelayInMs, node, diskURI)
                time.Sleep(time.Duration(c.AttachDetachInitialDelayInMs) * time.Millisecond)
        }</span>
        <span class="cov8" title="1">diskMap, err := c.cleanDetachDiskRequests(node)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("Trying to detach volume %s from node %s, diskMap len:%d, %s", diskURI, nodeName, len(diskMap), diskMap)
        if len(diskMap) &gt; 0 </span><span class="cov8" title="1">{
                c.diskStateMap.Store(disk, "detaching")
                defer c.diskStateMap.Delete(disk)
                if err = vmset.DetachDisk(ctx, nodeName, diskMap, false); err != nil </span><span class="cov0" title="0">{
                        if isInstanceNotFoundError(err) </span><span class="cov0" title="0">{
                                // if host doesn't exist, no need to detach
                                klog.Warningf("azureDisk - got InstanceNotFoundError(%v), DetachDisk(%s) will assume disk is already detached",
                                        err, diskURI)
                                return nil
                        }</span>
                        <span class="cov0" title="0">if c.ForceDetachBackoff &amp;&amp; !azureutils.IsThrottlingError(err) </span><span class="cov0" title="0">{
                                klog.Errorf("azureDisk - DetachDisk(%s) from node %s failed with error: %v, retry with force detach", diskURI, nodeName, err)
                                err = vmset.DetachDisk(ctx, nodeName, diskMap, true)
                        }</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("azureDisk - detach disk(%s, %s) failed, err: %v", diskName, diskURI, err)
                return err
        }</span>

        <span class="cov8" title="1">if !c.DisableDiskLunCheck </span><span class="cov8" title="1">{
                // always check disk lun after disk detach complete
                lun, vmState, errGetLun := c.GetDiskLun(ctx, diskName, diskURI, nodeName)
                if errGetLun == nil || !strings.Contains(errGetLun.Error(), consts.CannotFindDiskLUN) </span><span class="cov0" title="0">{
                        return fmt.Errorf("disk(%s) is still attached to node(%s) on lun(%d), vmState: %s, error: %w", diskURI, nodeName, lun, ptr.Deref(vmState, ""), errGetLun)
                }</span>
        }

        <span class="cov8" title="1">klog.V(2).Infof("azureDisk - detach disk(%s, %s) succeeded", diskName, diskURI)
        return nil</span>
}

// UpdateVM updates a vm
func (c *controllerCommon) UpdateVM(ctx context.Context, nodeName types.NodeName) error <span class="cov8" title="1">{
        vmset, err := c.cloud.GetNodeVMSet(ctx, nodeName, azcache.CacheReadTypeUnsafe)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">node := strings.ToLower(string(nodeName))
        c.lockMap.LockEntry(node)
        defer c.lockMap.UnlockEntry(node)

        defer func() </span><span class="cov8" title="1">{
                _ = vmset.DeleteCacheForNode(ctx, string(nodeName))
        }</span>()

        <span class="cov8" title="1">klog.V(2).Infof("azureDisk - update: vm(%s)", nodeName)
        return vmset.UpdateVM(ctx, nodeName)</span>
}

// insertDetachDiskRequest return (detachDiskRequestQueueLength, error)
func (c *controllerCommon) insertDetachDiskRequest(diskName, diskURI, nodeName string) (int, error) <span class="cov8" title="1">{
        var diskMap map[string]string
        detachDiskMapKey := nodeName + detachDiskMapKeySuffix
        c.lockMap.LockEntry(detachDiskMapKey)
        defer c.lockMap.UnlockEntry(detachDiskMapKey)
        v, ok := c.detachDiskMap.Load(nodeName)
        if ok </span><span class="cov8" title="1">{
                if diskMap, ok = v.(map[string]string); !ok </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("convert detachDiskMap failure on node(%s)", nodeName)
                }</span>
        } else<span class="cov8" title="1"> {
                diskMap = make(map[string]string)
                c.detachDiskMap.Store(nodeName, diskMap)
        }</span>
        // insert detach disk request to queue
        <span class="cov8" title="1">_, ok = diskMap[diskURI]
        if ok </span><span class="cov8" title="1">{
                klog.V(2).Infof("azureDisk - duplicated detach disk(%s) request on node(%s)", diskURI, nodeName)
        }</span> else<span class="cov8" title="1"> {
                diskMap[diskURI] = diskName
        }</span>
        <span class="cov8" title="1">return len(diskMap), nil</span>
}

// clean up detach disk requests
// return original detach disk requests
func (c *controllerCommon) cleanDetachDiskRequests(nodeName string) (map[string]string, error) <span class="cov8" title="1">{
        var diskMap map[string]string

        detachDiskMapKey := nodeName + detachDiskMapKeySuffix
        c.lockMap.LockEntry(detachDiskMapKey)
        defer c.lockMap.UnlockEntry(detachDiskMapKey)
        v, ok := c.detachDiskMap.Load(nodeName)
        if !ok </span><span class="cov8" title="1">{
                return diskMap, nil
        }</span>
        <span class="cov8" title="1">if diskMap, ok = v.(map[string]string); !ok </span><span class="cov0" title="0">{
                return diskMap, fmt.Errorf("convert detachDiskMap failure on node(%s)", nodeName)
        }</span>
        // clean up original requests in disk map
        <span class="cov8" title="1">c.detachDiskMap.Store(nodeName, make(map[string]string))
        return diskMap, nil</span>
}

func (c *controllerCommon) getDetachDiskRequestNum(nodeName string) (int, error) <span class="cov8" title="1">{
        detachDiskMapKey := nodeName + detachDiskMapKeySuffix
        c.lockMap.LockEntry(detachDiskMapKey)
        defer c.lockMap.UnlockEntry(detachDiskMapKey)
        v, ok := c.detachDiskMap.Load(nodeName)
        if !ok </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">if diskMap, ok := v.(map[string]string); ok </span><span class="cov8" title="1">{
                return len(diskMap), nil
        }</span>
        <span class="cov0" title="0">return -1, fmt.Errorf("convert detachDiskMap failure on node(%s)", nodeName)</span>
}

// GetNodeDataDisks invokes vmSet interfaces to get data disks for the node.
func (c *controllerCommon) GetNodeDataDisks(ctx context.Context, nodeName types.NodeName, crt azcache.AzureCacheReadType) ([]*armcompute.DataDisk, *string, error) <span class="cov8" title="1">{
        vmset, err := c.cloud.GetNodeVMSet(ctx, nodeName, crt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return vmset.GetDataDisks(ctx, nodeName, crt)</span>
}

// GetDiskLun finds the lun on the host that the vhd is attached to, given a vhd's diskName and diskURI.
func (c *controllerCommon) GetDiskLun(ctx context.Context, diskName, diskURI string, nodeName types.NodeName) (int32, *string, error) <span class="cov8" title="1">{
        // GetNodeDataDisks need to fetch the cached data/fresh data if cache expired here
        // to ensure we get LUN based on latest entry.
        disks, provisioningState, err := c.GetNodeDataDisks(ctx, nodeName, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("error of getting data disks for node %s: %v", nodeName, err)
                return -1, provisioningState, err
        }</span>

        <span class="cov8" title="1">for _, disk := range disks </span><span class="cov8" title="1">{
                if disk.Lun != nil &amp;&amp; (disk.Name != nil &amp;&amp; diskName != "" &amp;&amp; strings.EqualFold(*disk.Name, diskName)) ||
                        (disk.Vhd != nil &amp;&amp; disk.Vhd.URI != nil &amp;&amp; diskURI != "" &amp;&amp; strings.EqualFold(*disk.Vhd.URI, diskURI)) ||
                        (disk.ManagedDisk != nil &amp;&amp; strings.EqualFold(*disk.ManagedDisk.ID, diskURI)) </span><span class="cov8" title="1">{
                        if disk.ToBeDetached != nil &amp;&amp; *disk.ToBeDetached </span><span class="cov8" title="1">{
                                klog.Warningf("azureDisk - found disk(ToBeDetached): lun %d name %s uri %s", *disk.Lun, diskName, diskURI)
                        }</span> else<span class="cov8" title="1"> {
                                // found the disk
                                klog.V(2).Infof("azureDisk - found disk: lun %d name %s uri %s", *disk.Lun, diskName, diskURI)
                                return *disk.Lun, provisioningState, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return -1, provisioningState, fmt.Errorf("%s for disk %s", consts.CannotFindDiskLUN, diskName)</span>
}

// SetDiskLun find unused luns and allocate lun for every disk in diskMap.
// occupiedLuns is used to avoid conflict with other disk attach in k8s VolumeAttachments
// Return lun of diskURI, -1 if all luns are used.
func (c *controllerCommon) SetDiskLun(ctx context.Context, nodeName types.NodeName, diskURI string, diskMap map[string]*provider.AttachDiskOptions, occupiedLuns []int) (int32, error) <span class="cov8" title="1">{
        disks, _, err := c.GetNodeDataDisks(ctx, nodeName, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov8" title="1">{
                klog.Errorf("error of getting data disks for node %s: %v", nodeName, err)
                return -1, err
        }</span>

        <span class="cov8" title="1">lun := int32(-1)
        _, isDiskInMap := diskMap[diskURI]
        used := make([]bool, maxLUN)
        for _, disk := range disks </span><span class="cov8" title="1">{
                if disk.Lun != nil </span><span class="cov8" title="1">{
                        used[*disk.Lun] = true
                        if !isDiskInMap </span><span class="cov8" title="1">{
                                // find lun of diskURI since diskURI is not in diskMap
                                if disk.ManagedDisk != nil &amp;&amp; strings.EqualFold(*disk.ManagedDisk.ID, diskURI) </span><span class="cov0" title="0">{
                                        lun = *disk.Lun
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if !isDiskInMap &amp;&amp; lun &lt; 0 </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("could not find disk(%s) in current disk list(len: %d) nor in diskMap(%v)", diskURI, len(disks), diskMap)
        }</span>
        <span class="cov8" title="1">if len(diskMap) == 0 </span><span class="cov0" title="0">{
                // attach disk request is empty, return directly
                return lun, nil
        }</span>

        <span class="cov8" title="1">for _, lun := range occupiedLuns </span><span class="cov8" title="1">{
                if lun &gt;= 0 &amp;&amp; lun &lt;= maxLUN </span><span class="cov8" title="1">{
                        used[int32(lun)] = true
                }</span>
        }

        // allocate lun for every disk in diskMap
        <span class="cov8" title="1">var diskLuns []int32
        count := 0
        for k, v := range used </span><span class="cov8" title="1">{
                if !v </span><span class="cov8" title="1">{
                        diskLuns = append(diskLuns, int32(k))
                        count++
                        if count &gt;= len(diskMap) </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(diskLuns) != len(diskMap) </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("could not find enough disk luns(current: %d) for diskMap(%v, len=%d), diskURI(%s)",
                        len(diskLuns), diskMap, len(diskMap), diskURI)
        }</span>

        <span class="cov8" title="1">count = 0
        for uri, opt := range diskMap </span><span class="cov8" title="1">{
                if opt == nil </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("unexpected nil pointer in diskMap(%v), diskURI(%s)", diskMap, diskURI)
                }</span>
                <span class="cov8" title="1">if strings.EqualFold(uri, diskURI) </span><span class="cov8" title="1">{
                        lun = diskLuns[count]
                }</span>
                <span class="cov8" title="1">opt.Lun = diskLuns[count]
                count++</span>
        }
        <span class="cov8" title="1">if lun &lt; 0 </span><span class="cov0" title="0">{
                return lun, fmt.Errorf("could not find lun of diskURI(%s), diskMap(%v)", diskURI, diskMap)
        }</span>
        <span class="cov8" title="1">return lun, nil</span>
}

// isMaxDataDiskCountExceeded checks if the max data disk count is exceeded
func (c *controllerCommon) isMaxDataDiskCountExceeded(ctx context.Context, nodeName string) bool <span class="cov8" title="1">{
        _, err := c.hitMaxDataDiskCountCache.Get(ctx, nodeName, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("isMaxDataDiskCountExceeded(%s) return with error: %s", nodeName, err)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func getValidCreationData(subscriptionID, resourceGroup string, options *ManagedDiskOptions) (armcompute.CreationData, error) <span class="cov8" title="1">{
        if options.SourceResourceID == "" </span><span class="cov8" title="1">{
                return armcompute.CreationData{
                        CreateOption:    to.Ptr(armcompute.DiskCreateOptionEmpty),
                        PerformancePlus: options.PerformancePlus,
                }, nil
        }</span>

        <span class="cov8" title="1">sourceResourceID := options.SourceResourceID
        switch options.SourceType </span>{
        case sourceSnapshot:<span class="cov8" title="1">
                if match := azureconstants.DiskSnapshotPathRE.FindString(sourceResourceID); match == "" </span><span class="cov8" title="1">{
                        sourceResourceID = fmt.Sprintf(diskSnapshotPath, subscriptionID, resourceGroup, sourceResourceID)
                }</span>

        case sourceVolume:<span class="cov8" title="1">
                if match := azureconstants.ManagedDiskPathRE.FindString(sourceResourceID); match == "" </span><span class="cov8" title="1">{
                        sourceResourceID = fmt.Sprintf(managedDiskPath, subscriptionID, resourceGroup, sourceResourceID)
                }</span>
        default:<span class="cov8" title="1">
                return armcompute.CreationData{
                        CreateOption:    to.Ptr(armcompute.DiskCreateOptionEmpty),
                        PerformancePlus: options.PerformancePlus,
                }, nil</span>
        }

        <span class="cov8" title="1">splits := strings.Split(sourceResourceID, "/")
        if len(splits) &gt; 9 </span><span class="cov8" title="1">{
                if options.SourceType == sourceSnapshot </span><span class="cov8" title="1">{
                        return armcompute.CreationData{}, fmt.Errorf("sourceResourceID(%s) is invalid, correct format: %s", sourceResourceID, azureconstants.DiskSnapshotPathRE)
                }</span>
                <span class="cov8" title="1">return armcompute.CreationData{}, fmt.Errorf("sourceResourceID(%s) is invalid, correct format: %s", sourceResourceID, azureconstants.ManagedDiskPathRE)</span>
        }
        <span class="cov8" title="1">return armcompute.CreationData{
                CreateOption:     to.Ptr(armcompute.DiskCreateOptionCopy),
                SourceResourceID: &amp;sourceResourceID,
                PerformancePlus:  options.PerformancePlus,
        }, nil</span>
}

func isInstanceNotFoundError(err error) bool <span class="cov8" title="1">{
        errMsg := strings.ToLower(err.Error())
        if strings.Contains(errMsg, strings.ToLower(consts.VmssVMNotActiveErrorMessage)) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return strings.Contains(errMsg, errStatusCode400) &amp;&amp; strings.Contains(errMsg, errInvalidParameter) &amp;&amp; strings.Contains(errMsg, errTargetInstanceIDs)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"

        "k8s.io/apimachinery/pkg/api/resource"
        kwait "k8s.io/apimachinery/pkg/util/wait"
        volumehelpers "k8s.io/cloud-provider/volume/helpers"
        "k8s.io/klog/v2"
        "k8s.io/utils/ptr"

        azureconsts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
        azcache "sigs.k8s.io/cloud-provider-azure/pkg/cache"
        "sigs.k8s.io/cloud-provider-azure/pkg/consts"
        "sigs.k8s.io/cloud-provider-azure/pkg/provider"
)

// ManagedDiskController : managed disk controller struct
type ManagedDiskController struct {
        *controllerCommon
}

func NewManagedDiskController(provider *provider.Cloud) *ManagedDiskController <span class="cov8" title="1">{
        common := &amp;controllerCommon{
                cloud:                        provider,
                lockMap:                      newLockMap(),
                AttachDetachInitialDelayInMs: defaultAttachDetachInitialDelayInMs,
                clientFactory:                provider.ComputeClientFactory,
        }
        getter := func(_ context.Context, _ string) (interface{}, error) </span><span class="cov0" title="0">{ return nil, nil }</span>
        <span class="cov8" title="1">common.hitMaxDataDiskCountCache, _ = azcache.NewTimedCache(5*time.Minute, getter, false)

        return &amp;ManagedDiskController{common}</span>
}

// ManagedDiskOptions specifies the options of managed disks.
type ManagedDiskOptions struct {
        // The SKU of storage account.
        StorageAccountType armcompute.DiskStorageAccountTypes
        // The name of the disk.
        DiskName string
        // The name of PVC.
        PVCName string
        // The name of resource group.
        ResourceGroup string
        // The AvailabilityZone to create the disk.
        AvailabilityZone string
        // The tags of the disk.
        Tags map[string]string
        // IOPS Caps for UltraSSD disk
        DiskIOPSReadWrite string
        // Throughput Cap (MBps) for UltraSSD disk
        DiskMBpsReadWrite string
        // if SourceResourceID is not empty, then it's a disk copy operation(for snapshot)
        SourceResourceID string
        // The type of source
        SourceType string
        // ResourceId of the disk encryption set to use for enabling encryption at rest.
        DiskEncryptionSetID string
        // DiskEncryption type, available values: EncryptionAtRestWithCustomerKey, EncryptionAtRestWithPlatformAndCustomerKeys
        DiskEncryptionType string
        // The size in GB.
        SizeGB int
        // The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can be mounted on multiple VMs at the same time.
        MaxShares int32
        // Logical sector size in bytes for Ultra disks
        LogicalSectorSize int32
        // SkipGetDiskOperation indicates whether skip GetDisk operation(mainly due to throttling)
        SkipGetDiskOperation bool
        // PublicNetworkAccess - Possible values include: 'Enabled', 'Disabled'
        PublicNetworkAccess armcompute.PublicNetworkAccess
        // NetworkAccessPolicy - Possible values include: 'AllowAll', 'AllowPrivate', 'DenyAll'
        NetworkAccessPolicy armcompute.NetworkAccessPolicy
        // DiskAccessID - ARM id of the DiskAccess resource for using private endpoints on disks.
        DiskAccessID *string
        // BurstingEnabled - Set to true to enable bursting beyond the provisioned performance target of the disk.
        BurstingEnabled *bool
        // SubscriptionID - specify a different SubscriptionID
        SubscriptionID string
        // Location - specify a different location
        Location string
        // PerformancePlus - Set this flag to true to get a boost on the performance target of the disk deployed
        PerformancePlus *bool
}

// CreateManagedDisk: create managed disk
func (c *ManagedDiskController) CreateManagedDisk(ctx context.Context, options *ManagedDiskOptions) (string, error) <span class="cov8" title="1">{
        var err error
        klog.V(4).Infof("azureDisk - creating new managed Name:%s StorageAccountType:%s Size:%v", options.DiskName, options.StorageAccountType, options.SizeGB)

        var createZones []string
        if len(options.AvailabilityZone) &gt; 0 </span><span class="cov8" title="1">{
                requestedZone := c.cloud.GetZoneID(options.AvailabilityZone)
                if requestedZone != "" </span><span class="cov8" title="1">{
                        createZones = append(createZones, requestedZone)
                }</span>
        }

        // insert original tags to newTags
        <span class="cov8" title="1">newTags := make(map[string]*string)
        newTags[consts.CreatedByTag] = ptr.To(azureconsts.AzureDiskDriverTag)
        if options.Tags != nil </span><span class="cov8" title="1">{
                for k, v := range options.Tags </span><span class="cov8" title="1">{
                        value := v
                        newTags[k] = &amp;value
                }</span>
        }

        <span class="cov8" title="1">diskSizeGB := int32(options.SizeGB)
        diskSku := options.StorageAccountType

        rg := c.cloud.ResourceGroup
        if options.ResourceGroup != "" </span><span class="cov8" title="1">{
                rg = options.ResourceGroup
        }</span>
        <span class="cov8" title="1">if options.SubscriptionID != "" &amp;&amp; !strings.EqualFold(options.SubscriptionID, c.cloud.SubscriptionID) &amp;&amp; options.ResourceGroup == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("resourceGroup must be specified when subscriptionID(%s) is not empty", options.SubscriptionID)
        }</span>
        <span class="cov8" title="1">subsID := c.cloud.SubscriptionID
        if options.SubscriptionID != "" </span><span class="cov0" title="0">{
                subsID = options.SubscriptionID
        }</span>

        <span class="cov8" title="1">creationData, err := getValidCreationData(subsID, rg, options)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">diskProperties := armcompute.DiskProperties{
                DiskSizeGB:      &amp;diskSizeGB,
                CreationData:    &amp;creationData,
                BurstingEnabled: options.BurstingEnabled,
        }

        if options.PublicNetworkAccess != "" </span><span class="cov8" title="1">{
                diskProperties.PublicNetworkAccess = to.Ptr(options.PublicNetworkAccess)
        }</span>

        <span class="cov8" title="1">if options.NetworkAccessPolicy != "" </span><span class="cov8" title="1">{
                diskProperties.NetworkAccessPolicy = to.Ptr(options.NetworkAccessPolicy)
                if options.NetworkAccessPolicy == armcompute.NetworkAccessPolicyAllowPrivate </span><span class="cov8" title="1">{
                        if options.DiskAccessID == nil </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("DiskAccessID should not be empty when NetworkAccessPolicy is AllowPrivate")
                        }</span>
                        <span class="cov0" title="0">diskProperties.DiskAccessID = options.DiskAccessID</span>
                } else<span class="cov8" title="1"> {
                        if options.DiskAccessID != nil </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("DiskAccessID(%s) must be empty when NetworkAccessPolicy(%s) is not AllowPrivate", *options.DiskAccessID, options.NetworkAccessPolicy)
                        }</span>
                }
        }

        <span class="cov8" title="1">if diskSku == armcompute.DiskStorageAccountTypesUltraSSDLRS || diskSku == armcompute.DiskStorageAccountTypesPremiumV2LRS </span><span class="cov8" title="1">{
                if options.DiskIOPSReadWrite == "" </span><span class="cov8" title="1">{
                        if diskSku == armcompute.DiskStorageAccountTypesUltraSSDLRS </span><span class="cov0" title="0">{
                                diskIOPSReadWrite := int64(consts.DefaultDiskIOPSReadWrite)
                                diskProperties.DiskIOPSReadWrite = ptr.To(int64(diskIOPSReadWrite))
                        }</span>
                } else<span class="cov8" title="1"> {
                        v, err := strconv.Atoi(options.DiskIOPSReadWrite)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("AzureDisk - failed to parse DiskIOPSReadWrite: %w", err)
                        }</span>
                        <span class="cov8" title="1">diskIOPSReadWrite := int64(v)
                        diskProperties.DiskIOPSReadWrite = ptr.To(int64(diskIOPSReadWrite))</span>
                }

                <span class="cov8" title="1">if options.DiskMBpsReadWrite == "" </span><span class="cov8" title="1">{
                        if diskSku == armcompute.DiskStorageAccountTypesUltraSSDLRS </span><span class="cov0" title="0">{
                                diskMBpsReadWrite := int64(consts.DefaultDiskMBpsReadWrite)
                                diskProperties.DiskMBpsReadWrite = ptr.To(int64(diskMBpsReadWrite))
                        }</span>
                } else<span class="cov8" title="1"> {
                        v, err := strconv.Atoi(options.DiskMBpsReadWrite)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("AzureDisk - failed to parse DiskMBpsReadWrite: %w", err)
                        }</span>
                        <span class="cov8" title="1">diskMBpsReadWrite := int64(v)
                        diskProperties.DiskMBpsReadWrite = ptr.To(int64(diskMBpsReadWrite))</span>
                }

                <span class="cov8" title="1">if options.LogicalSectorSize != 0 </span><span class="cov0" title="0">{
                        klog.V(2).Infof("AzureDisk - requested LogicalSectorSize: %v", options.LogicalSectorSize)
                        diskProperties.CreationData.LogicalSectorSize = ptr.To(int32(options.LogicalSectorSize))
                }</span>
        } else<span class="cov8" title="1"> {
                if options.DiskIOPSReadWrite != "" </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("AzureDisk - DiskIOPSReadWrite parameter is only applicable in UltraSSD_LRS disk type")
                }</span>
                <span class="cov8" title="1">if options.DiskMBpsReadWrite != "" </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("AzureDisk - DiskMBpsReadWrite parameter is only applicable in UltraSSD_LRS disk type")
                }</span>
                <span class="cov8" title="1">if options.LogicalSectorSize != 0 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("AzureDisk - LogicalSectorSize parameter is only applicable in UltraSSD_LRS disk type")
                }</span>
        }

        <span class="cov8" title="1">if options.DiskEncryptionSetID != "" </span><span class="cov8" title="1">{
                if strings.Index(strings.ToLower(options.DiskEncryptionSetID), "/subscriptions/") != 0 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("AzureDisk - format of DiskEncryptionSetID(%s) is incorrect, correct format: %s", options.DiskEncryptionSetID, consts.DiskEncryptionSetIDFormat)
                }</span>
                <span class="cov8" title="1">encryptionType := armcompute.EncryptionTypeEncryptionAtRestWithCustomerKey
                if options.DiskEncryptionType != "" </span><span class="cov8" title="1">{
                        encryptionType = armcompute.EncryptionType(options.DiskEncryptionType)
                        klog.V(4).Infof("azureDisk - DiskEncryptionType: %s, DiskEncryptionSetID: %s", options.DiskEncryptionType, options.DiskEncryptionSetID)
                }</span>
                <span class="cov8" title="1">diskProperties.Encryption = &amp;armcompute.Encryption{
                        DiskEncryptionSetID: &amp;options.DiskEncryptionSetID,
                        Type:                to.Ptr(encryptionType),
                }</span>
        } else<span class="cov8" title="1"> {
                if options.DiskEncryptionType != "" </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("AzureDisk - DiskEncryptionType(%s) should be empty when DiskEncryptionSetID is not set", options.DiskEncryptionType)
                }</span>
        }

        <span class="cov8" title="1">if options.MaxShares &gt; 1 </span><span class="cov8" title="1">{
                diskProperties.MaxShares = &amp;options.MaxShares
        }</span>

        <span class="cov8" title="1">location := c.cloud.Location
        if options.Location != "" </span><span class="cov8" title="1">{
                location = options.Location
        }</span>
        <span class="cov8" title="1">model := armcompute.Disk{
                Location: &amp;location,
                Tags:     newTags,
                SKU: &amp;armcompute.DiskSKU{
                        Name: to.Ptr(diskSku),
                },
                Properties: &amp;diskProperties,
        }

        if c.cloud.HasExtendedLocation() </span><span class="cov8" title="1">{
                klog.V(2).Infof("extended location Name:%s Type:%s is set on disk(%s)", c.cloud.ExtendedLocationName, c.cloud.ExtendedLocationType, options.DiskName)
                model.ExtendedLocation = &amp;armcompute.ExtendedLocation{
                        Name: ptr.To(c.cloud.ExtendedLocationName),
                        Type: to.Ptr(armcompute.ExtendedLocationTypes(c.cloud.ExtendedLocationType)),
                }
        }</span>

        <span class="cov8" title="1">if len(createZones) &gt; 0 </span><span class="cov8" title="1">{
                model.Zones = to.SliceOfPtrs(createZones...)
        }</span>
        <span class="cov8" title="1">diskClient, err := c.clientFactory.GetDiskClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">diskID := fmt.Sprintf(managedDiskPath, subsID, rg, options.DiskName)
        disk, err := diskClient.CreateOrUpdate(ctx, rg, options.DiskName, model)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">err = kwait.ExponentialBackoffWithContext(ctx, defaultBackOff, func(_ context.Context) (bool, error) </span><span class="cov8" title="1">{
                if disk != nil &amp;&amp; disk.Properties != nil &amp;&amp; strings.EqualFold(ptr.Deref((*disk.Properties).ProvisioningState, ""), "succeeded") </span><span class="cov8" title="1">{
                        if ptr.Deref(disk.ID, "") != "" </span><span class="cov8" title="1">{
                                diskID = *disk.ID
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }

                <span class="cov0" title="0">if options.SkipGetDiskOperation </span><span class="cov0" title="0">{
                        klog.Warningf("azureDisk - GetDisk(%s, StorageAccountType:%s) is throttled, unable to confirm provisioningState in poll process", options.DiskName, options.StorageAccountType)
                        return true, nil
                }</span>
                <span class="cov0" title="0">klog.V(4).Infof("azureDisk - waiting for disk(%s) in resourceGroup(%s) to be provisioned", options.DiskName, rg)
                if disk, err = diskClient.Get(ctx, rg, options.DiskName); err != nil </span><span class="cov0" title="0">{
                        // We are waiting for provisioningState==Succeeded
                        // We don't want to hand-off managed disks to k8s while they are
                        //still being provisioned, this is to avoid some race conditions
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("azureDisk - created new MD Name:%s StorageAccountType:%s Size:%v but was unable to confirm provisioningState in poll process", options.DiskName, options.StorageAccountType, options.SizeGB)
        }</span> else<span class="cov8" title="1"> {
                klog.V(2).Infof("azureDisk - created new MD Name:%s StorageAccountType:%s Size:%v", options.DiskName, options.StorageAccountType, options.SizeGB)
        }</span>
        <span class="cov8" title="1">return diskID, nil</span>
}

// DeleteManagedDisk : delete managed disk
func (c *ManagedDiskController) DeleteManagedDisk(ctx context.Context, diskURI string) error <span class="cov8" title="1">{
        subsID, resourceGroup, diskName, err := azureutils.GetInfoFromURI(diskURI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if state, ok := c.diskStateMap.Load(strings.ToLower(diskURI)); ok </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete disk(%s) since it's in %s state", diskURI, state.(string))
        }</span>

        <span class="cov8" title="1">diskClient, err := c.clientFactory.GetDiskClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">disk, err := diskClient.Get(ctx, resourceGroup, diskName)
        if err != nil </span><span class="cov8" title="1">{
                var respErr = &amp;azcore.ResponseError{}
                if errors.As(err, &amp;respErr) &amp;&amp; respErr.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        klog.V(2).Infof("azureDisk - disk(%s) is already deleted", diskURI)
                        return nil
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">if disk.ManagedBy != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("disk(%s) already attached to node(%s), could not be deleted", diskURI, *disk.ManagedBy)
        }</span>

        <span class="cov8" title="1">if err = diskClient.Delete(ctx, resourceGroup, diskName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // We don't need poll here, k8s will immediately stop referencing the disk
        // the disk will be eventually deleted - cleanly - by ARM
        <span class="cov8" title="1">klog.V(2).Infof("azureDisk - deleted a managed disk: %s", diskURI)
        return nil</span>
}

func (c *ManagedDiskController) GetDiskByURI(ctx context.Context, diskURI string) (*armcompute.Disk, error) <span class="cov8" title="1">{
        subsID, resourceGroup, diskName, err := azureutils.GetInfoFromURI(diskURI)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.GetDisk(ctx, subsID, resourceGroup, diskName)</span>
}

func (c *ManagedDiskController) GetDisk(ctx context.Context, subsID, resourceGroup, diskName string) (*armcompute.Disk, error) <span class="cov8" title="1">{
        diskclient, err := c.clientFactory.GetDiskClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return diskclient.Get(ctx, resourceGroup, diskName)</span>
}

// ResizeDisk Expand the disk to new size
func (c *ManagedDiskController) ResizeDisk(ctx context.Context, diskURI string, oldSize resource.Quantity, newSize resource.Quantity, supportOnlineResize bool) (resource.Quantity, error) <span class="cov8" title="1">{
        subsID, resourceGroup, diskName, err := azureutils.GetInfoFromURI(diskURI)
        if err != nil </span><span class="cov0" title="0">{
                return oldSize, err
        }</span>
        <span class="cov8" title="1">diskClient, err := c.clientFactory.GetDiskClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return oldSize, err
        }</span>
        <span class="cov8" title="1">result, err := diskClient.Get(ctx, resourceGroup, diskName)
        if err != nil </span><span class="cov8" title="1">{
                return oldSize, err
        }</span>

        <span class="cov8" title="1">if result == nil || result.Properties == nil || result.Properties.DiskSizeGB == nil </span><span class="cov8" title="1">{
                return oldSize, fmt.Errorf("DiskProperties of disk(%s) is nil", diskName)
        }</span>

        // Azure resizes in chunks of GiB (not GB)
        <span class="cov8" title="1">requestGiB, err := volumehelpers.RoundUpToGiBInt32(newSize)
        if err != nil </span><span class="cov0" title="0">{
                return oldSize, err
        }</span>

        <span class="cov8" title="1">newSizeQuant := resource.MustParse(fmt.Sprintf("%dGi", requestGiB))

        klog.V(2).Infof("azureDisk - begin to resize disk(%s) with new size(%d), old size(%v)", diskName, requestGiB, oldSize)
        // If disk already of greater or equal size than requested we return
        if *result.Properties.DiskSizeGB &gt;= requestGiB </span><span class="cov8" title="1">{
                return newSizeQuant, nil
        }</span>

        <span class="cov8" title="1">if !supportOnlineResize &amp;&amp; *result.Properties.DiskState != armcompute.DiskStateUnattached </span><span class="cov8" title="1">{
                return oldSize, fmt.Errorf("azureDisk - disk resize is only supported on Unattached disk, current disk state: %s, already attached to %s", *result.Properties.DiskState, ptr.Deref(result.ManagedBy, ""))
        }</span>

        <span class="cov8" title="1">diskParameter := armcompute.DiskUpdate{
                Properties: &amp;armcompute.DiskUpdateProperties{
                        DiskSizeGB: &amp;requestGiB,
                },
        }

        if _, err := diskClient.Patch(ctx, resourceGroup, diskName, diskParameter); err != nil </span><span class="cov8" title="1">{
                return oldSize, err
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("azureDisk - resize disk(%s) with new size(%d) completed", diskName, requestGiB)
        return newSizeQuant, nil</span>
}

// ModifyDisk: modify disk
func (c *ManagedDiskController) ModifyDisk(ctx context.Context, options *ManagedDiskOptions) error <span class="cov8" title="1">{
        klog.V(4).Infof("azureDisk - modifying managed disk URI:%s, StorageAccountType:%s, DiskIOPSReadWrite:%s, DiskMBpsReadWrite:%s", options.SourceResourceID, options.StorageAccountType, options.DiskIOPSReadWrite, options.DiskMBpsReadWrite)

        subsID, rg, diskName, err := azureutils.GetInfoFromURI(options.SourceResourceID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">diskClient, err := c.clientFactory.GetDiskClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">result, err := diskClient.Get(ctx, rg, diskName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if result == nil || result.Properties == nil || result.SKU == nil || result.SKU.Name == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("DiskProperties or SKU of disk(%s) is nil", diskName)
        }</span>

        <span class="cov8" title="1">model := armcompute.DiskUpdate{}
        diskSku := *result.SKU.Name
        if options.StorageAccountType != "" &amp;&amp; options.StorageAccountType != diskSku </span><span class="cov8" title="1">{
                diskSku = options.StorageAccountType
                model.SKU = &amp;armcompute.DiskSKU{
                        Name: to.Ptr(diskSku),
                }
        }</span>

        <span class="cov8" title="1">diskProperties := armcompute.DiskUpdateProperties{}

        if diskSku == armcompute.DiskStorageAccountTypesUltraSSDLRS || diskSku == armcompute.DiskStorageAccountTypesPremiumV2LRS </span><span class="cov8" title="1">{
                if options.DiskIOPSReadWrite != "" </span><span class="cov8" title="1">{
                        v, err := strconv.Atoi(options.DiskIOPSReadWrite)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("AzureDisk - failed to parse DiskIOPSReadWrite: %w", err)
                        }</span>
                        <span class="cov8" title="1">diskIOPSReadWrite := int64(v)
                        diskProperties.DiskIOPSReadWrite = ptr.To(int64(diskIOPSReadWrite))</span>
                }

                <span class="cov8" title="1">if options.DiskMBpsReadWrite != "" </span><span class="cov8" title="1">{
                        v, err := strconv.Atoi(options.DiskMBpsReadWrite)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("AzureDisk - failed to parse DiskMBpsReadWrite: %w", err)
                        }</span>
                        <span class="cov8" title="1">diskMBpsReadWrite := int64(v)
                        diskProperties.DiskMBpsReadWrite = ptr.To(int64(diskMBpsReadWrite))</span>
                }

                <span class="cov8" title="1">model.Properties = &amp;diskProperties</span>
        } else<span class="cov8" title="1"> {
                if options.DiskIOPSReadWrite != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("AzureDisk - DiskIOPSReadWrite parameter is only applicable in UltraSSD_LRS or PremiumV2_LRS disk type")
                }</span>
                <span class="cov8" title="1">if options.DiskMBpsReadWrite != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("AzureDisk - DiskMBpsReadWrite parameter is only applicable in UltraSSD_LRS or PremiumV2_LRS disk type")
                }</span>
        }

        <span class="cov8" title="1">if model.SKU != nil || model.Properties != nil </span><span class="cov8" title="1">{
                if _, err := diskClient.Patch(ctx, rg, diskName, model); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                klog.V(4).Infof("azureDisk - no modification needed for disk(%s)", diskName)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/container-storage-interface/spec/lib/go/csi"
        "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        grpcprom "github.com/grpc-ecosystem/go-grpc-middleware/providers/prometheus"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        k8stypes "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        clientset "k8s.io/client-go/kubernetes"
        "k8s.io/klog/v2"
        "k8s.io/kubernetes/pkg/volume/util/hostutil"
        "k8s.io/mount-utils"
        "k8s.io/utils/ptr"

        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
        csicommon "sigs.k8s.io/azuredisk-csi-driver/pkg/csi-common"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/mounter"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
        volumehelper "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        "sigs.k8s.io/cloud-provider-azure/pkg/azclient"
        azcache "sigs.k8s.io/cloud-provider-azure/pkg/cache"
        azurecloudconsts "sigs.k8s.io/cloud-provider-azure/pkg/consts"
        azure "sigs.k8s.io/cloud-provider-azure/pkg/provider"
)

var (
        // taintRemovalBackoff is the exponential backoff configuration for node taint removal
        taintRemovalBackoff = wait.Backoff{
                Duration: 500 * time.Millisecond,
                Factor:   2,
                Steps:    10, // Max delay = 0.5 * 2^9 = ~4 minutes
        }
)

// CSIDriver defines the interface for a CSI driver.
type CSIDriver interface {
        csi.ControllerServer
        csi.NodeServer
        csi.IdentityServer

        Run(ctx context.Context) error
}

type hostUtil interface {
        PathIsDevice(string) (bool, error)
}

// Driver is the implementation of the Azure Disk CSI Driver.
type Driver struct {
        csicommon.CSIDriver
        // Embed UnimplementedXXXServer to ensure the driver returns Unimplemented for any
        // new RPC methods that might be introduced in future versions of the spec.
        csi.UnimplementedControllerServer
        csi.UnimplementedIdentityServer
        csi.UnimplementedNodeServer

        perfOptimizationEnabled      bool
        cloudConfigSecretName        string
        cloudConfigSecretNamespace   string
        customUserAgent              string
        userAgentSuffix              string
        cloud                        *azure.Cloud
        clientFactory                azclient.ClientFactory
        diskController               *ManagedDiskController
        mounter                      *mount.SafeFormatAndMount
        deviceHelper                 optimization.Interface
        nodeInfo                     *optimization.NodeInfo
        ioHandler                    azureutils.IOHandler
        hostUtil                     hostUtil
        useCSIProxyGAInterface       bool
        enableDiskOnlineResize       bool
        allowEmptyCloudConfig        bool
        enableListVolumes            bool
        enableListSnapshots          bool
        supportZone                  bool
        getNodeInfoFromLabels        bool
        enableDiskCapacityCheck      bool
        enableTrafficManager         bool
        trafficManagerPort           int64
        vmssCacheTTLInSeconds        int64
        volStatsCacheExpireInMinutes int64
        attachDetachInitialDelayInMs int64
        getDiskTimeoutInSeconds      int64
        vmType                       string
        enableWindowsHostProcess     bool
        useWinCIMAPI                 bool
        getNodeIDFromIMDS            bool
        enableOtelTracing            bool
        shouldWaitForSnapshotReady   bool
        checkDiskLUNCollision        bool
        checkDiskCountForBatching    bool
        forceDetachBackoff           bool
        waitForDetach                bool
        endpoint                     string
        disableAVSetNodes            bool
        removeNotReadyTaint          bool
        kubeClient                   clientset.Interface
        // a timed cache storing volume stats &lt;volumeID, volumeStats&gt;
        volStatsCache           azcache.Resource
        maxConcurrentFormat     int64
        concurrentFormatTimeout int64
        enableMinimumRetryAfter bool
        volumeLocks             *volumehelper.VolumeLocks
        // a timed cache for throttling
        throttlingCache azcache.Resource
        // a timed cache for disk lun collision check throttling
        checkDiskLunThrottlingCache azcache.Resource
}

// NewDriver Creates a NewCSIDriver object. Assumes vendor version is equal to driver version &amp;
// does not support optional driver plugin info manifest field. Refer to CSI spec for more details.
func NewDriver(options *DriverOptions) *Driver <span class="cov8" title="1">{
        driver := Driver{}
        driver.Name = options.DriverName
        driver.Version = driverVersion
        driver.NodeID = options.NodeID
        driver.VolumeAttachLimit = options.VolumeAttachLimit
        driver.ReservedDataDiskSlotNum = options.ReservedDataDiskSlotNum
        driver.perfOptimizationEnabled = options.EnablePerfOptimization
        driver.cloudConfigSecretName = options.CloudConfigSecretName
        driver.cloudConfigSecretNamespace = options.CloudConfigSecretNamespace
        driver.customUserAgent = options.CustomUserAgent
        driver.userAgentSuffix = options.UserAgentSuffix
        driver.useCSIProxyGAInterface = options.UseCSIProxyGAInterface
        driver.enableDiskOnlineResize = options.EnableDiskOnlineResize
        driver.allowEmptyCloudConfig = options.AllowEmptyCloudConfig
        driver.enableListVolumes = options.EnableListVolumes
        driver.enableListSnapshots = options.EnableListVolumes
        driver.supportZone = options.SupportZone
        driver.getNodeInfoFromLabels = options.GetNodeInfoFromLabels
        driver.enableDiskCapacityCheck = options.EnableDiskCapacityCheck
        driver.attachDetachInitialDelayInMs = options.AttachDetachInitialDelayInMs
        driver.enableTrafficManager = options.EnableTrafficManager
        driver.trafficManagerPort = options.TrafficManagerPort
        driver.vmssCacheTTLInSeconds = options.VMSSCacheTTLInSeconds
        driver.volStatsCacheExpireInMinutes = options.VolStatsCacheExpireInMinutes
        driver.getDiskTimeoutInSeconds = options.GetDiskTimeoutInSeconds
        driver.vmType = options.VMType
        driver.enableWindowsHostProcess = options.EnableWindowsHostProcess
        driver.useWinCIMAPI = options.UseWinCIMAPI
        driver.getNodeIDFromIMDS = options.GetNodeIDFromIMDS
        driver.enableOtelTracing = options.EnableOtelTracing
        driver.shouldWaitForSnapshotReady = options.WaitForSnapshotReady
        driver.checkDiskLUNCollision = options.CheckDiskLUNCollision
        driver.checkDiskCountForBatching = options.CheckDiskCountForBatching
        driver.forceDetachBackoff = options.ForceDetachBackoff
        driver.waitForDetach = options.WaitForDetach
        driver.endpoint = options.Endpoint
        driver.disableAVSetNodes = options.DisableAVSetNodes
        driver.removeNotReadyTaint = options.RemoveNotReadyTaint
        driver.maxConcurrentFormat = options.MaxConcurrentFormat
        driver.concurrentFormatTimeout = options.ConcurrentFormatTimeout
        driver.enableMinimumRetryAfter = options.EnableMinimumRetryAfter
        driver.volumeLocks = volumehelper.NewVolumeLocks()
        driver.ioHandler = azureutils.NewOSIOHandler()
        driver.hostUtil = hostutil.NewHostUtil()

        if driver.NodeID == "" </span><span class="cov8" title="1">{
                // nodeid is not needed in controller component
                klog.Warning("nodeid is empty")
        }</span>
        <span class="cov8" title="1">topologyKey = fmt.Sprintf("topology.%s/zone", driver.Name)

        getter := func(_ context.Context, _ string) (interface{}, error) </span><span class="cov0" title="0">{ return nil, nil }</span>
        <span class="cov8" title="1">var err error
        if driver.throttlingCache, err = azcache.NewTimedCache(5*time.Minute, getter, false); err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("%v", err)
        }</span>
        <span class="cov8" title="1">if driver.checkDiskLunThrottlingCache, err = azcache.NewTimedCache(30*time.Minute, getter, false); err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("%v", err)
        }</span>

        <span class="cov8" title="1">if options.VolStatsCacheExpireInMinutes &lt;= 0 </span><span class="cov8" title="1">{
                options.VolStatsCacheExpireInMinutes = 10 // default expire in 10 minutes
        }</span>
        <span class="cov8" title="1">if driver.volStatsCache, err = azcache.NewTimedCache(time.Duration(options.VolStatsCacheExpireInMinutes)*time.Minute, getter, false); err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("%v", err)
        }</span>

        <span class="cov8" title="1">userAgent := GetUserAgent(driver.Name, driver.customUserAgent, driver.userAgentSuffix)
        klog.V(2).Infof("driver userAgent: %s", userAgent)

        kubeClient, err := azureutils.GetKubeClient(options.Kubeconfig)
        if err != nil </span><span class="cov8" title="1">{
                klog.Warningf("get kubeconfig(%s) failed with error: %v", options.Kubeconfig, err)
        }</span>
        <span class="cov8" title="1">driver.kubeClient = kubeClient

        cloud, err := azureutils.GetCloudProviderFromClient(context.Background(), kubeClient, driver.cloudConfigSecretName, driver.cloudConfigSecretNamespace,
                userAgent, driver.allowEmptyCloudConfig, driver.enableTrafficManager, driver.enableMinimumRetryAfter, driver.trafficManagerPort)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("failed to get Azure Cloud Provider, error: %v", err)
        }</span>
        <span class="cov8" title="1">driver.cloud = cloud

        if driver.cloud != nil </span><span class="cov8" title="1">{
                driver.clientFactory = driver.cloud.ComputeClientFactory
                if driver.vmType != "" </span><span class="cov8" title="1">{
                        klog.V(2).Infof("override VMType(%s) in cloud config as %s", driver.cloud.VMType, driver.vmType)
                        driver.cloud.VMType = driver.vmType
                }</span>

                <span class="cov8" title="1">if driver.NodeID == "" </span><span class="cov8" title="1">{
                        // Disable UseInstanceMetadata for controller to mitigate a timeout issue using IMDS
                        // https://github.com/kubernetes-sigs/azuredisk-csi-driver/issues/168
                        klog.V(2).Infof("disable UseInstanceMetadata for controller")
                        driver.cloud.Config.UseInstanceMetadata = false

                        if driver.cloud.VMType == azurecloudconsts.VMTypeStandard &amp;&amp; driver.cloud.DisableAvailabilitySetNodes </span><span class="cov0" title="0">{
                                klog.V(2).Infof("set DisableAvailabilitySetNodes as false since VMType is %s", driver.cloud.VMType)
                                driver.cloud.DisableAvailabilitySetNodes = false
                        }</span>

                        <span class="cov8" title="1">if driver.cloud.VMType == azurecloudconsts.VMTypeVMSS &amp;&amp; !driver.cloud.DisableAvailabilitySetNodes &amp;&amp; driver.disableAVSetNodes </span><span class="cov0" title="0">{
                                klog.V(2).Infof("DisableAvailabilitySetNodes for controller since current VMType is vmss")
                                driver.cloud.DisableAvailabilitySetNodes = true
                        }</span>
                        <span class="cov8" title="1">klog.V(2).Infof("cloud: %s, location: %s, rg: %s, VMType: %s, PrimaryScaleSetName: %s, PrimaryAvailabilitySetName: %s, DisableAvailabilitySetNodes: %v", driver.cloud.Cloud, driver.cloud.Location, driver.cloud.ResourceGroup, driver.cloud.VMType, driver.cloud.PrimaryScaleSetName, driver.cloud.PrimaryAvailabilitySetName, driver.cloud.DisableAvailabilitySetNodes)</span>
                }

                <span class="cov8" title="1">if driver.vmssCacheTTLInSeconds &gt; 0 </span><span class="cov8" title="1">{
                        klog.V(2).Infof("reset vmssCacheTTLInSeconds as %d", driver.vmssCacheTTLInSeconds)
                        driver.cloud.VMCacheTTLInSeconds = int(driver.vmssCacheTTLInSeconds)
                        driver.cloud.VmssCacheTTLInSeconds = int(driver.vmssCacheTTLInSeconds)
                }</span>

                <span class="cov8" title="1">driver.diskController = NewManagedDiskController(driver.cloud)
                driver.diskController.AttachDetachInitialDelayInMs = int(driver.attachDetachInitialDelayInMs)
                driver.diskController.ForceDetachBackoff = driver.forceDetachBackoff
                driver.diskController.WaitForDetach = driver.waitForDetach
                driver.diskController.CheckDiskCountForBatching = driver.checkDiskCountForBatching</span>
        }

        <span class="cov8" title="1">driver.deviceHelper = optimization.NewSafeDeviceHelper()

        if driver.getPerfOptimizationEnabled() </span><span class="cov8" title="1">{
                driver.nodeInfo, err = optimization.NewNodeInfo(context.TODO(), driver.getCloud(), driver.NodeID)
                if err != nil </span><span class="cov8" title="1">{
                        klog.Warningf("Failed to get node info. Error: %v", err)
                }</span>
        }

        <span class="cov8" title="1">driver.mounter, err = mounter.NewSafeMounter(driver.enableWindowsHostProcess, driver.useWinCIMAPI, driver.useCSIProxyGAInterface, int(driver.maxConcurrentFormat), time.Duration(driver.concurrentFormatTimeout)*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to get safe mounter. Error: %v", err)
        }</span>

        <span class="cov8" title="1">controllerCap := []csi.ControllerServiceCapability_RPC_Type{
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME,
                csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME,
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT,
                csi.ControllerServiceCapability_RPC_CLONE_VOLUME,
                csi.ControllerServiceCapability_RPC_EXPAND_VOLUME,
                csi.ControllerServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER,
                csi.ControllerServiceCapability_RPC_MODIFY_VOLUME,
        }
        if driver.enableListVolumes </span><span class="cov8" title="1">{
                controllerCap = append(controllerCap, csi.ControllerServiceCapability_RPC_LIST_VOLUMES, csi.ControllerServiceCapability_RPC_LIST_VOLUMES_PUBLISHED_NODES)
        }</span>
        <span class="cov8" title="1">if driver.enableListSnapshots </span><span class="cov8" title="1">{
                controllerCap = append(controllerCap, csi.ControllerServiceCapability_RPC_LIST_SNAPSHOTS)
        }</span>

        <span class="cov8" title="1">driver.AddControllerServiceCapabilities(controllerCap)
        driver.AddVolumeCapabilityAccessModes(
                []csi.VolumeCapability_AccessMode_Mode{
                        csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
                        csi.VolumeCapability_AccessMode_SINGLE_NODE_READER_ONLY,
                        csi.VolumeCapability_AccessMode_SINGLE_NODE_SINGLE_WRITER,
                        csi.VolumeCapability_AccessMode_SINGLE_NODE_MULTI_WRITER,
                })
        driver.AddNodeServiceCapabilities([]csi.NodeServiceCapability_RPC_Type{
                csi.NodeServiceCapability_RPC_STAGE_UNSTAGE_VOLUME,
                csi.NodeServiceCapability_RPC_EXPAND_VOLUME,
                csi.NodeServiceCapability_RPC_GET_VOLUME_STATS,
                csi.NodeServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER,
        })

        if kubeClient != nil &amp;&amp; driver.removeNotReadyTaint &amp;&amp; driver.NodeID != "" </span><span class="cov0" title="0">{
                // Remove taint from node to indicate driver startup success
                // This is done at the last possible moment to prevent race conditions or false positive removals
                time.AfterFunc(time.Duration(options.TaintRemovalInitialDelayInSeconds)*time.Second, func() </span><span class="cov0" title="0">{
                        removeTaintInBackground(kubeClient, driver.NodeID, driver.Name, taintRemovalBackoff, removeNotReadyTaint)
                }</span>)
        }
        <span class="cov8" title="1">return &amp;driver</span>
}

// Run driver initialization
func (d *Driver) Run(ctx context.Context) error <span class="cov8" title="1">{
        versionMeta, err := GetVersionYAML(d.Name)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("%v", err)
        }</span>
        <span class="cov8" title="1">klog.Infof("\nDRIVER INFORMATION:\n-------------------\n%s\n\nStreaming logs below:", versionMeta)

        opts := []grpc.ServerOption{
                grpc.ChainUnaryInterceptor(
                        grpcprom.NewServerMetrics().UnaryServerInterceptor(),
                        csicommon.LogGRPC,
                ),
        }
        if d.enableOtelTracing </span><span class="cov0" title="0">{
                exporter, err := InitOtelTracing()
                if err != nil </span><span class="cov0" title="0">{
                        klog.Fatalf("Failed to initialize otel tracing: %v", err)
                }</span>
                // Exporter will flush traces on shutdown
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := exporter.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                                klog.Errorf("Could not shutdown otel exporter: %v", err)
                        }</span>
                }()
                <span class="cov0" title="0">opts = append(opts, grpc.StatsHandler(otelgrpc.NewServerHandler()))</span>
        }

        <span class="cov8" title="1">s := grpc.NewServer(opts...)
        csi.RegisterIdentityServer(s, d)
        csi.RegisterControllerServer(s, d)
        csi.RegisterNodeServer(s, d)

        go func() </span><span class="cov8" title="1">{
                //graceful shutdown
                &lt;-ctx.Done()
                s.GracefulStop()
        }</span>()
        // Driver d act as IdentityServer, ControllerServer and NodeServer
        <span class="cov8" title="1">listener, err := csicommon.Listen(ctx, d.endpoint)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("failed to listen to endpoint, error: %v", err)
        }</span>
        <span class="cov8" title="1">err = s.Serve(listener)
        if errors.Is(err, grpc.ErrServerStopped) </span><span class="cov8" title="1">{
                klog.Infof("gRPC server stopped serving")
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (d *Driver) isGetDiskThrottled(ctx context.Context) bool <span class="cov8" title="1">{
        cache, err := d.throttlingCache.Get(ctx, consts.GetDiskThrottlingKey, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("throttlingCache(%s) return with error: %s", consts.GetDiskThrottlingKey, err)
                return false
        }</span>
        <span class="cov8" title="1">return cache != nil</span>
}

func (d *Driver) isCheckDiskLunThrottled(ctx context.Context) bool <span class="cov0" title="0">{
        cache, err := d.checkDiskLunThrottlingCache.Get(ctx, consts.CheckDiskLunThrottlingKey, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("throttlingCache(%s) return with error: %s", consts.CheckDiskLunThrottlingKey, err)
                return false
        }</span>
        <span class="cov0" title="0">return cache != nil</span>
}

func (d *Driver) checkDiskExists(ctx context.Context, diskURI string) (*armcompute.Disk, error) <span class="cov8" title="1">{
        if d.isGetDiskThrottled(ctx) </span><span class="cov8" title="1">{
                klog.Warningf("skip checkDiskExists(%s) since it's still in throttling", diskURI)
                return nil, nil
        }</span>

        <span class="cov8" title="1">newCtx, cancel := context.WithTimeout(ctx, time.Duration(d.getDiskTimeoutInSeconds)*time.Second)
        defer cancel()
        return d.diskController.GetDiskByURI(newCtx, diskURI)</span>
}

func (d *Driver) checkDiskCapacity(ctx context.Context, subsID, resourceGroup, diskName string, requestGiB int) (bool, error) <span class="cov8" title="1">{
        if d.isGetDiskThrottled(ctx) </span><span class="cov8" title="1">{
                klog.Warningf("skip checkDiskCapacity(%s, %s) since it's still in throttling", resourceGroup, diskName)
                return true, nil
        }</span>
        <span class="cov8" title="1">disk, err := d.diskController.GetDisk(ctx, subsID, resourceGroup, diskName)
        // Because we can not judge the reason of the error. Maybe the disk does not exist.
        // So here we do not handle the error.
        if err == nil </span><span class="cov8" title="1">{
                if !reflect.DeepEqual(disk, armcompute.Disk{}) &amp;&amp; disk.Properties.DiskSizeGB != nil &amp;&amp; int(*disk.Properties.DiskSizeGB) != requestGiB </span><span class="cov8" title="1">{
                        return false, status.Errorf(codes.AlreadyExists, "the request volume already exists, but its capacity(%v) is different from (%v)", *disk.Properties.DiskSizeGB, requestGiB)
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

func (d *Driver) getVolumeLocks() *volumehelper.VolumeLocks <span class="cov8" title="1">{
        return d.volumeLocks
}</span>

// setControllerCapabilities sets the controller capabilities field. It is intended for use with unit tests.
func (d *Driver) setControllerCapabilities(caps []*csi.ControllerServiceCapability) <span class="cov8" title="1">{
        d.Cap = caps
}</span>

// setNodeCapabilities sets the node capabilities field. It is intended for use with unit tests.
func (d *Driver) setNodeCapabilities(nodeCaps []*csi.NodeServiceCapability) <span class="cov8" title="1">{
        d.NSCap = nodeCaps
}</span>

// setName sets the Name field. It is intended for use with unit tests.
func (d *Driver) setName(name string) <span class="cov8" title="1">{
        d.Name = name
}</span>

// setName sets the NodeId field. It is intended for use with unit tests.
func (d *Driver) setNodeID(nodeID string) <span class="cov8" title="1">{
        d.NodeID = nodeID
}</span>

// setName sets the Version field. It is intended for use with unit tests.
func (d *Driver) setVersion(version string) <span class="cov8" title="1">{
        d.Version = version
}</span>

// getCloud returns the value of the cloud field. It is intended for use with unit tests.
func (d *Driver) getCloud() *azure.Cloud <span class="cov8" title="1">{
        return d.cloud
}</span>

// setCloud sets the cloud field. It is intended for use with unit tests.
func (d *Driver) setCloud(cloud *azure.Cloud) <span class="cov8" title="1">{
        d.cloud = cloud
}</span>

// getMounter returns the value of the mounter field. It is intended for use with unit tests.
func (d *Driver) getMounter() *mount.SafeFormatAndMount <span class="cov8" title="1">{
        return d.mounter
}</span>

// setMounter sets the mounter field. It is intended for use with unit tests.
func (d *Driver) setMounter(mounter *mount.SafeFormatAndMount) <span class="cov8" title="1">{
        d.mounter = mounter
}</span>

// getPerfOptimizationEnabled returns the value of the perfOptimizationEnabled field. It is intended for use with unit tests.
func (d *Driver) getPerfOptimizationEnabled() bool <span class="cov8" title="1">{
        return d.perfOptimizationEnabled
}</span>

// setPerfOptimizationEnabled sets the value of the perfOptimizationEnabled field. It is intended for use with unit tests.
func (d *Driver) setPerfOptimizationEnabled(enabled bool) <span class="cov8" title="1">{
        d.perfOptimizationEnabled = enabled
}</span>

// getDeviceHelper returns the value of the deviceHelper field. It is intended for use with unit tests.
func (d *Driver) getDeviceHelper() optimization.Interface <span class="cov8" title="1">{
        return d.deviceHelper
}</span>

// getNodeInfo returns the value of the nodeInfo field. It is intended for use with unit tests.
func (d *Driver) getNodeInfo() *optimization.NodeInfo <span class="cov8" title="1">{
        return d.nodeInfo
}</span>

func (d *Driver) getHostUtil() hostUtil <span class="cov8" title="1">{
        return d.hostUtil
}</span>

// getSnapshotCompletionPercent returns the completion percent of snapshot
func (d *Driver) getSnapshotCompletionPercent(ctx context.Context, subsID, resourceGroup, snapshotName string) (float32, error) <span class="cov8" title="1">{
        snapshotClient, err := d.clientFactory.GetSnapshotClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, err
        }</span>
        <span class="cov8" title="1">copySnapshot, err := snapshotClient.Get(ctx, resourceGroup, snapshotName)
        if err != nil </span><span class="cov8" title="1">{
                return 0.0, err
        }</span>

        <span class="cov8" title="1">if copySnapshot.Properties == nil || copySnapshot.Properties.CompletionPercent == nil </span><span class="cov8" title="1">{
                // If CompletionPercent is nil, it means the snapshot is complete
                klog.V(2).Infof("snapshot(%s) under rg(%s) has no SnapshotProperties or CompletionPercent is nil", snapshotName, resourceGroup)
                return 100.0, nil
        }</span>

        <span class="cov8" title="1">return *copySnapshot.Properties.CompletionPercent, nil</span>
}

// waitForSnapshotReady wait for completionPercent of snapshot is 100.0
func (d *Driver) waitForSnapshotReady(ctx context.Context, subsID, resourceGroup, snapshotName string, intervel, timeout time.Duration) error <span class="cov8" title="1">{
        completionPercent, err := d.getSnapshotCompletionPercent(ctx, subsID, resourceGroup, snapshotName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if completionPercent &gt;= float32(100.0) </span><span class="cov8" title="1">{
                klog.V(2).Infof("snapshot(%s) under rg(%s) complete", snapshotName, resourceGroup)
                return nil
        }</span>

        <span class="cov8" title="1">timeTick := time.Tick(intervel)
        timeAfter := time.After(timeout)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timeTick:<span class="cov8" title="1">
                        completionPercent, err = d.getSnapshotCompletionPercent(ctx, subsID, resourceGroup, snapshotName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if completionPercent &gt;= float32(100.0) </span><span class="cov8" title="1">{
                                klog.V(2).Infof("snapshot(%s) under rg(%s) complete", snapshotName, resourceGroup)
                                return nil
                        }</span>
                        <span class="cov8" title="1">klog.V(2).Infof("snapshot(%s) under rg(%s) completionPercent: %f", snapshotName, resourceGroup, completionPercent)</span>
                case &lt;-timeAfter:<span class="cov8" title="1">
                        return fmt.Errorf("timeout waiting for snapshot(%s) under rg(%s)", snapshotName, resourceGroup)</span>
                }
        }
}

// getUsedLunsFromVolumeAttachments returns a list of used luns from VolumeAttachments
func (d *Driver) getUsedLunsFromVolumeAttachments(ctx context.Context, nodeName string) ([]int, error) <span class="cov8" title="1">{
        kubeClient := d.cloud.KubeClient
        if kubeClient == nil || kubeClient.StorageV1() == nil || kubeClient.StorageV1().VolumeAttachments() == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("kubeClient or kubeClient.StorageV1() or kubeClient.StorageV1().VolumeAttachments() is nil")
        }</span>

        <span class="cov0" title="0">volumeAttachments, err := kubeClient.StorageV1().VolumeAttachments().List(ctx, metav1.ListOptions{
                TimeoutSeconds: ptr.To(int64(2))})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">usedLuns := make([]int, 0)
        if volumeAttachments == nil </span><span class="cov0" title="0">{
                klog.V(2).Infof("volumeAttachments is nil")
                return usedLuns, nil
        }</span>

        <span class="cov0" title="0">klog.V(2).Infof("volumeAttachments count: %d, nodeName: %s", len(volumeAttachments.Items), nodeName)
        for _, va := range volumeAttachments.Items </span><span class="cov0" title="0">{
                klog.V(6).Infof("attacher: %s, nodeName: %s, Status: %v, PV: %s, attachmentMetadata: %v", va.Spec.Attacher, va.Spec.NodeName,
                        va.Status.Attached, ptr.Deref(va.Spec.Source.PersistentVolumeName, ""), va.Status.AttachmentMetadata)
                if va.Spec.Attacher == d.Name &amp;&amp; strings.EqualFold(va.Spec.NodeName, nodeName) &amp;&amp; va.Status.Attached </span><span class="cov0" title="0">{
                        if k, ok := va.Status.AttachmentMetadata[consts.LUN]; ok </span><span class="cov0" title="0">{
                                lun, err := strconv.Atoi(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Warningf("VolumeAttachment(%s) lun(%s) is not a valid integer", va.Name, k)
                                        continue</span>
                                }
                                <span class="cov0" title="0">usedLuns = append(usedLuns, lun)</span>
                        }
                }
        }
        <span class="cov0" title="0">return usedLuns, nil</span>
}

// getUsedLunsFromNode returns a list of sorted used luns from Node
func (d *Driver) getUsedLunsFromNode(ctx context.Context, nodeName k8stypes.NodeName) ([]int, error) <span class="cov8" title="1">{
        disks, _, err := d.diskController.GetNodeDataDisks(ctx, nodeName, azcache.CacheReadTypeDefault)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("error of getting data disks for node %s: %v", nodeName, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">usedLuns := make([]int, 0)
        // get all disks attached to the node
        for _, disk := range disks </span><span class="cov8" title="1">{
                if disk.Lun == nil </span><span class="cov0" title="0">{
                        klog.Warningf("disk(%s) lun is nil", *disk.Name)
                        continue</span>
                }
                <span class="cov8" title="1">usedLuns = append(usedLuns, int(*disk.Lun))</span>
        }
        <span class="cov8" title="1">return usedLuns, nil</span>
}

// getNodeInfoFromLabels get zone, instanceType from node labels
func GetNodeInfoFromLabels(ctx context.Context, nodeName string, kubeClient clientset.Interface) (string, string, error) <span class="cov8" title="1">{
        if kubeClient == nil || kubeClient.CoreV1() == nil </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("kubeClient is nil")
        }</span>

        <span class="cov0" title="0">node, err := kubeClient.CoreV1().Nodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("get node(%s) failed with %v", nodeName, err)
        }</span>

        <span class="cov0" title="0">if len(node.Labels) == 0 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("node(%s) label is empty", nodeName)
        }</span>
        <span class="cov0" title="0">return node.Labels[consts.WellKnownTopologyKey], node.Labels[consts.InstanceTypeKey], nil</span>
}

// getDefaultDiskIOPSReadWrite according to requestGiB
//
//        ref: https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disk-iops
func getDefaultDiskIOPSReadWrite(requestGiB int) int <span class="cov8" title="1">{
        iops := azurecloudconsts.DefaultDiskIOPSReadWrite
        if requestGiB &gt; iops </span><span class="cov8" title="1">{
                iops = requestGiB
        }</span>
        <span class="cov8" title="1">if iops &gt; 160000 </span><span class="cov8" title="1">{
                iops = 160000
        }</span>
        <span class="cov8" title="1">return iops</span>
}

// getDefaultDiskMBPSReadWrite according to requestGiB
//
//        ref: https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disk-throughput
func getDefaultDiskMBPSReadWrite(requestGiB int) int <span class="cov8" title="1">{
        bandwidth := azurecloudconsts.DefaultDiskMBpsReadWrite
        iops := getDefaultDiskIOPSReadWrite(requestGiB)
        if iops/256 &gt; bandwidth </span><span class="cov8" title="1">{
                bandwidth = int(volumehelper.RoundUpSize(int64(iops), 256))
        }</span>
        <span class="cov8" title="1">if bandwidth &gt; iops/4 </span><span class="cov0" title="0">{
                bandwidth = int(volumehelper.RoundUpSize(int64(iops), 4))
        }</span>
        <span class="cov8" title="1">if bandwidth &gt; 4000 </span><span class="cov0" title="0">{
                bandwidth = 4000
        }</span>
        <span class="cov8" title="1">return bandwidth</span>
}

// getVMSSInstanceName get instance name from vmss compute name, e.g. "aks-agentpool-20657377-vmss_2" -&gt; "aks-agentpool-20657377-vmss000002"
func getVMSSInstanceName(computeName string) (string, error) <span class="cov8" title="1">{
        names := strings.Split(computeName, "_")
        if len(names) != 2 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid vmss compute name: %s", computeName)
        }</span>

        <span class="cov8" title="1">instanceID, err := strconv.Atoi(names[1])
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("parsing vmss compute name(%s) failed with %v", computeName, err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s%06s", names[0], strconv.FormatInt(int64(instanceID), 36)), nil</span>
}

// Struct for JSON patch operations
type JSONPatch struct {
        OP    string      `json:"op,omitempty"`
        Path  string      `json:"path,omitempty"`
        Value interface{} `json:"value"`
}

// removeTaintInBackground is a goroutine that retries removeNotReadyTaint with exponential backoff
func removeTaintInBackground(k8sClient clientset.Interface, nodeName, driverName string, backoff wait.Backoff, removalFunc func(clientset.Interface, string, string) error) <span class="cov0" title="0">{
        backoffErr := wait.ExponentialBackoff(backoff, func() (bool, error) </span><span class="cov0" title="0">{
                err := removalFunc(k8sClient, nodeName, driverName)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "Unexpected failure when attempting to remove node taint(s)")
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        })

        <span class="cov0" title="0">if backoffErr != nil </span><span class="cov0" title="0">{
                klog.ErrorS(backoffErr, "Retries exhausted, giving up attempting to remove node taint(s)")
        }</span>
}

// removeNotReadyTaint removes the taint disk.csi.azure.com/agent-not-ready from the local node
// This taint can be optionally applied by users to prevent startup race conditions such as
// https://github.com/kubernetes/kubernetes/issues/95911
func removeNotReadyTaint(clientset clientset.Interface, nodeName, driverName string) error <span class="cov0" title="0">{
        ctx := context.Background()
        node, err := clientset.CoreV1().Nodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := checkAllocatable(ctx, clientset, nodeName, driverName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">taintKeyToRemove := driverName + consts.AgentNotReadyNodeTaintKeySuffix
        klog.V(2).Infof("removing taint with key %s from local node %s", taintKeyToRemove, nodeName)
        var taintsToKeep []corev1.Taint
        for _, taint := range node.Spec.Taints </span><span class="cov0" title="0">{
                klog.V(5).Infof("checking taint key %s, value %s, effect %s", taint.Key, taint.Value, taint.Effect)
                if taint.Key != taintKeyToRemove </span><span class="cov0" title="0">{
                        taintsToKeep = append(taintsToKeep, taint)
                }</span> else<span class="cov0" title="0"> {
                        klog.V(2).Infof("queued taint for removal with key %s, effect %s", taint.Key, taint.Effect)
                }</span>
        }

        <span class="cov0" title="0">if len(taintsToKeep) == len(node.Spec.Taints) </span><span class="cov0" title="0">{
                klog.V(2).Infof("No taints to remove on node, skipping taint removal")
                return nil
        }</span>

        <span class="cov0" title="0">patchRemoveTaints := []JSONPatch{
                {
                        OP:    "test",
                        Path:  "/spec/taints",
                        Value: node.Spec.Taints,
                },
                {
                        OP:    "replace",
                        Path:  "/spec/taints",
                        Value: taintsToKeep,
                },
        }

        patch, err := json.Marshal(patchRemoveTaints)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = clientset.CoreV1().Nodes().Patch(ctx, nodeName, k8stypes.JSONPatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">klog.V(2).Infof("removed taint with key %s from local node %s successfully", taintKeyToRemove, nodeName)
        return nil</span>
}

func checkAllocatable(ctx context.Context, clientset clientset.Interface, nodeName, driverName string) error <span class="cov0" title="0">{
        csiNode, err := clientset.StorageV1().CSINodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("isAllocatableSet: failed to get CSINode for %s: %w", nodeName, err)
        }</span>

        <span class="cov0" title="0">for _, driver := range csiNode.Spec.Drivers </span><span class="cov0" title="0">{
                if driver.Name == driverName </span><span class="cov0" title="0">{
                        if driver.Allocatable != nil &amp;&amp; driver.Allocatable.Count != nil </span><span class="cov0" title="0">{
                                klog.V(2).Infof("CSINode Allocatable value is set for driver on node %s, count %d", nodeName, *driver.Allocatable.Count)
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("isAllocatableSet: allocatable value not set for driver on node %s", nodeName)</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("isAllocatableSet: driver not found on node %s", nodeName)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2023 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "flag"

        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
)

// DriverOptions defines driver parameters specified in driver deployment
type DriverOptions struct {
        // Common options
        NodeID                     string
        DriverName                 string
        VolumeAttachLimit          int64
        ReservedDataDiskSlotNum    int64
        EnablePerfOptimization     bool
        CloudConfigSecretName      string
        CloudConfigSecretNamespace string
        CustomUserAgent            string
        UserAgentSuffix            string
        UseCSIProxyGAInterface     bool
        EnableOtelTracing          bool
        EnableMinimumRetryAfter    bool

        //only used in v1
        EnableDiskOnlineResize            bool
        AllowEmptyCloudConfig             bool
        EnableListVolumes                 bool
        EnableListSnapshots               bool
        SupportZone                       bool
        GetNodeInfoFromLabels             bool
        EnableDiskCapacityCheck           bool
        EnableTrafficManager              bool
        TrafficManagerPort                int64
        AttachDetachInitialDelayInMs      int64
        VMSSCacheTTLInSeconds             int64
        VolStatsCacheExpireInMinutes      int64
        GetDiskTimeoutInSeconds           int64
        VMType                            string
        EnableWindowsHostProcess          bool
        UseWinCIMAPI                      bool
        GetNodeIDFromIMDS                 bool
        WaitForSnapshotReady              bool
        CheckDiskLUNCollision             bool
        ForceDetachBackoff                bool
        CheckDiskCountForBatching         bool
        WaitForDetach                     bool
        Kubeconfig                        string
        Endpoint                          string
        DisableAVSetNodes                 bool
        RemoveNotReadyTaint               bool
        TaintRemovalInitialDelayInSeconds int64
        MaxConcurrentFormat               int64
        ConcurrentFormatTimeout           int64
        GoMaxProcs                        int64
}

func (o *DriverOptions) AddFlags() *flag.FlagSet <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">fs := flag.NewFlagSet("", flag.ExitOnError)
        fs.StringVar(&amp;o.NodeID, "nodeid", "", "node id")
        fs.StringVar(&amp;o.DriverName, "drivername", consts.DefaultDriverName, "name of the driver")
        fs.Int64Var(&amp;o.VolumeAttachLimit, "volume-attach-limit", -1, "maximum number of attachable volumes per node")
        fs.Int64Var(&amp;o.ReservedDataDiskSlotNum, "reserved-data-disk-slot-num", 0, "reserved data disk slot number per node")
        fs.BoolVar(&amp;o.EnablePerfOptimization, "enable-perf-optimization", false, "boolean flag to enable disk perf optimization")
        fs.StringVar(&amp;o.CloudConfigSecretName, "cloud-config-secret-name", "azure-cloud-provider", "cloud config secret name")
        fs.StringVar(&amp;o.CloudConfigSecretNamespace, "cloud-config-secret-namespace", "kube-system", "cloud config secret namespace")
        fs.StringVar(&amp;o.CustomUserAgent, "custom-user-agent", "", "custom userAgent")
        fs.StringVar(&amp;o.UserAgentSuffix, "user-agent-suffix", "", "userAgent suffix")
        fs.BoolVar(&amp;o.UseCSIProxyGAInterface, "use-csiproxy-ga-interface", true, "boolean flag to enable csi-proxy GA interface on Windows")
        fs.BoolVar(&amp;o.EnableOtelTracing, "enable-otel-tracing", false, "If set, enable opentelemetry tracing for the driver. The tracing is disabled by default. Configure the exporter endpoint with OTEL_EXPORTER_OTLP_ENDPOINT and other env variables, see https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#general-sdk-configuration.")
        fs.BoolVar(&amp;o.EnableMinimumRetryAfter, "enable-minimum-retry-after", true, "boolean flag to enable minimum retry after policy in azclient")
        //only used in v1
        fs.BoolVar(&amp;o.EnableDiskOnlineResize, "enable-disk-online-resize", true, "boolean flag to enable disk online resize")
        fs.BoolVar(&amp;o.AllowEmptyCloudConfig, "allow-empty-cloud-config", true, "Whether allow running driver without cloud config")
        fs.BoolVar(&amp;o.EnableListVolumes, "enable-list-volumes", false, "boolean flag to enable ListVolumes on controller")
        fs.BoolVar(&amp;o.EnableListSnapshots, "enable-list-snapshots", false, "boolean flag to enable ListSnapshots on controller")
        fs.BoolVar(&amp;o.SupportZone, "support-zone", true, "boolean flag to get zone info in NodeGetInfo")
        fs.BoolVar(&amp;o.GetNodeInfoFromLabels, "get-node-info-from-labels", false, "boolean flag to get zone info from node labels in NodeGetInfo")
        fs.BoolVar(&amp;o.EnableDiskCapacityCheck, "enable-disk-capacity-check", false, "boolean flag to enable volume capacity check in CreateVolume")
        fs.BoolVar(&amp;o.EnableTrafficManager, "enable-traffic-manager", false, "boolean flag to enable traffic manager")
        fs.Int64Var(&amp;o.TrafficManagerPort, "traffic-manager-port", 7788, "default traffic manager port")
        fs.Int64Var(&amp;o.AttachDetachInitialDelayInMs, "attach-detach-initial-delay-ms", 1000, "initial delay in milliseconds for batch disk attach/detach")
        fs.Int64Var(&amp;o.VMSSCacheTTLInSeconds, "vmss-cache-ttl-seconds", -1, "vmss cache TTL in seconds (600 by default)")
        fs.Int64Var(&amp;o.VolStatsCacheExpireInMinutes, "vol-stats-cache-expire-in-minutes", 10, "The cache expire time in minutes for volume stats cache")
        fs.Int64Var(&amp;o.GetDiskTimeoutInSeconds, "get-disk-timeout-seconds", 15, "The timeout in seconds for getting disk")
        fs.StringVar(&amp;o.VMType, "vm-type", "", "type of agent node. available values: vmss, standard")
        fs.BoolVar(&amp;o.EnableWindowsHostProcess, "enable-windows-host-process", false, "enable windows host process")
        fs.BoolVar(&amp;o.UseWinCIMAPI, "use-win-cim-api", true, "whether perform disk operations using CIM API or Powershell command on Windows node")
        fs.BoolVar(&amp;o.GetNodeIDFromIMDS, "get-nodeid-from-imds", false, "boolean flag to get NodeID from IMDS")
        fs.BoolVar(&amp;o.WaitForSnapshotReady, "wait-for-snapshot-ready", false, "boolean flag to wait for snapshot ready when creating snapshot in same region")
        fs.BoolVar(&amp;o.CheckDiskLUNCollision, "check-disk-lun-collision", true, "boolean flag to check disk lun collisio before attaching disk")
        fs.BoolVar(&amp;o.CheckDiskCountForBatching, "check-disk-count-for-batching", true, "boolean flag to check disk count before creating a batch for disk attach")
        fs.BoolVar(&amp;o.ForceDetachBackoff, "force-detach-backoff", true, "boolean flag to force detach in disk detach backoff")
        fs.BoolVar(&amp;o.WaitForDetach, "wait-for-detach", true, "boolean flag to wait for detach before attaching disk on the same node")
        fs.StringVar(&amp;o.Kubeconfig, "kubeconfig", "", "Absolute path to the kubeconfig file. Required only when running out of cluster.")
        fs.BoolVar(&amp;o.DisableAVSetNodes, "disable-avset-nodes", false, "disable DisableAvailabilitySetNodes in cloud config for controller")
        fs.BoolVar(&amp;o.RemoveNotReadyTaint, "remove-not-ready-taint", true, "remove NotReady taint from node when node is ready")
        fs.Int64Var(&amp;o.TaintRemovalInitialDelayInSeconds, "taint-removal-initial-delay-seconds", 30, "initial delay in seconds for taint removal")
        fs.StringVar(&amp;o.Endpoint, "endpoint", "unix://tmp/csi.sock", "CSI endpoint")
        fs.Int64Var(&amp;o.MaxConcurrentFormat, "max-concurrent-format", 2, "maximum number of concurrent format exec calls")
        fs.Int64Var(&amp;o.ConcurrentFormatTimeout, "concurrent-format-timeout", 300, "maximum time in seconds duration of a format operation before its concurrency token is released")
        fs.Int64Var(&amp;o.GoMaxProcs, "max-procs", 2, "maximum number of CPUs that can be executing simultaneously in golang runtime")
        return fs</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "fmt"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/container-storage-interface/spec/lib/go/csi"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        cloudprovider "k8s.io/cloud-provider"
        volerr "k8s.io/cloud-provider/volume/errors"
        "k8s.io/klog/v2"
        "k8s.io/utils/ptr"

        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
        volumehelper "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        azureconsts "sigs.k8s.io/cloud-provider-azure/pkg/consts"
        "sigs.k8s.io/cloud-provider-azure/pkg/metrics"
        azure "sigs.k8s.io/cloud-provider-azure/pkg/provider"
)

const (
        waitForSnapshotReadyInterval = 5 * time.Second
        waitForSnapshotReadyTimeout  = 10 * time.Minute
        maxErrMsgLength              = 990
        checkDiskLunThrottleLatency  = 1 * time.Second
)

// listVolumeStatus explains the return status of `listVolumesByResourceGroup`
type listVolumeStatus struct {
        numVisited    int  // the number of iterated azure disks
        isCompleteRun bool // isCompleteRun is flagged true if the function iterated through all azure disks
        entries       []*csi.ListVolumesResponse_Entry
        err           error
}

// CreateVolume provisions an azure disk
func (d *Driver) CreateVolume(ctx context.Context, req *csi.CreateVolumeRequest) (*csi.CreateVolumeResponse, error) <span class="cov8" title="1">{
        if err := d.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME); err != nil </span><span class="cov8" title="1">{
                klog.Errorf("invalid create volume req: %v", req)
                return nil, err
        }</span>
        <span class="cov8" title="1">params := make(map[string]string, len(req.GetParameters())+len(req.GetMutableParameters()))
        for k, v := range req.GetParameters() </span><span class="cov8" title="1">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range req.GetMutableParameters() </span><span class="cov8" title="1">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">diskParams, err := azureutils.ParseDiskParameters(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Failed parsing disk parameters: %v", err)
        }</span>
        <span class="cov8" title="1">name := req.GetName()
        if len(name) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "CreateVolume Name must be provided")
        }</span>
        <span class="cov8" title="1">volCaps := req.GetVolumeCapabilities()
        if len(volCaps) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "CreateVolume Volume capabilities must be provided")
        }</span>

        <span class="cov8" title="1">if err := azureutils.IsValidVolumeCapabilities(volCaps, diskParams.MaxShares); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">isAdvancedPerfProfile := strings.EqualFold(diskParams.PerfProfile, consts.PerfProfileAdvanced)
        // If perfProfile is set to advanced and no/invalid device settings are provided, fail the request
        if d.getPerfOptimizationEnabled() &amp;&amp; isAdvancedPerfProfile </span><span class="cov8" title="1">{
                if err := optimization.AreDeviceSettingsValid(consts.DummyBlockDevicePathLinux, diskParams.DeviceSettings); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>
        }

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(name); !acquired </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, name)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(name)

        capacityBytes := req.GetCapacityRange().GetRequiredBytes()
        volSizeBytes := int64(capacityBytes)
        requestGiB := int(volumehelper.RoundUpGiB(volSizeBytes))

        if diskParams.PerformancePlus != nil &amp;&amp; *diskParams.PerformancePlus &amp;&amp; requestGiB &lt; consts.PerformancePlusMinimumDiskSizeGiB </span><span class="cov8" title="1">{
                klog.Warningf("using PerformancePlus, increasing requested disk size from %vGiB to %vGiB (minimal size for PerformancePlus feature)", requestGiB, consts.PerformancePlusMinimumDiskSizeGiB)
                requestGiB = consts.PerformancePlusMinimumDiskSizeGiB
        }</span>
        <span class="cov8" title="1">if requestGiB &lt; consts.MinimumDiskSizeGiB </span><span class="cov8" title="1">{
                klog.Infof("increasing requested disk size from %vGiB to %vGiB (minimal disk size)", requestGiB, consts.MinimumDiskSizeGiB)
                requestGiB = consts.MinimumDiskSizeGiB
        }</span>

        <span class="cov8" title="1">maxVolSize := int(volumehelper.RoundUpGiB(req.GetCapacityRange().GetLimitBytes()))
        if (maxVolSize &gt; 0) &amp;&amp; (maxVolSize &lt; requestGiB) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "After round-up, volume size exceeds the limit specified")
        }</span>

        <span class="cov8" title="1">localCloud := d.cloud
        localDiskController := d.diskController

        if diskParams.UserAgent != "" </span><span class="cov0" title="0">{
                localCloud, err = azureutils.GetCloudProviderFromClient(ctx, d.kubeClient, d.cloudConfigSecretName, d.cloudConfigSecretNamespace, diskParams.UserAgent,
                        d.allowEmptyCloudConfig, d.enableTrafficManager, d.enableMinimumRetryAfter, d.trafficManagerPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "create cloud with UserAgent(%s) failed with: (%s)", diskParams.UserAgent, err)
                }</span>
                <span class="cov0" title="0">localDiskController = &amp;ManagedDiskController{
                        controllerCommon: &amp;controllerCommon{
                                cloud:                     localCloud,
                                lockMap:                   newLockMap(),
                                DisableDiskLunCheck:       true,
                                clientFactory:             localCloud.ComputeClientFactory,
                                ForceDetachBackoff:        d.forceDetachBackoff,
                                WaitForDetach:             d.waitForDetach,
                                CheckDiskCountForBatching: d.checkDiskCountForBatching,
                        },
                }
                localDiskController.AttachDetachInitialDelayInMs = int(d.attachDetachInitialDelayInMs)</span>

        }
        <span class="cov8" title="1">if azureutils.IsAzureStackCloud(localCloud.Config.Cloud, localCloud.Config.DisableAzureStackCloud) </span><span class="cov0" title="0">{
                if diskParams.MaxShares &gt; 1 </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("Invalid maxShares value: %d as Azure Stack does not support shared disk.", diskParams.MaxShares))
                }</span>
        }

        <span class="cov8" title="1">if diskParams.DiskName == "" </span><span class="cov8" title="1">{
                diskParams.DiskName = name
        }</span>
        <span class="cov8" title="1">diskParams.DiskName = azureutils.CreateValidDiskName(diskParams.DiskName)

        if diskParams.ResourceGroup == "" </span><span class="cov8" title="1">{
                diskParams.ResourceGroup = d.cloud.ResourceGroup
        }</span>

        // normalize values
        <span class="cov8" title="1">skuName, err := azureutils.NormalizeStorageAccountType(diskParams.AccountType, localCloud.Config.Cloud, localCloud.Config.DisableAzureStackCloud)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">if _, err := azureutils.NormalizeCachingMode(diskParams.CachingMode); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">if skuName == armcompute.DiskStorageAccountTypesPremiumV2LRS </span><span class="cov8" title="1">{
                // PremiumV2LRS only supports None caching mode
                azureutils.SetKeyValueInMap(diskParams.VolumeContext, consts.CachingModeField, string(v1.AzureDataDiskCachingNone))
        }</span>

        <span class="cov8" title="1">if err := azureutils.ValidateDiskEncryptionType(diskParams.DiskEncryptionType); err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">networkAccessPolicy, err := azureutils.NormalizeNetworkAccessPolicy(diskParams.NetworkAccessPolicy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">publicNetworkAccess, err := azureutils.NormalizePublicNetworkAccess(diskParams.PublicNetworkAccess)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">diskZone := azureutils.PickAvailabilityZone(req.GetAccessibilityRequirements(), diskParams.Location, topologyKey)
        if diskParams.Location == "" </span><span class="cov8" title="1">{
                diskParams.Location = d.cloud.Location
                region := azureutils.GetRegionFromAvailabilityZone(diskZone)
                if region != "" &amp;&amp; region != d.cloud.Location </span><span class="cov0" title="0">{
                        klog.V(2).Infof("got a different region from zone %s for disk %s", diskZone, diskParams.DiskName)
                        diskParams.Location = region
                }</span>
        }
        <span class="cov8" title="1">accessibleTopology := []*csi.Topology{}

        if d.enableDiskCapacityCheck </span><span class="cov0" title="0">{
                if ok, err := d.checkDiskCapacity(ctx, diskParams.SubscriptionID, diskParams.ResourceGroup, diskParams.DiskName, requestGiB); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">contentSource := &amp;csi.VolumeContentSource{}

        if strings.EqualFold(diskParams.WriteAcceleratorEnabled, consts.TrueValue) </span><span class="cov0" title="0">{
                diskParams.Tags[azure.WriteAcceleratorEnabled] = consts.TrueValue
        }</span>
        <span class="cov8" title="1">var sourceID, sourceType string
        metricsRequest := "controller_create_volume"
        content := req.GetVolumeContentSource()
        if content != nil </span><span class="cov8" title="1">{
                if content.GetSnapshot() != nil </span><span class="cov8" title="1">{
                        sourceID = content.GetSnapshot().GetSnapshotId()
                        sourceType = consts.SourceSnapshot
                        contentSource = &amp;csi.VolumeContentSource{
                                Type: &amp;csi.VolumeContentSource_Snapshot{
                                        Snapshot: &amp;csi.VolumeContentSource_SnapshotSource{
                                                SnapshotId: sourceID,
                                        },
                                },
                        }
                        metricsRequest = "controller_create_volume_from_snapshot"
                }</span> else<span class="cov8" title="1"> {
                        sourceID = content.GetVolume().GetVolumeId()
                        sourceType = consts.SourceVolume
                        contentSource = &amp;csi.VolumeContentSource{
                                Type: &amp;csi.VolumeContentSource_Volume{
                                        Volume: &amp;csi.VolumeContentSource_VolumeSource{
                                                VolumeId: sourceID,
                                        },
                                },
                        }
                        subsID, resourceGroup, diskName, err := azureutils.GetInfoFromURI(sourceID)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.NotFound, "%v", err)
                        }</span>
                        <span class="cov0" title="0">sourceGiB, disk, err := d.GetSourceDiskSize(ctx, subsID, resourceGroup, diskName, 0, consts.SourceDiskSearchMaxDepth)
                        if err == nil </span><span class="cov0" title="0">{
                                if sourceGiB != nil &amp;&amp; *sourceGiB &lt; int32(requestGiB) </span><span class="cov0" title="0">{
                                        diskParams.VolumeContext[consts.ResizeRequired] = strconv.FormatBool(true)
                                        klog.V(2).Infof("source disk(%s) size(%d) is less than requested size(%d), set resizeRequired as true", sourceID, *sourceGiB, requestGiB)
                                }</span>
                                <span class="cov0" title="0">if disk != nil &amp;&amp; len(disk.Zones) == 1 </span><span class="cov0" title="0">{
                                        if disk.Zones[0] != nil </span><span class="cov0" title="0">{
                                                diskZone = fmt.Sprintf("%s-%s", diskParams.Location, *disk.Zones[0])
                                                klog.V(2).Infof("source disk(%s) is in zone(%s), set diskZone as %s", sourceID, *disk.Zones[0], diskZone)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                klog.Warningf("failed to get source disk(%s) size, err: %v", sourceID, err)
                        }</span>
                        <span class="cov0" title="0">metricsRequest = "controller_create_volume_from_volume"</span>
                }
        }

        <span class="cov8" title="1">if strings.HasSuffix(strings.ToLower(string(skuName)), "zrs") </span><span class="cov8" title="1">{
                klog.V(2).Infof("diskZone(%s) is reset as empty since disk(%s) is ZRS(%s)", diskZone, diskParams.DiskName, skuName)
                diskZone = ""
                // make volume scheduled on all 3 availability zones
                for i := 1; i &lt;= 3; i++ </span><span class="cov8" title="1">{
                        topology := &amp;csi.Topology{
                                Segments: map[string]string{topologyKey: fmt.Sprintf("%s-%d", diskParams.Location, i)},
                        }
                        accessibleTopology = append(accessibleTopology, topology)
                }</span>
                // make volume scheduled on all non-zone nodes
                <span class="cov8" title="1">topology := &amp;csi.Topology{
                        Segments: map[string]string{topologyKey: ""},
                }
                accessibleTopology = append(accessibleTopology, topology)</span>
        } else<span class="cov8" title="1"> {
                accessibleTopology = []*csi.Topology{
                        {
                                Segments: map[string]string{topologyKey: diskZone},
                        },
                }
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("begin to create azure disk(%s) account type(%s) rg(%s) location(%s) size(%d) diskZone(%v) maxShares(%d)",
                diskParams.DiskName, skuName, diskParams.ResourceGroup, diskParams.Location, requestGiB, diskZone, diskParams.MaxShares)

        if skuName == armcompute.DiskStorageAccountTypesUltraSSDLRS </span><span class="cov0" title="0">{
                if diskParams.DiskIOPSReadWrite == "" &amp;&amp; diskParams.DiskMBPSReadWrite == "" </span><span class="cov0" title="0">{
                        // set default DiskIOPSReadWrite, DiskMBPSReadWrite per request size
                        diskParams.DiskIOPSReadWrite = strconv.Itoa(getDefaultDiskIOPSReadWrite(requestGiB))
                        diskParams.DiskMBPSReadWrite = strconv.Itoa(getDefaultDiskMBPSReadWrite(requestGiB))
                        klog.V(2).Infof("set default DiskIOPSReadWrite as %s, DiskMBPSReadWrite as %s on disk(%s)", diskParams.DiskIOPSReadWrite, diskParams.DiskMBPSReadWrite, diskParams.DiskName)
                }</span>
        }

        <span class="cov8" title="1">diskParams.VolumeContext[consts.RequestedSizeGib] = strconv.Itoa(requestGiB)
        volumeOptions := &amp;ManagedDiskOptions{
                AvailabilityZone:    diskZone,
                BurstingEnabled:     diskParams.EnableBursting,
                DiskEncryptionSetID: diskParams.DiskEncryptionSetID,
                DiskEncryptionType:  diskParams.DiskEncryptionType,
                DiskIOPSReadWrite:   diskParams.DiskIOPSReadWrite,
                DiskMBpsReadWrite:   diskParams.DiskMBPSReadWrite,
                DiskName:            diskParams.DiskName,
                LogicalSectorSize:   int32(diskParams.LogicalSectorSize),
                MaxShares:           int32(diskParams.MaxShares),
                ResourceGroup:       diskParams.ResourceGroup,
                SubscriptionID:      diskParams.SubscriptionID,
                SizeGB:              requestGiB,
                StorageAccountType:  skuName,
                SourceResourceID:    sourceID,
                SourceType:          sourceType,
                Tags:                diskParams.Tags,
                Location:            diskParams.Location,
                PerformancePlus:     diskParams.PerformancePlus,
        }

        volumeOptions.SkipGetDiskOperation = d.isGetDiskThrottled(ctx)
        // Azure Stack Cloud does not support NetworkAccessPolicy, PublicNetworkAccess
        if !azureutils.IsAzureStackCloud(localCloud.Config.Cloud, localCloud.Config.DisableAzureStackCloud) </span><span class="cov8" title="1">{
                volumeOptions.NetworkAccessPolicy = networkAccessPolicy
                volumeOptions.PublicNetworkAccess = publicNetworkAccess
                if diskParams.DiskAccessID != "" </span><span class="cov0" title="0">{
                        volumeOptions.DiskAccessID = &amp;diskParams.DiskAccessID
                }</span>
        }

        <span class="cov8" title="1">var diskURI string
        mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, metricsRequest, d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI)
        }</span>()

        <span class="cov8" title="1">diskURI, err = localDiskController.CreateManagedDisk(ctx, volumeOptions)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), consts.NotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "%v", err)</span>
        }

        <span class="cov8" title="1">isOperationSucceeded = true
        klog.V(2).Infof("create azure disk(%s) account type(%s) rg(%s) location(%s) size(%d) tags(%s) successfully", diskParams.DiskName, skuName, diskParams.ResourceGroup, diskParams.Location, requestGiB, diskParams.Tags)

        return &amp;csi.CreateVolumeResponse{
                Volume: &amp;csi.Volume{
                        VolumeId:           diskURI,
                        CapacityBytes:      volumehelper.GiBToBytes(int64(requestGiB)),
                        VolumeContext:      diskParams.VolumeContext,
                        ContentSource:      contentSource,
                        AccessibleTopology: accessibleTopology,
                },
        }, nil</span>
}

// DeleteVolume delete an azure disk
func (d *Driver) DeleteVolume(ctx context.Context, req *csi.DeleteVolumeRequest) (*csi.DeleteVolumeResponse, error) <span class="cov8" title="1">{
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>

        <span class="cov8" title="1">if err := d.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "invalid delete volume req: %v", req)
        }</span>
        <span class="cov8" title="1">diskURI := volumeID

        if !azureutils.IsARMResourceID(diskURI) </span><span class="cov8" title="1">{
                klog.Errorf("diskURI(%s) is not a valid ARM resource ID", diskURI)
                return &amp;csi.DeleteVolumeResponse{}, nil
        }</span>

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(volumeID); !acquired </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, volumeID)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(volumeID)

        mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_delete_volume", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI)
        }</span>()

        <span class="cov8" title="1">klog.V(2).Infof("deleting azure disk(%s)", diskURI)
        err := d.diskController.DeleteManagedDisk(ctx, diskURI)
        klog.V(2).Infof("delete azure disk(%s) returned with %v", diskURI, err)
        isOperationSucceeded = (err == nil)
        return &amp;csi.DeleteVolumeResponse{}, err</span>
}

// ControllerGetVolume get volume
func (d *Driver) ControllerGetVolume(context.Context, *csi.ControllerGetVolumeRequest) (*csi.ControllerGetVolumeResponse, error) <span class="cov8" title="1">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>

// ControllerModifyVolume modify volume
func (d *Driver) ControllerModifyVolume(ctx context.Context, req *csi.ControllerModifyVolumeRequest) (*csi.ControllerModifyVolumeResponse, error) <span class="cov8" title="1">{
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>

        <span class="cov8" title="1">if err := d.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_MODIFY_VOLUME); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "invalid modify volume req: %v", req)
        }</span>
        <span class="cov8" title="1">diskURI := volumeID
        if _, err := d.checkDiskExists(ctx, diskURI); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.NotFound, fmt.Sprintf("Volume not found, failed with error: %v", err))
        }</span>

        <span class="cov8" title="1">diskParams, err := azureutils.ParseDiskParameters(req.GetMutableParameters())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Failed parsing disk parameters: %v", err)
        }</span>

        // normalize values
        <span class="cov8" title="1">skuName, err := azureutils.NormalizeStorageAccountType(diskParams.AccountType, d.cloud.Config.Cloud, d.cloud.Config.DisableAzureStackCloud)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">if diskParams.AccountType == "" </span><span class="cov8" title="1">{
                skuName = ""
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("begin to modify azure disk(%s) account type(%s) rg(%s) location(%s)",
                diskParams.DiskName, skuName, diskParams.ResourceGroup, diskParams.Location)

        volumeOptions := &amp;ManagedDiskOptions{
                DiskIOPSReadWrite:  diskParams.DiskIOPSReadWrite,
                DiskMBpsReadWrite:  diskParams.DiskMBPSReadWrite,
                ResourceGroup:      diskParams.ResourceGroup,
                SubscriptionID:     diskParams.SubscriptionID,
                StorageAccountType: skuName,
                SourceResourceID:   diskURI,
                SourceType:         consts.SourceVolume,
        }

        mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_modify_volume", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI)
        }</span>()

        <span class="cov8" title="1">if err = d.diskController.ModifyDisk(ctx, volumeOptions); err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), consts.NotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "%v", err)</span>
        }

        <span class="cov8" title="1">isOperationSucceeded = true
        klog.V(2).Infof("modify azure disk(%s) account type(%s) rg(%s) location(%s) successfully", diskParams.DiskName, skuName, diskParams.ResourceGroup, diskParams.Location)

        return &amp;csi.ControllerModifyVolumeResponse{}, err</span>
}

// ControllerPublishVolume attach an azure disk to a required node
func (d *Driver) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) <span class="cov8" title="1">{
        diskURI := req.GetVolumeId()
        if len(diskURI) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">volCap := req.GetVolumeCapability()
        if volCap == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not provided")
        }</span>

        <span class="cov8" title="1">caps := []*csi.VolumeCapability{volCap}
        maxShares, err := azureutils.GetMaxShares(req.GetVolumeContext())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "MaxShares value not supported")
        }</span>

        <span class="cov8" title="1">if err := azureutils.IsValidVolumeCapabilities(caps, maxShares); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">disk, err := d.checkDiskExists(ctx, diskURI)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "context deadline") </span><span class="cov0" title="0">{
                        disk = nil
                        klog.Warningf("checkDiskExists(%s) failed with %v, proceed to attach disk", diskURI, err)
                }</span> else<span class="cov8" title="1"> {
                        return nil, status.Error(codes.NotFound, fmt.Sprintf("Volume not found, failed with error: %v", err))
                }</span>
        }

        <span class="cov8" title="1">nodeID := req.GetNodeId()
        if len(nodeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Node ID not provided")
        }</span>

        <span class="cov8" title="1">nodeName := types.NodeName(nodeID)
        _, _, diskName, err := azureutils.GetInfoFromURI(diskURI)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "%v", err)
        }</span>

        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_publish_volume", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI, consts.Node, string(nodeName))
        }</span>()

        <span class="cov8" title="1">lun, vmState, err := d.diskController.GetDiskLun(ctx, diskName, diskURI, nodeName)
        if err == cloudprovider.InstanceNotFound </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, fmt.Sprintf("failed to get azure instance id for node %q (%v)", nodeName, err))
        }</span>

        <span class="cov8" title="1">vmStateStr := "&lt;nil&gt;"
        if vmState != nil </span><span class="cov8" title="1">{
                vmStateStr = *vmState
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("GetDiskLun returned: %v. Initiating attaching volume %s to node %s (vmState %s).", err, diskURI, nodeName, vmStateStr)

        volumeContext := req.GetVolumeContext()
        if volumeContext == nil </span><span class="cov8" title="1">{
                volumeContext = map[string]string{}
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if vmState != nil &amp;&amp; strings.ToLower(*vmState) == "failed" </span><span class="cov8" title="1">{
                        klog.Warningf("VM(%s) is in failed state, update VM first", nodeName)
                        if err := d.diskController.UpdateVM(ctx, nodeName); err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.Internal, "update instance %q failed with %v", nodeName, err)
                        }</span>
                }
                // Volume is already attached to node.
                <span class="cov8" title="1">klog.V(2).Infof("Attach operation is successful. volume %s is already attached to node %s at lun %d.", diskURI, nodeName, lun)</span>
        } else<span class="cov8" title="1"> {
                if !strings.Contains(err.Error(), azureconsts.CannotFindDiskLUN) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "could not get disk lun for volume %s: %v", diskURI, err)
                }</span>
                <span class="cov8" title="1">var cachingMode armcompute.CachingTypes
                if cachingMode, err = azureutils.GetCachingMode(volumeContext); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "%v", err)
                }</span>

                <span class="cov0" title="0">occupiedLuns := d.getOccupiedLunsFromNode(ctx, nodeName, diskURI)
                klog.V(2).Infof("Trying to attach volume %s to node %s", diskURI, nodeName)

                attachDiskInitialDelay := azureutils.GetAttachDiskInitialDelay(volumeContext)
                if attachDiskInitialDelay &gt; 0 </span><span class="cov0" title="0">{
                        klog.V(2).Infof("attachDiskInitialDelayInMs is set to %d", attachDiskInitialDelay)
                        d.diskController.AttachDetachInitialDelayInMs = attachDiskInitialDelay
                }</span>
                <span class="cov0" title="0">lun, err = d.diskController.AttachDisk(ctx, diskName, diskURI, nodeName, cachingMode, disk, occupiedLuns)
                if err == nil </span><span class="cov0" title="0">{
                        klog.V(2).Infof("Attach operation successful: volume %s attached to node %s.", diskURI, nodeName)
                }</span> else<span class="cov0" title="0"> {
                        if derr, ok := err.(*volerr.DanglingAttachError); ok </span><span class="cov0" title="0">{
                                if strings.EqualFold(string(nodeName), string(derr.CurrentNode)) </span><span class="cov0" title="0">{
                                        err := status.Errorf(codes.Internal, "volume %s is actually attached to current node %s, return error", diskURI, nodeName)
                                        klog.Warningf("%v", err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">klog.Warningf("volume %s is already attached to node %s, try detach first", diskURI, derr.CurrentNode)
                                if err = d.diskController.DetachDisk(ctx, diskName, diskURI, derr.CurrentNode); err != nil </span><span class="cov0" title="0">{
                                        return nil, status.Errorf(codes.Internal, "Could not detach volume %s from node %s: %v", diskURI, derr.CurrentNode, err)
                                }</span>
                                <span class="cov0" title="0">klog.V(2).Infof("Trying to attach volume %s to node %s again", diskURI, nodeName)
                                lun, err = d.diskController.AttachDisk(ctx, diskName, diskURI, nodeName, cachingMode, disk, occupiedLuns)</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                klog.Errorf("Attach volume %s to instance %s failed with %v", diskURI, nodeName, err)
                                errMsg := fmt.Sprintf("Attach volume %s to instance %s failed with %v", diskURI, nodeName, err)
                                if len(errMsg) &gt; maxErrMsgLength </span><span class="cov0" title="0">{
                                        errMsg = errMsg[:maxErrMsgLength]
                                }</span>
                                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "%v", errMsg)</span>
                        }
                }
                <span class="cov0" title="0">klog.V(2).Infof("attach volume %s to node %s successfully", diskURI, nodeName)</span>
        }

        <span class="cov8" title="1">publishContext := map[string]string{consts.LUN: strconv.Itoa(int(lun))}
        if disk != nil </span><span class="cov8" title="1">{
                if _, ok := volumeContext[consts.RequestedSizeGib]; !ok </span><span class="cov8" title="1">{
                        klog.V(6).Infof("found static PV(%s), insert disk properties to volumeattachments", diskURI)
                        azureutils.InsertDiskProperties(disk, publishContext)
                }</span>
        }
        <span class="cov8" title="1">isOperationSucceeded = true
        return &amp;csi.ControllerPublishVolumeResponse{PublishContext: publishContext}, nil</span>
}

// ControllerUnpublishVolume detach an azure disk from a required node
func (d *Driver) ControllerUnpublishVolume(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) (*csi.ControllerUnpublishVolumeResponse, error) <span class="cov8" title="1">{
        diskURI := req.GetVolumeId()
        if len(diskURI) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">nodeID := req.GetNodeId()
        if len(nodeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Node ID not provided")
        }</span>
        <span class="cov8" title="1">nodeName := types.NodeName(nodeID)

        _, _, diskName, err := azureutils.GetInfoFromURI(diskURI)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "%v", err)
        }</span>

        <span class="cov0" title="0">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_unpublish_volume", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov0" title="0">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI, consts.Node, string(nodeName))
        }</span>()

        <span class="cov0" title="0">klog.V(2).Infof("Trying to detach volume %s from node %s", diskURI, nodeID)

        if err := d.diskController.DetachDisk(ctx, diskName, diskURI, nodeName); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), consts.ErrDiskNotFound) </span><span class="cov0" title="0">{
                        klog.Warningf("volume %s already detached from node %s", diskURI, nodeID)
                }</span> else<span class="cov0" title="0"> {
                        klog.Errorf("Could not detach volume %s from node %s: %v", diskURI, nodeID, err)
                        errMsg := fmt.Sprintf("Could not detach volume %s from node %s: %v", diskURI, nodeID, err)
                        if len(errMsg) &gt; maxErrMsgLength </span><span class="cov0" title="0">{
                                errMsg = errMsg[:maxErrMsgLength]
                        }</span>
                        <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "%v", errMsg)</span>
                }
        }
        <span class="cov0" title="0">klog.V(2).Infof("detach volume %s from node %s successfully", diskURI, nodeID)
        isOperationSucceeded = true

        return &amp;csi.ControllerUnpublishVolumeResponse{}, nil</span>
}

// ValidateVolumeCapabilities return the capabilities of the volume
func (d *Driver) ValidateVolumeCapabilities(ctx context.Context, req *csi.ValidateVolumeCapabilitiesRequest) (*csi.ValidateVolumeCapabilitiesResponse, error) <span class="cov8" title="1">{
        diskURI := req.GetVolumeId()
        if len(diskURI) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>

        <span class="cov8" title="1">volumeCapabilities := req.GetVolumeCapabilities()
        if volumeCapabilities == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "VolumeCapabilities missing in the request")
        }</span>

        <span class="cov8" title="1">params := req.GetParameters()
        maxShares, err := azureutils.GetMaxShares(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "MaxShares value not supported")
        }</span>

        <span class="cov8" title="1">if err := azureutils.IsValidVolumeCapabilities(volumeCapabilities, maxShares); err != nil </span><span class="cov8" title="1">{
                return &amp;csi.ValidateVolumeCapabilitiesResponse{Message: err.Error()}, nil
        }</span>

        <span class="cov8" title="1">if _, err := d.checkDiskExists(ctx, diskURI); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.NotFound, fmt.Sprintf("Volume not found, failed with error: %v", err))
        }</span>

        <span class="cov8" title="1">return &amp;csi.ValidateVolumeCapabilitiesResponse{
                Confirmed: &amp;csi.ValidateVolumeCapabilitiesResponse_Confirmed{
                        VolumeCapabilities: volumeCapabilities,
                }}, nil</span>
}

// getOccupiedLunsFromNode returns the occupied luns from node
func (d *Driver) getOccupiedLunsFromNode(ctx context.Context, nodeName types.NodeName, diskURI string) []int <span class="cov0" title="0">{
        var occupiedLuns []int
        if d.checkDiskLUNCollision &amp;&amp; !d.isCheckDiskLunThrottled(ctx) </span><span class="cov0" title="0">{
                timer := time.AfterFunc(checkDiskLunThrottleLatency, func() </span><span class="cov0" title="0">{
                        klog.Warningf("checkDiskLun(%s) on node %s took longer than %v, disable disk lun check temporarily", diskURI, nodeName, checkDiskLunThrottleLatency)
                        d.checkDiskLunThrottlingCache.Set(consts.CheckDiskLunThrottlingKey, "")
                }</span>)
                <span class="cov0" title="0">now := time.Now()
                if usedLunsFromVA, err := d.getUsedLunsFromVolumeAttachments(ctx, string(nodeName)); err == nil </span><span class="cov0" title="0">{
                        if len(usedLunsFromVA) &gt; 0 </span><span class="cov0" title="0">{
                                if usedLunsFromNode, err := d.getUsedLunsFromNode(ctx, nodeName); err == nil </span><span class="cov0" title="0">{
                                        occupiedLuns = volumehelper.GetElementsInArray1NotInArray2(usedLunsFromVA, usedLunsFromNode)
                                        if len(occupiedLuns) &gt; 0 </span><span class="cov0" title="0">{
                                                klog.Warningf("node: %s, usedLuns from VolumeAttachments: %v, usedLuns from Node: %v, occupiedLuns: %v, disk: %s", nodeName, usedLunsFromVA, usedLunsFromNode, occupiedLuns, diskURI)
                                        }</span> else<span class="cov0" title="0"> {
                                                klog.V(6).Infof("node: %s, usedLuns from VolumeAttachments: %v, usedLuns from Node: %v, occupiedLuns: %v, disk: %s", nodeName, usedLunsFromVA, usedLunsFromNode, occupiedLuns, diskURI)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        klog.Warningf("getUsedLunsFromNode(%s, %s) failed with %v", nodeName, diskURI, err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        klog.Warningf("getUsedLunsFromVolumeAttachments(%s, %s) failed with %v", nodeName, diskURI, err)
                }</span>
                <span class="cov0" title="0">latency := time.Since(now)
                if latency &gt; checkDiskLunThrottleLatency </span><span class="cov0" title="0">{
                        klog.Warningf("checkDiskLun(%s) on node %s took %v (limit: %v)", diskURI, nodeName, latency, checkDiskLunThrottleLatency)
                }</span> else<span class="cov0" title="0"> {
                        timer.Stop() // cancel the timer
                        klog.V(6).Infof("checkDiskLun(%s) on node %s took %v", diskURI, nodeName, latency)
                }</span>
        }
        <span class="cov0" title="0">return occupiedLuns</span>
}

// ControllerGetCapabilities returns the capabilities of the Controller plugin
func (d *Driver) ControllerGetCapabilities(_ context.Context, _ *csi.ControllerGetCapabilitiesRequest) (*csi.ControllerGetCapabilitiesResponse, error) <span class="cov8" title="1">{
        return &amp;csi.ControllerGetCapabilitiesResponse{
                Capabilities: d.Cap,
        }, nil
}</span>

// GetCapacity returns the capacity of the total available storage pool
func (d *Driver) GetCapacity(_ context.Context, _ *csi.GetCapacityRequest) (*csi.GetCapacityResponse, error) <span class="cov8" title="1">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>

// ListVolumes return all available volumes
func (d *Driver) ListVolumes(ctx context.Context, req *csi.ListVolumesRequest) (*csi.ListVolumesResponse, error) <span class="cov8" title="1">{
        start := 0
        if req.StartingToken != "" </span><span class="cov8" title="1">{
                var err error
                start, err = strconv.Atoi(req.StartingToken)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Aborted, "ListVolumes starting token(%s) parsing with error: %v", req.StartingToken, err)
                }</span>
                <span class="cov8" title="1">if start &lt; 0 </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Aborted, "ListVolumes starting token(%d) can not be negative", start)
                }</span>
        }
        <span class="cov8" title="1">if d.cloud.KubeClient != nil &amp;&amp; d.cloud.KubeClient.CoreV1() != nil &amp;&amp; d.cloud.KubeClient.CoreV1().PersistentVolumes() != nil </span><span class="cov8" title="1">{
                klog.V(6).Infof("List Volumes in Cluster:")
                return d.listVolumesInCluster(ctx, start, int(req.MaxEntries))
        }</span>
        <span class="cov0" title="0">klog.V(6).Infof("List Volumes in Node Resource Group: %s", d.cloud.ResourceGroup)
        return d.listVolumesInNodeResourceGroup(ctx, start, int(req.MaxEntries))</span>
}

// listVolumesInCluster is a helper function for ListVolumes used for when there is an available kubeclient
func (d *Driver) listVolumesInCluster(ctx context.Context, start, maxEntries int) (*csi.ListVolumesResponse, error) <span class="cov8" title="1">{
        pvList, err := d.cloud.KubeClient.CoreV1().PersistentVolumes().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "ListVolumes failed while fetching PersistentVolumes List with error: %v", err)
        }</span>

        // get all resource groups and put them into a sorted slice
        <span class="cov8" title="1">rgMap := make(map[string]bool)
        volSet := make(map[string]bool)
        for _, pv := range pvList.Items </span><span class="cov0" title="0">{
                if pv.Spec.CSI != nil &amp;&amp; pv.Spec.CSI.Driver == d.Name </span><span class="cov0" title="0">{
                        diskURI := pv.Spec.CSI.VolumeHandle
                        _, rg, _, err := azureutils.GetInfoFromURI(diskURI)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.Warningf("failed to get subscription id, resource group from disk uri (%s) with error(%v)", diskURI, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">rg, diskURI = strings.ToLower(rg), strings.ToLower(diskURI)
                        volSet[diskURI] = true
                        if _, visited := rgMap[rg]; visited </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">rgMap[rg] = true</span>
                }
        }

        <span class="cov8" title="1">resourceGroups := make([]string, len(rgMap))
        i := 0
        for rg := range rgMap </span><span class="cov0" title="0">{
                resourceGroups[i] = rg
                i++
        }</span>
        <span class="cov8" title="1">sort.Strings(resourceGroups)

        // loop through each resourceGroup to get disk lists
        entries := []*csi.ListVolumesResponse_Entry{}
        numVisited := 0
        isCompleteRun, startFound := true, false
        for _, resourceGroup := range resourceGroups </span><span class="cov0" title="0">{
                if !isCompleteRun || (maxEntries &gt; 0 &amp;&amp; len(entries) &gt;= maxEntries) </span><span class="cov0" title="0">{
                        isCompleteRun = false
                        break</span>
                }
                <span class="cov0" title="0">localStart := start - numVisited
                if startFound </span><span class="cov0" title="0">{
                        localStart = 0
                }</span>
                <span class="cov0" title="0">listStatus := d.listVolumesByResourceGroup(ctx, resourceGroup, entries, localStart, maxEntries-len(entries), volSet)
                numVisited += listStatus.numVisited
                if listStatus.err != nil </span><span class="cov0" title="0">{
                        if status.Code(listStatus.err) == codes.FailedPrecondition </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, listStatus.err</span>
                }
                <span class="cov0" title="0">startFound = true
                entries = listStatus.entries
                isCompleteRun = isCompleteRun &amp;&amp; listStatus.isCompleteRun</span>
        }
        // if start was not found, start token was greater than total number of disks
        <span class="cov8" title="1">if start &gt; 0 &amp;&amp; !startFound </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.FailedPrecondition, "ListVolumes starting token(%d) is greater than total number of disks", start)
        }</span>

        <span class="cov8" title="1">nextTokenString := ""
        if !isCompleteRun </span><span class="cov0" title="0">{
                nextTokenString = strconv.Itoa(start + numVisited)
        }</span>

        <span class="cov8" title="1">listVolumesResp := &amp;csi.ListVolumesResponse{
                Entries:   entries,
                NextToken: nextTokenString,
        }

        return listVolumesResp, nil</span>
}

// listVolumesInNodeResourceGroup is a helper function for ListVolumes used for when there is no available kubeclient
func (d *Driver) listVolumesInNodeResourceGroup(ctx context.Context, start, maxEntries int) (*csi.ListVolumesResponse, error) <span class="cov0" title="0">{
        entries := []*csi.ListVolumesResponse_Entry{}
        listStatus := d.listVolumesByResourceGroup(ctx, d.cloud.ResourceGroup, entries, start, maxEntries, nil)
        if listStatus.err != nil </span><span class="cov0" title="0">{
                return nil, listStatus.err
        }</span>

        <span class="cov0" title="0">nextTokenString := ""
        if !listStatus.isCompleteRun </span><span class="cov0" title="0">{
                nextTokenString = strconv.Itoa(listStatus.numVisited)
        }</span>

        <span class="cov0" title="0">listVolumesResp := &amp;csi.ListVolumesResponse{
                Entries:   listStatus.entries,
                NextToken: nextTokenString,
        }

        return listVolumesResp, nil</span>
}

// listVolumesByResourceGroup is a helper function that updates the ListVolumeResponse_Entry slice and returns number of total visited volumes, number of volumes that needs to be visited and an error if found
func (d *Driver) listVolumesByResourceGroup(ctx context.Context, resourceGroup string, entries []*csi.ListVolumesResponse_Entry, start, maxEntries int, volSet map[string]bool) listVolumeStatus <span class="cov0" title="0">{
        diskClient := d.clientFactory.GetDiskClient()
        disks, derr := diskClient.List(ctx, resourceGroup)
        if derr != nil </span><span class="cov0" title="0">{
                return listVolumeStatus{err: status.Errorf(codes.Internal, "ListVolumes on rg(%s) failed with error: %v", resourceGroup, derr)}
        }</span>
        // if volSet is initialized but is empty, return
        <span class="cov0" title="0">if volSet != nil &amp;&amp; len(volSet) == 0 </span><span class="cov0" title="0">{
                return listVolumeStatus{
                        numVisited:    len(disks),
                        isCompleteRun: true,
                        entries:       entries,
                }
        }</span>
        <span class="cov0" title="0">if start &gt; 0 &amp;&amp; start &gt;= len(disks) </span><span class="cov0" title="0">{
                return listVolumeStatus{
                        numVisited: len(disks),
                        err:        status.Errorf(codes.FailedPrecondition, "ListVolumes starting token(%d) on rg(%s) is greater than total number of volumes", start, d.cloud.ResourceGroup),
                }
        }</span>
        <span class="cov0" title="0">if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov0" title="0">i := start
        isCompleteRun := true
        // Loop until
        for ; i &lt; len(disks); i++ </span><span class="cov0" title="0">{
                if maxEntries &gt; 0 &amp;&amp; len(entries) &gt;= maxEntries </span><span class="cov0" title="0">{
                        isCompleteRun = false
                        break</span>
                }

                <span class="cov0" title="0">disk := disks[i]
                // if given a set of volumes from KubeClient, only continue if the disk can be found in the set
                if volSet != nil &amp;&amp; !volSet[strings.ToLower(*disk.ID)] </span><span class="cov0" title="0">{
                        continue</span>
                }
                // HyperVGeneration property is only setup for os disks. Only the non os disks should be included in the list
                <span class="cov0" title="0">if disk.Properties == nil || disk.Properties.HyperVGeneration == nil || *disk.Properties.HyperVGeneration == "" </span><span class="cov0" title="0">{
                        nodeList := []string{}

                        if disk.ManagedBy != nil </span><span class="cov0" title="0">{
                                attachedNode, err := d.cloud.VMSet.GetNodeNameByProviderID(ctx, *disk.ManagedBy)
                                if err != nil </span><span class="cov0" title="0">{
                                        return listVolumeStatus{err: err}
                                }</span>
                                <span class="cov0" title="0">nodeList = append(nodeList, string(attachedNode))</span>
                        }

                        <span class="cov0" title="0">entries = append(entries, &amp;csi.ListVolumesResponse_Entry{
                                Volume: &amp;csi.Volume{
                                        VolumeId: *disk.ID,
                                },
                                Status: &amp;csi.ListVolumesResponse_VolumeStatus{
                                        PublishedNodeIds: nodeList,
                                },
                        })</span>
                }
        }
        <span class="cov0" title="0">return listVolumeStatus{
                numVisited:    i - start,
                isCompleteRun: isCompleteRun,
                entries:       entries,
        }</span>
}

// ControllerExpandVolume controller expand volume
func (d *Driver) ControllerExpandVolume(ctx context.Context, req *csi.ControllerExpandVolumeRequest) (*csi.ControllerExpandVolumeResponse, error) <span class="cov8" title="1">{
        if len(req.GetVolumeId()) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>
        <span class="cov8" title="1">if err := d.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_EXPAND_VOLUME); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid expand volume request: %v", req)
        }</span>

        <span class="cov8" title="1">capacityBytes := req.GetCapacityRange().GetRequiredBytes()
        if capacityBytes == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "volume capacity range missing in request")
        }</span>
        <span class="cov8" title="1">requestSize := *resource.NewQuantity(capacityBytes, resource.BinarySI)

        diskURI := req.GetVolumeId()
        result, rerr := d.diskController.GetDiskByURI(ctx, diskURI)
        if rerr != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "GetDiskByURI(%s) failed with error(%v)", diskURI, rerr)
        }</span>
        <span class="cov8" title="1">if result == nil || result.Properties == nil || result.Properties.DiskSizeGB == nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "could not get size of the disk(%s)", diskURI)
        }</span>
        <span class="cov0" title="0">oldSize := *resource.NewQuantity(int64(*result.Properties.DiskSizeGB), resource.BinarySI)

        mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_expand_volume", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov0" title="0">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI)
        }</span>()

        <span class="cov0" title="0">klog.V(2).Infof("begin to expand azure disk(%s) with new size(%d)", diskURI, requestSize.Value())
        newSize, err := d.diskController.ResizeDisk(ctx, diskURI, oldSize, requestSize, d.enableDiskOnlineResize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to resize disk(%s) with error(%v)", diskURI, err)
        }</span>

        <span class="cov0" title="0">currentSize, ok := newSize.AsInt64()
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to transform disk size with error(%v)", err)
        }</span>

        <span class="cov0" title="0">isOperationSucceeded = true
        klog.V(2).Infof("expand azure disk(%s) successfully, currentSize(%d)", diskURI, currentSize)

        if result.ManagedBy != nil </span><span class="cov0" title="0">{
                attachedNode, err := d.cloud.VMSet.GetNodeNameByProviderID(ctx, *result.ManagedBy)
                if err == nil </span><span class="cov0" title="0">{
                        klog.V(2).Infof("delete cache for node (%s, %s) after disk(%s) expanded", attachedNode, *result.ManagedBy, diskURI)
                        if err = d.cloud.VMSet.DeleteCacheForNode(ctx, string(attachedNode)); err != nil </span><span class="cov0" title="0">{
                                klog.Warningf("failed to delete cache for node %s with error(%v)", attachedNode, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        klog.Warningf("failed to get attached node for disk(%s) with error(%v)", diskURI, err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;csi.ControllerExpandVolumeResponse{
                CapacityBytes:         currentSize,
                NodeExpansionRequired: true,
        }, nil</span>
}

// CreateSnapshot create a snapshot
func (d *Driver) CreateSnapshot(ctx context.Context, req *csi.CreateSnapshotRequest) (*csi.CreateSnapshotResponse, error) <span class="cov8" title="1">{
        sourceVolumeID := req.GetSourceVolumeId()
        if len(sourceVolumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "CreateSnapshot Source Volume ID must be provided")
        }</span>
        <span class="cov8" title="1">snapshotName := req.Name
        if len(snapshotName) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "snapshot name must be provided")
        }</span>

        <span class="cov8" title="1">snapshotName = azureutils.CreateValidDiskName(snapshotName)

        var customTags string
        // set incremental snapshot as true by default
        incremental := true
        var subsID, resourceGroup, dataAccessAuthMode, tagValueDelimiter string
        var err error
        localCloud := d.cloud
        location := d.cloud.Location

        tags := make(map[string]*string)

        parameters := req.GetParameters()
        for k, v := range parameters </span><span class="cov8" title="1">{
                switch strings.ToLower(k) </span>{
                case consts.TagsField:<span class="cov8" title="1">
                        customTags = v</span>
                case consts.IncrementalField:<span class="cov8" title="1">
                        if v == "false" </span><span class="cov8" title="1">{
                                incremental = false
                        }</span>
                case consts.ResourceGroupField:<span class="cov8" title="1">
                        resourceGroup = v</span>
                case consts.LocationField:<span class="cov8" title="1">
                        location = v</span>
                case consts.UserAgentField:<span class="cov8" title="1">
                        newUserAgent := v
                        localCloud, err = azureutils.GetCloudProviderFromClient(ctx, d.kubeClient, d.cloudConfigSecretName, d.cloudConfigSecretNamespace, newUserAgent,
                                d.allowEmptyCloudConfig, d.enableTrafficManager, d.enableMinimumRetryAfter, d.trafficManagerPort)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.Internal, "create cloud with UserAgent(%s) failed with: (%s)", newUserAgent, err)
                        }</span>
                case consts.SubscriptionIDField:<span class="cov8" title="1">
                        subsID = v</span>
                case consts.DataAccessAuthModeField:<span class="cov8" title="1">
                        dataAccessAuthMode = v</span>
                case consts.TagValueDelimiterField:<span class="cov8" title="1">
                        tagValueDelimiter = v</span>
                case consts.VolumeSnapshotNameKey:<span class="cov8" title="1">
                        tags[consts.SnapshotNameTag] = ptr.To(v)</span>
                case consts.VolumeSnapshotNamespaceKey:<span class="cov8" title="1">
                        tags[consts.SnapshotNamespaceTag] = ptr.To(v)</span>
                case consts.VolumeSnapshotContentNameKey:<span class="cov8" title="1"></span>
                        // ignore the key
                default:<span class="cov8" title="1">
                        return nil, status.Errorf(codes.Internal, "AzureDisk - invalid option %s in VolumeSnapshotClass", k)</span>
                }
        }

        <span class="cov8" title="1">if azureutils.IsAzureStackCloud(localCloud.Config.Cloud, localCloud.Config.DisableAzureStackCloud) </span><span class="cov8" title="1">{
                klog.V(2).Info("Use full snapshot instead as Azure Stack does not support incremental snapshot.")
                incremental = false
        }</span>

        <span class="cov8" title="1">if resourceGroup == "" </span><span class="cov8" title="1">{
                if _, resourceGroup, _, err = azureutils.GetInfoFromURI(sourceVolumeID); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "could not get resource group from diskURI(%s) with error(%v)", sourceVolumeID, err)
                }</span>
        }

        <span class="cov8" title="1">customTagsMap, err := volumehelper.ConvertTagsToMap(customTags, tagValueDelimiter)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov8" title="1">tags[azureconsts.CreatedByTag] = ptr.To(consts.AzureDiskDriverTag)
        tags["source_volume_id"] = ptr.To(sourceVolumeID)
        for k, v := range customTagsMap </span><span class="cov8" title="1">{
                value := v
                tags[k] = &amp;value
        }</span>

        <span class="cov8" title="1">snapshot := armcompute.Snapshot{
                Properties: &amp;armcompute.SnapshotProperties{
                        CreationData: &amp;armcompute.CreationData{
                                CreateOption:     to.Ptr(armcompute.DiskCreateOptionCopy),
                                SourceResourceID: &amp;sourceVolumeID,
                        },
                        Incremental: &amp;incremental,
                },
                Location: &amp;d.cloud.Location,
                Tags:     tags,
        }

        if d.cloud.HasExtendedLocation() </span><span class="cov8" title="1">{
                klog.V(2).Infof("extended location Name:%s Type:%s is set on snapshot %s, source volume %s", d.cloud.ExtendedLocationName, d.cloud.ExtendedLocationType, snapshotName, sourceVolumeID)
                snapshot.ExtendedLocation = &amp;armcompute.ExtendedLocation{
                        Name: to.Ptr(d.cloud.ExtendedLocationName),
                        Type: to.Ptr(armcompute.ExtendedLocationTypes(d.cloud.ExtendedLocationType)),
                }
        }</span>

        <span class="cov8" title="1">if dataAccessAuthMode != "" </span><span class="cov8" title="1">{
                if err := azureutils.ValidateDataAccessAuthMode(dataAccessAuthMode); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>
                <span class="cov8" title="1">snapshot.Properties.DataAccessAuthMode = to.Ptr(armcompute.DataAccessAuthMode(dataAccessAuthMode))</span>
        }

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(snapshotName); !acquired </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, snapshotName)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(snapshotName)

        var crossRegionSnapshotName string
        if location != "" &amp;&amp; location != d.cloud.Location </span><span class="cov8" title="1">{
                if incremental </span><span class="cov8" title="1">{
                        crossRegionSnapshotName = snapshotName
                        snapshotName = azureutils.CreateValidDiskName("local_" + snapshotName)
                }</span> else<span class="cov8" title="1"> {
                        return nil, status.Errorf(codes.InvalidArgument, "could not create snapshot cross region with incremental is false")
                }</span>
        }

        <span class="cov8" title="1">metricsRequest := "controller_create_snapshot"
        if crossRegionSnapshotName != "" </span><span class="cov8" title="1">{
                metricsRequest = "controller_create_snapshot_cross_region"
        }</span>
        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, metricsRequest, d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        isOperationInProgress := false
        defer func() </span><span class="cov8" title="1">{
                if !isOperationInProgress </span><span class="cov8" title="1">{
                        mc.ObserveOperationWithResult(isOperationSucceeded, consts.SourceResourceID, sourceVolumeID, consts.SnapshotName, snapshotName)
                }</span>
        }()

        <span class="cov8" title="1">klog.V(2).Infof("begin to create snapshot(%s, incremental: %v) under rg(%s) region(%s)", snapshotName, incremental, resourceGroup, d.cloud.Location)
        snapshotClient, err := d.clientFactory.GetSnapshotClientForSub(subsID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "could not get snapshot client for subscription(%s) with error(%v)", subsID, err)
        }</span>

        <span class="cov8" title="1">csiSnapshot, _ := d.getSnapshotByID(ctx, subsID, resourceGroup, snapshotName, "")
        if csiSnapshot == nil || sourceVolumeID != csiSnapshot.SourceVolumeId </span><span class="cov8" title="1">{
                if _, err := snapshotClient.CreateOrUpdate(ctx, resourceGroup, snapshotName, snapshot); err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), "existing disk") </span><span class="cov8" title="1">{
                                return nil, status.Error(codes.AlreadyExists, fmt.Sprintf("request snapshot(%s) under rg(%s) already exists, but the SourceVolumeId is different, error details: %v", snapshotName, resourceGroup, err))
                        }</span>

                        <span class="cov8" title="1">azureutils.SleepIfThrottled(err, consts.SnapshotOpThrottlingSleepSec)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("create snapshot error: %v", err.Error()))</span>
                }
        }

        <span class="cov8" title="1">if d.shouldWaitForSnapshotReady </span><span class="cov8" title="1">{
                if err := d.waitForSnapshotReady(ctx, subsID, resourceGroup, snapshotName, waitForSnapshotReadyInterval, waitForSnapshotReadyTimeout); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("waitForSnapshotReady(%s, %s, %s) failed with %v", subsID, resourceGroup, snapshotName, err))
                }</span>
        }
        <span class="cov8" title="1">klog.V(2).Infof("create snapshot(%s) under rg(%s) region(%s) successfully", snapshotName, resourceGroup, d.cloud.Location)

        csiSnapshot, err = d.getSnapshotByID(ctx, subsID, resourceGroup, snapshotName, sourceVolumeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if csiSnapshot == nil </span><span class="cov0" title="0">{
                klog.Errorf("getSnapshotByID(%s, %s, %s) did not return a valid snapshot", subsID, resourceGroup, snapshotName)
                return nil, status.Error(codes.Internal, fmt.Sprintf("getSnapshotByID(%s, %s, %s) did not return a valid snapshot", subsID, resourceGroup, snapshotName))
        }</span>

        <span class="cov8" title="1">if csiSnapshot.ReadyToUse &amp;&amp; crossRegionSnapshotName != "" </span><span class="cov8" title="1">{
                crossRegionSnapshot, _ := d.getSnapshotByID(ctx, subsID, resourceGroup, crossRegionSnapshotName, sourceVolumeID)
                if crossRegionSnapshot == nil </span><span class="cov8" title="1">{
                        copySnapshot := snapshot
                        if copySnapshot.Properties == nil </span><span class="cov0" title="0">{
                                copySnapshot.Properties = &amp;armcompute.SnapshotProperties{}
                        }</span>
                        <span class="cov8" title="1">if copySnapshot.Properties.CreationData == nil </span><span class="cov0" title="0">{
                                copySnapshot.Properties.CreationData = &amp;armcompute.CreationData{}
                        }</span>
                        <span class="cov8" title="1">copySnapshot.Properties.CreationData.SourceResourceID = &amp;csiSnapshot.SnapshotId
                        copySnapshot.Properties.CreationData.CreateOption = to.Ptr(armcompute.DiskCreateOptionCopyStart)
                        copySnapshot.Location = &amp;location

                        klog.V(2).Infof("begin to create snapshot(%s, incremental: %v) under rg(%s) region(%s)", crossRegionSnapshotName, incremental, resourceGroup, location)
                        if _, err := snapshotClient.CreateOrUpdate(ctx, resourceGroup, crossRegionSnapshotName, copySnapshot); err != nil </span><span class="cov8" title="1">{
                                if strings.Contains(err.Error(), "existing disk") </span><span class="cov8" title="1">{
                                        return nil, status.Error(codes.AlreadyExists, fmt.Sprintf("request snapshot(%s) under rg(%s) already exists, but the SourceVolumeId is different, error details: %v", crossRegionSnapshotName, resourceGroup, err))
                                }</span>

                                <span class="cov8" title="1">azureutils.SleepIfThrottled(err, consts.SnapshotOpThrottlingSleepSec)
                                return nil, status.Error(codes.Internal, fmt.Sprintf("create snapshot error: %v", err))</span>
                        }
                        <span class="cov8" title="1">klog.V(2).Infof("create snapshot(%s) under rg(%s) region(%s) successfully", crossRegionSnapshotName, resourceGroup, location)</span>
                }

                <span class="cov8" title="1">if d.shouldWaitForSnapshotReady </span><span class="cov8" title="1">{
                        if err := d.waitForSnapshotReady(ctx, subsID, resourceGroup, crossRegionSnapshotName, waitForSnapshotReadyInterval, waitForSnapshotReadyTimeout); err != nil </span><span class="cov8" title="1">{
                                return nil, status.Error(codes.Internal, fmt.Sprintf("waitForSnapshotReady(%s, %s, %s) failed with %v", subsID, resourceGroup, crossRegionSnapshotName, err))
                        }</span>
                }

                <span class="cov8" title="1">csiSnapshot, err = d.getSnapshotByID(ctx, subsID, resourceGroup, crossRegionSnapshotName, sourceVolumeID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.Internal, err.Error())
                }</span>

                <span class="cov8" title="1">if csiSnapshot.ReadyToUse </span><span class="cov8" title="1">{
                        klog.V(2).Infof("begin to delete snapshot(%s) under rg(%s) region(%s)", snapshotName, resourceGroup, d.cloud.Location)
                        if err = snapshotClient.Delete(ctx, resourceGroup, snapshotName); err != nil </span><span class="cov8" title="1">{
                                klog.Errorf("delete snapshot error: %v", err)
                                azureutils.SleepIfThrottled(err, consts.SnapshotOpThrottlingSleepSec)
                        }</span> else<span class="cov8" title="1"> {
                                klog.V(2).Infof("delete snapshot(%s) under rg(%s) region(%s) successfully", snapshotName, resourceGroup, d.cloud.Location)
                        }</span>
                }

        } else<span class="cov8" title="1"> if crossRegionSnapshotName != "" </span><span class="cov8" title="1">{
                // replace the last token of csiSnapshot.SnapshotId with crossRegionSnapshotName
                csiSnapshot.SnapshotId = strings.TrimSuffix(csiSnapshot.SnapshotId, snapshotName) + crossRegionSnapshotName
        }</span>

        <span class="cov8" title="1">isOperationInProgress = !csiSnapshot.ReadyToUse

        createResp := &amp;csi.CreateSnapshotResponse{
                Snapshot: csiSnapshot,
        }
        isOperationSucceeded = true
        return createResp, nil</span>
}

// DeleteSnapshot delete a snapshot
func (d *Driver) DeleteSnapshot(ctx context.Context, req *csi.DeleteSnapshotRequest) (*csi.DeleteSnapshotResponse, error) <span class="cov8" title="1">{
        snapshotID := req.SnapshotId
        if len(snapshotID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Snapshot ID must be provided")
        }</span>

        <span class="cov8" title="1">var err error
        var subsID string
        snapshotName := snapshotID
        resourceGroup := d.cloud.ResourceGroup

        if azureutils.IsARMResourceID(snapshotID) </span><span class="cov8" title="1">{
                subsID, resourceGroup, snapshotName, err = azureutils.GetInfoFromURI(snapshotID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "%v", err)
                }</span>
        }

        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "controller_delete_snapshot", d.cloud.ResourceGroup, d.cloud.SubscriptionID, d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.SnapshotID, snapshotID)
        }</span>()

        <span class="cov8" title="1">klog.V(2).Infof("begin to delete snapshot(%s) under rg(%s)", snapshotName, resourceGroup)
        snapshotClient, err := d.clientFactory.GetSnapshotClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "could not get snapshot client for subscription(%s) with error(%v)", subsID, err)
        }</span>
        <span class="cov8" title="1">if err := snapshotClient.Delete(ctx, resourceGroup, snapshotName); err != nil </span><span class="cov8" title="1">{
                azureutils.SleepIfThrottled(err, consts.SnapshotOpThrottlingSleepSec)
                return nil, status.Error(codes.Internal, fmt.Sprintf("delete snapshot error: %v", err))
        }</span>
        <span class="cov8" title="1">klog.V(2).Infof("delete snapshot(%s) under rg(%s) successfully", snapshotName, resourceGroup)
        isOperationSucceeded = true
        return &amp;csi.DeleteSnapshotResponse{}, nil</span>
}

// ListSnapshots list all snapshots
func (d *Driver) ListSnapshots(ctx context.Context, req *csi.ListSnapshotsRequest) (*csi.ListSnapshotsResponse, error) <span class="cov8" title="1">{
        // SnapshotId is not empty, return snapshot that match the snapshot id.
        if len(req.GetSnapshotId()) != 0 </span><span class="cov8" title="1">{
                snapshot, err := d.getSnapshotByID(ctx, "", d.cloud.ResourceGroup, req.GetSnapshotId(), req.SourceVolumeId)
                if err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), consts.ResourceNotFound) </span><span class="cov0" title="0">{
                                return &amp;csi.ListSnapshotsResponse{}, nil
                        }</span>
                        <span class="cov8" title="1">return nil, err</span>
                }
                <span class="cov8" title="1">entries := []*csi.ListSnapshotsResponse_Entry{
                        {
                                Snapshot: snapshot,
                        },
                }
                listSnapshotResp := &amp;csi.ListSnapshotsResponse{
                        Entries: entries,
                }
                return listSnapshotResp, nil</span>
        }
        <span class="cov8" title="1">snapshotClient := d.clientFactory.GetSnapshotClient()
        // no SnapshotId is set, return all snapshots that satisfy the request.
        snapshots, err := snapshotClient.List(ctx, d.cloud.ResourceGroup)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("Unknown list snapshot error: %v", err.Error()))
        }</span>

        <span class="cov8" title="1">return azureutils.GetEntriesAndNextToken(req, snapshots)</span>
}

func (d *Driver) getSnapshotByID(ctx context.Context, subsID, resourceGroup, snapshotID, sourceVolumeID string) (*csi.Snapshot, error) <span class="cov8" title="1">{
        var err error
        snapshotName := snapshotID
        if azureutils.IsARMResourceID(snapshotID) </span><span class="cov8" title="1">{
                subsID, resourceGroup, snapshotName, err = azureutils.GetInfoFromURI(snapshotID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "%v", err)
                }</span>
        }
        <span class="cov8" title="1">snapshotClient, err := d.clientFactory.GetSnapshotClientForSub(subsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "could not get snapshot client for subscription(%s) with error(%v)", subsID, err)
        }</span>
        <span class="cov8" title="1">snapshot, err := snapshotClient.Get(ctx, resourceGroup, snapshotName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("get snapshot %s from rg(%s) error: %v", snapshotName, resourceGroup, err))
        }</span>

        <span class="cov8" title="1">return azureutils.GenerateCSISnapshot(sourceVolumeID, snapshot)</span>
}

// GetSourceDiskSize recursively searches for the sourceDisk and returns: sourceDisk disk size, error
func (d *Driver) GetSourceDiskSize(ctx context.Context, subsID, resourceGroup, diskName string, curDepth, maxDepth int) (*int32, *armcompute.Disk, error) <span class="cov8" title="1">{
        if curDepth &gt; maxDepth </span><span class="cov8" title="1">{
                return nil, nil, status.Error(codes.Internal, fmt.Sprintf("current depth (%d) surpassed the max depth (%d) while searching for the source disk size", curDepth, maxDepth))
        }</span>
        <span class="cov8" title="1">result, err := d.diskController.GetDisk(ctx, subsID, resourceGroup, diskName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, result, err
        }</span>
        <span class="cov8" title="1">if result == nil || result.Properties == nil </span><span class="cov8" title="1">{
                return nil, result, status.Error(codes.Internal, fmt.Sprintf("DiskProperty not found for disk (%s) in resource group (%s)", diskName, resourceGroup))
        }</span>

        <span class="cov8" title="1">if result.Properties.CreationData != nil &amp;&amp; result.Properties.CreationData.CreateOption != nil &amp;&amp; *result.Properties.CreationData.CreateOption == armcompute.DiskCreateOptionCopy </span><span class="cov0" title="0">{
                klog.V(2).Infof("Clone source disk has a parent source")
                sourceResourceID := *result.Properties.CreationData.SourceResourceID
                subsID, parentResourceGroup, parentDiskName, err := azureutils.GetInfoFromURI(sourceResourceID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, result, status.Error(codes.Internal, fmt.Sprintf("failed to get subscription id, resource group from disk uri (%s) with error(%v)", sourceResourceID, err))
                }</span>
                <span class="cov0" title="0">return d.GetSourceDiskSize(ctx, subsID, parentResourceGroup, parentDiskName, curDepth+1, maxDepth)</span>
        }

        <span class="cov8" title="1">if (*result.Properties).DiskSizeGB == nil </span><span class="cov8" title="1">{
                return nil, result, status.Error(codes.Internal, fmt.Sprintf("DiskSizeGB for disk (%s) in resourcegroup (%s) is nil", diskName, resourceGroup))
        }</span>
        <span class="cov8" title="1">return (*result.Properties).DiskSizeGB, result, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/container-storage-interface/spec/lib/go/csi"
        "go.uber.org/mock/gomock"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes/fake"
        "k8s.io/mount-utils"
        testingexec "k8s.io/utils/exec/testing"

        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
        csicommon "sigs.k8s.io/azuredisk-csi-driver/pkg/csi-common"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/mounter"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization/mockoptimization"
        volumehelper "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        "sigs.k8s.io/cloud-provider-azure/pkg/azclient"
        azcache "sigs.k8s.io/cloud-provider-azure/pkg/cache"
        azure "sigs.k8s.io/cloud-provider-azure/pkg/provider"
)

const (
        fakeDriverName    = "disk.csi.azure.com"
        fakeNodeID        = "fakeNodeID"
        fakeDriverVersion = "fakeDriverVersion"
)

var (
        stdVolumeCapability = &amp;csi.VolumeCapability{
                AccessType: &amp;csi.VolumeCapability_Mount{
                        Mount: &amp;csi.VolumeCapability_MountVolume{},
                },
                AccessMode: &amp;csi.VolumeCapability_AccessMode{
                        Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER,
                },
        }
        stdVolumeCapabilities = []*csi.VolumeCapability{
                stdVolumeCapability,
        }
        stdCapacityRange = &amp;csi.CapacityRange{
                RequiredBytes: volumehelper.GiBToBytes(10),
                LimitBytes:    volumehelper.GiBToBytes(15),
        }
)

// FakeDriver defines an interface unit tests use to test the implementation of the Azure Disk CSI Driver.
type FakeDriver interface {
        CSIDriver

        GetSourceDiskSize(ctx context.Context, subsID, resourceGroup, diskName string, curDepth, maxDepth int) (*int32, *armcompute.Disk, error)
        SetWaitForSnapshotReady(bool)
        GetWaitForSnapshotReady() bool

        setNextCommandOutputScripts(scripts ...testingexec.FakeAction)

        getVolumeLocks() *volumehelper.VolumeLocks
        setControllerCapabilities([]*csi.ControllerServiceCapability)
        setNodeCapabilities([]*csi.NodeServiceCapability)
        setName(string)
        setNodeID(string)
        setVersion(version string)
        getCloud() *azure.Cloud
        setCloud(*azure.Cloud)
        getClientFactory() azclient.ClientFactory
        getMounter() *mount.SafeFormatAndMount
        setMounter(*mount.SafeFormatAndMount)
        setPerfOptimizationEnabled(bool)
        getDeviceHelper() optimization.Interface
        getHostUtil() hostUtil

        checkDiskCapacity(context.Context, string, string, string, int) (bool, error)
        checkDiskExists(ctx context.Context, diskURI string) (*armcompute.Disk, error)
        waitForSnapshotReady(context.Context, string, string, string, time.Duration, time.Duration) error
        getSnapshotByID(context.Context, string, string, string, string) (*csi.Snapshot, error)
        ensureMountPoint(string) (bool, error)
        ensureBlockTargetFile(string) error
        getDevicePathWithLUN(lunStr string) (string, error)
        setThrottlingCache(key string, value string)
        getUsedLunsFromVolumeAttachments(context.Context, string) ([]int, error)
        getUsedLunsFromNode(context.Context, types.NodeName) ([]int, error)
}

type fakeDriver struct {
        Driver
}

// NewFakeDriver returns a driver implementation suitable for use in unit tests.
func NewFakeDriver(ctrl *gomock.Controller) (FakeDriver, error) <span class="cov8" title="1">{
        driver := fakeDriver{}
        driver.Name = fakeDriverName
        driver.Version = fakeDriverVersion
        driver.NodeID = fakeNodeID
        driver.CSIDriver = *csicommon.NewFakeCSIDriver()
        driver.volumeLocks = volumehelper.NewVolumeLocks()
        driver.VolumeAttachLimit = -1
        driver.supportZone = true
        driver.ioHandler = azureutils.NewFakeIOHandler()
        driver.hostUtil = azureutils.NewFakeHostUtil()
        driver.useCSIProxyGAInterface = true
        driver.allowEmptyCloudConfig = true
        driver.shouldWaitForSnapshotReady = true
        driver.endpoint = "tcp://127.0.0.1:0"
        driver.disableAVSetNodes = true
        driver.kubeClient = fake.NewSimpleClientset()

        driver.cloud = azure.GetTestCloud(ctrl)
        driver.diskController = NewManagedDiskController(driver.cloud)
        driver.clientFactory = driver.cloud.ComputeClientFactory

        mounter, err := mounter.NewSafeMounter(true, true, driver.useCSIProxyGAInterface, int(driver.maxConcurrentFormat), time.Duration(driver.concurrentFormatTimeout)*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">driver.mounter = mounter

        cache, err := azcache.NewTimedCache(time.Minute, func(_ context.Context, _ string) (interface{}, error) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>, false)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">driver.throttlingCache = cache
        driver.checkDiskLunThrottlingCache = cache
        driver.deviceHelper = mockoptimization.NewMockInterface(ctrl)

        driver.AddControllerServiceCapabilities(
                []csi.ControllerServiceCapability_RPC_Type{
                        csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME,
                        csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME,
                        csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT,
                        csi.ControllerServiceCapability_RPC_LIST_SNAPSHOTS,
                        csi.ControllerServiceCapability_RPC_CLONE_VOLUME,
                        csi.ControllerServiceCapability_RPC_EXPAND_VOLUME,
                        csi.ControllerServiceCapability_RPC_LIST_VOLUMES,
                        csi.ControllerServiceCapability_RPC_LIST_VOLUMES_PUBLISHED_NODES,
                        csi.ControllerServiceCapability_RPC_MODIFY_VOLUME,
                })
        driver.AddVolumeCapabilityAccessModes([]csi.VolumeCapability_AccessMode_Mode{csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER})
        driver.AddNodeServiceCapabilities([]csi.NodeServiceCapability_RPC_Type{
                csi.NodeServiceCapability_RPC_STAGE_UNSTAGE_VOLUME,
                csi.NodeServiceCapability_RPC_EXPAND_VOLUME,
        })

        return &amp;driver, nil</span>
}

func (d *fakeDriver) setNextCommandOutputScripts(scripts ...testingexec.FakeAction) <span class="cov8" title="1">{
        d.mounter.Exec.(*mounter.FakeSafeMounter).SetNextCommandOutputScripts(scripts...)
}</span>

func (d *fakeDriver) setThrottlingCache(key string, value string) <span class="cov8" title="1">{
        d.throttlingCache.Set(key, value)
}</span>
func (d *fakeDriver) getClientFactory() azclient.ClientFactory <span class="cov8" title="1">{
        return d.clientFactory
}</span>

func createVolumeCapabilities(accessMode csi.VolumeCapability_AccessMode_Mode) []*csi.VolumeCapability <span class="cov8" title="1">{
        return []*csi.VolumeCapability{
                createVolumeCapability(accessMode),
        }
}</span>

func createVolumeCapability(accessMode csi.VolumeCapability_AccessMode_Mode) *csi.VolumeCapability <span class="cov8" title="1">{
        return &amp;csi.VolumeCapability{
                AccessType: &amp;csi.VolumeCapability_Mount{
                        Mount: &amp;csi.VolumeCapability_MountVolume{},
                },
                AccessMode: &amp;csi.VolumeCapability_AccessMode{
                        Mode: accessMode,
                },
        }
}</span>

func (d *fakeDriver) SetWaitForSnapshotReady(shouldWait bool) <span class="cov8" title="1">{
        d.shouldWaitForSnapshotReady = shouldWait
}</span>

func (d *fakeDriver) GetWaitForSnapshotReady() bool <span class="cov8" title="1">{
        return d.shouldWaitForSnapshotReady
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/container-storage-interface/spec/lib/go/csi"

        wrappers "github.com/golang/protobuf/ptypes/wrappers"
)

// GetPluginInfo return the version and name of the plugin
func (f *Driver) GetPluginInfo(_ context.Context, _ *csi.GetPluginInfoRequest) (*csi.GetPluginInfoResponse, error) <span class="cov8" title="1">{
        if f.Name == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unavailable, "Driver name not configured")
        }</span>

        <span class="cov8" title="1">if f.Version == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Unavailable, "Driver is missing version")
        }</span>

        <span class="cov8" title="1">return &amp;csi.GetPluginInfoResponse{
                Name:          f.Name,
                VendorVersion: f.Version,
        }, nil</span>
}

// Probe check whether the plugin is running or not.
// This method does not need to return anything.
// Currently the spec does not dictate what you should return either.
// Hence, return an empty response
func (f *Driver) Probe(_ context.Context, _ *csi.ProbeRequest) (*csi.ProbeResponse, error) <span class="cov8" title="1">{
        return &amp;csi.ProbeResponse{Ready: &amp;wrappers.BoolValue{Value: true}}, nil
}</span>

// GetPluginCapabilities returns the capabilities of the plugin
func (f *Driver) GetPluginCapabilities(_ context.Context, _ *csi.GetPluginCapabilitiesRequest) (*csi.GetPluginCapabilitiesResponse, error) <span class="cov8" title="1">{
        capabilities := []*csi.PluginCapability{
                {
                        Type: &amp;csi.PluginCapability_Service_{
                                Service: &amp;csi.PluginCapability_Service{
                                        Type: csi.PluginCapability_Service_CONTROLLER_SERVICE,
                                },
                        },
                },
                {
                        Type: &amp;csi.PluginCapability_Service_{
                                Service: &amp;csi.PluginCapability_Service{
                                        Type: csi.PluginCapability_Service_VOLUME_ACCESSIBILITY_CONSTRAINTS,
                                },
                        },
                },
                {
                        Type: &amp;csi.PluginCapability_VolumeExpansion_{
                                VolumeExpansion: &amp;csi.PluginCapability_VolumeExpansion{
                                        Type: csi.PluginCapability_VolumeExpansion_OFFLINE,
                                },
                        },
                },
        }

        if f.enableDiskOnlineResize </span><span class="cov0" title="0">{
                pluginCapability := &amp;csi.PluginCapability{
                        Type: &amp;csi.PluginCapability_VolumeExpansion_{
                                VolumeExpansion: &amp;csi.PluginCapability_VolumeExpansion{
                                        Type: csi.PluginCapability_VolumeExpansion_ONLINE,
                                },
                        },
                }
                capabilities = append(capabilities, pluginCapability)
        }</span>

        <span class="cov8" title="1">return &amp;csi.GetPluginCapabilitiesResponse{
                Capabilities: capabilities,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mockcorev1

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        rest "k8s.io/client-go/rest"
)

// MockInterface is a mock of CoreV1Interface interface
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov0" title="0">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// RESTClient mocks base method
func (m *MockInterface) RESTClient() rest.Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RESTClient")
        ret0, _ := ret[0].(rest.Interface)
        return ret0
}</span>

// RESTClient indicates an expected call of RESTClient
func (mr *MockInterfaceMockRecorder) RESTClient() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RESTClient", reflect.TypeOf((*MockInterface)(nil).RESTClient))
}</span>

// ComponentStatuses mocks base method
func (m *MockInterface) ComponentStatuses() v1.ComponentStatusInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ComponentStatuses")
        ret0, _ := ret[0].(v1.ComponentStatusInterface)
        return ret0
}</span>

// ComponentStatuses indicates an expected call of ComponentStatuses
func (mr *MockInterfaceMockRecorder) ComponentStatuses() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ComponentStatuses", reflect.TypeOf((*MockInterface)(nil).ComponentStatuses))
}</span>

// ConfigMaps mocks base method
func (m *MockInterface) ConfigMaps(namespace string) v1.ConfigMapInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConfigMaps", namespace)
        ret0, _ := ret[0].(v1.ConfigMapInterface)
        return ret0
}</span>

// ConfigMaps indicates an expected call of ConfigMaps
func (mr *MockInterfaceMockRecorder) ConfigMaps(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigMaps", reflect.TypeOf((*MockInterface)(nil).ConfigMaps), namespace)
}</span>

// Endpoints mocks base method
func (m *MockInterface) Endpoints(namespace string) v1.EndpointsInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Endpoints", namespace)
        ret0, _ := ret[0].(v1.EndpointsInterface)
        return ret0
}</span>

// Endpoints indicates an expected call of Endpoints
func (mr *MockInterfaceMockRecorder) Endpoints(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockInterface)(nil).Endpoints), namespace)
}</span>

// Events mocks base method
func (m *MockInterface) Events(namespace string) v1.EventInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Events", namespace)
        ret0, _ := ret[0].(v1.EventInterface)
        return ret0
}</span>

// Events indicates an expected call of Events
func (mr *MockInterfaceMockRecorder) Events(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockInterface)(nil).Events), namespace)
}</span>

// LimitRanges mocks base method
func (m *MockInterface) LimitRanges(namespace string) v1.LimitRangeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LimitRanges", namespace)
        ret0, _ := ret[0].(v1.LimitRangeInterface)
        return ret0
}</span>

// LimitRanges indicates an expected call of LimitRanges
func (mr *MockInterfaceMockRecorder) LimitRanges(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LimitRanges", reflect.TypeOf((*MockInterface)(nil).LimitRanges), namespace)
}</span>

// Namespaces mocks base method
func (m *MockInterface) Namespaces() v1.NamespaceInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Namespaces")
        ret0, _ := ret[0].(v1.NamespaceInterface)
        return ret0
}</span>

// Namespaces indicates an expected call of Namespaces
func (mr *MockInterfaceMockRecorder) Namespaces() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Namespaces", reflect.TypeOf((*MockInterface)(nil).Namespaces))
}</span>

// Nodes mocks base method
func (m *MockInterface) Nodes() v1.NodeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Nodes")
        ret0, _ := ret[0].(v1.NodeInterface)
        return ret0
}</span>

// Nodes indicates an expected call of Nodes
func (mr *MockInterfaceMockRecorder) Nodes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nodes", reflect.TypeOf((*MockInterface)(nil).Nodes))
}</span>

// PersistentVolumes mocks base method
func (m *MockInterface) PersistentVolumes() v1.PersistentVolumeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PersistentVolumes")
        ret0, _ := ret[0].(v1.PersistentVolumeInterface)
        return ret0
}</span>

// PersistentVolumes indicates an expected call of PersistentVolumes
func (mr *MockInterfaceMockRecorder) PersistentVolumes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistentVolumes", reflect.TypeOf((*MockInterface)(nil).PersistentVolumes))
}</span>

// PersistentVolumeClaims mocks base method
func (m *MockInterface) PersistentVolumeClaims(namespace string) v1.PersistentVolumeClaimInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PersistentVolumeClaims", namespace)
        ret0, _ := ret[0].(v1.PersistentVolumeClaimInterface)
        return ret0
}</span>

// PersistentVolumeClaims indicates an expected call of PersistentVolumeClaims
func (mr *MockInterfaceMockRecorder) PersistentVolumeClaims(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistentVolumeClaims", reflect.TypeOf((*MockInterface)(nil).PersistentVolumeClaims), namespace)
}</span>

// Pods mocks base method
func (m *MockInterface) Pods(namespace string) v1.PodInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Pods", namespace)
        ret0, _ := ret[0].(v1.PodInterface)
        return ret0
}</span>

// Pods indicates an expected call of Pods
func (mr *MockInterfaceMockRecorder) Pods(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pods", reflect.TypeOf((*MockInterface)(nil).Pods), namespace)
}</span>

// PodTemplates mocks base method
func (m *MockInterface) PodTemplates(namespace string) v1.PodTemplateInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PodTemplates", namespace)
        ret0, _ := ret[0].(v1.PodTemplateInterface)
        return ret0
}</span>

// PodTemplates indicates an expected call of PodTemplates
func (mr *MockInterfaceMockRecorder) PodTemplates(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PodTemplates", reflect.TypeOf((*MockInterface)(nil).PodTemplates), namespace)
}</span>

// ReplicationControllers mocks base method
func (m *MockInterface) ReplicationControllers(namespace string) v1.ReplicationControllerInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReplicationControllers", namespace)
        ret0, _ := ret[0].(v1.ReplicationControllerInterface)
        return ret0
}</span>

// ReplicationControllers indicates an expected call of ReplicationControllers
func (mr *MockInterfaceMockRecorder) ReplicationControllers(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplicationControllers", reflect.TypeOf((*MockInterface)(nil).ReplicationControllers), namespace)
}</span>

// ResourceQuotas mocks base method
func (m *MockInterface) ResourceQuotas(namespace string) v1.ResourceQuotaInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceQuotas", namespace)
        ret0, _ := ret[0].(v1.ResourceQuotaInterface)
        return ret0
}</span>

// ResourceQuotas indicates an expected call of ResourceQuotas
func (mr *MockInterfaceMockRecorder) ResourceQuotas(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceQuotas", reflect.TypeOf((*MockInterface)(nil).ResourceQuotas), namespace)
}</span>

// Secrets mocks base method
func (m *MockInterface) Secrets(namespace string) v1.SecretInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Secrets", namespace)
        ret0, _ := ret[0].(v1.SecretInterface)
        return ret0
}</span>

// Secrets indicates an expected call of Secrets
func (mr *MockInterfaceMockRecorder) Secrets(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Secrets", reflect.TypeOf((*MockInterface)(nil).Secrets), namespace)
}</span>

// Services mocks base method
func (m *MockInterface) Services(namespace string) v1.ServiceInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Services", namespace)
        ret0, _ := ret[0].(v1.ServiceInterface)
        return ret0
}</span>

// Services indicates an expected call of Services
func (mr *MockInterfaceMockRecorder) Services(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Services", reflect.TypeOf((*MockInterface)(nil).Services), namespace)
}</span>

// ServiceAccounts mocks base method
func (m *MockInterface) ServiceAccounts(namespace string) v1.ServiceAccountInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ServiceAccounts", namespace)
        ret0, _ := ret[0].(v1.ServiceAccountInterface)
        return ret0
}</span>

// ServiceAccounts indicates an expected call of ServiceAccounts
func (mr *MockInterfaceMockRecorder) ServiceAccounts(namespace interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceAccounts", reflect.TypeOf((*MockInterface)(nil).ServiceAccounts), namespace)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by MockGen. DO NOT EDIT.
// Source: vendor/k8s.io/client-go/kubernetes/clientset.go

// Package mockkubeclient is a generated GoMock package.
package mockkubeclient

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        discovery "k8s.io/client-go/discovery"
        v1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1"
        v1alpha1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1alpha1"
        v1beta1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1beta1"
        v1alpha10 "k8s.io/client-go/kubernetes/typed/apiserverinternal/v1alpha1"
        v10 "k8s.io/client-go/kubernetes/typed/apps/v1"
        v1beta10 "k8s.io/client-go/kubernetes/typed/apps/v1beta1"
        v1beta2 "k8s.io/client-go/kubernetes/typed/apps/v1beta2"
        v11 "k8s.io/client-go/kubernetes/typed/authentication/v1"
        v1alpha11 "k8s.io/client-go/kubernetes/typed/authentication/v1alpha1"
        v1beta11 "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
        v12 "k8s.io/client-go/kubernetes/typed/authorization/v1"
        v1beta12 "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
        v13 "k8s.io/client-go/kubernetes/typed/autoscaling/v1"
        v2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2"
        v2beta1 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta1"
        v2beta2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta2"
        v14 "k8s.io/client-go/kubernetes/typed/batch/v1"
        v1beta13 "k8s.io/client-go/kubernetes/typed/batch/v1beta1"
        v15 "k8s.io/client-go/kubernetes/typed/certificates/v1"
        v1alpha19 "k8s.io/client-go/kubernetes/typed/certificates/v1alpha1"
        v1beta14 "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
        v16 "k8s.io/client-go/kubernetes/typed/coordination/v1"
        v1alpha211 "k8s.io/client-go/kubernetes/typed/coordination/v1alpha2"
        v1beta15 "k8s.io/client-go/kubernetes/typed/coordination/v1beta1"
        v17 "k8s.io/client-go/kubernetes/typed/core/v1"
        v18 "k8s.io/client-go/kubernetes/typed/discovery/v1"
        v1beta16 "k8s.io/client-go/kubernetes/typed/discovery/v1beta1"
        v19 "k8s.io/client-go/kubernetes/typed/events/v1"
        v1beta17 "k8s.io/client-go/kubernetes/typed/events/v1beta1"
        v1beta18 "k8s.io/client-go/kubernetes/typed/extensions/v1beta1"
        flowcontrolv1 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1"
        v1beta19 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta1"
        v1beta20 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta2"
        v1beta3 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta3"
        v110 "k8s.io/client-go/kubernetes/typed/networking/v1"
        v1alpha13 "k8s.io/client-go/kubernetes/typed/networking/v1alpha1"
        v1beta110 "k8s.io/client-go/kubernetes/typed/networking/v1beta1"
        v111 "k8s.io/client-go/kubernetes/typed/node/v1"
        v1alpha14 "k8s.io/client-go/kubernetes/typed/node/v1alpha1"
        v1beta111 "k8s.io/client-go/kubernetes/typed/node/v1beta1"
        v112 "k8s.io/client-go/kubernetes/typed/policy/v1"
        v1beta112 "k8s.io/client-go/kubernetes/typed/policy/v1beta1"
        v113 "k8s.io/client-go/kubernetes/typed/rbac/v1"
        v1alpha15 "k8s.io/client-go/kubernetes/typed/rbac/v1alpha1"
        v1beta113 "k8s.io/client-go/kubernetes/typed/rbac/v1beta1"
        v1alpha26 "k8s.io/client-go/kubernetes/typed/resource/v1alpha3"
        v1beta126 "k8s.io/client-go/kubernetes/typed/resource/v1beta1"
        v114 "k8s.io/client-go/kubernetes/typed/scheduling/v1"
        v1alpha17 "k8s.io/client-go/kubernetes/typed/scheduling/v1alpha1"
        v1beta114 "k8s.io/client-go/kubernetes/typed/scheduling/v1beta1"
        v115 "k8s.io/client-go/kubernetes/typed/storage/v1"
        v1alpha18 "k8s.io/client-go/kubernetes/typed/storage/v1alpha1"
        v1beta115 "k8s.io/client-go/kubernetes/typed/storage/v1beta1"
        v1alpha112 "k8s.io/client-go/kubernetes/typed/storagemigration/v1alpha1"
)

// MockInterface is a mock of Interface interface.
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface.
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance.
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov0" title="0">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AdmissionregistrationV1 mocks base method.
func (m *MockInterface) AdmissionregistrationV1() v1.AdmissionregistrationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1")
        ret0, _ := ret[0].(v1.AdmissionregistrationV1Interface)
        return ret0
}</span>

// AdmissionregistrationV1 indicates an expected call of AdmissionregistrationV1.
func (mr *MockInterfaceMockRecorder) AdmissionregistrationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1", reflect.TypeOf((*MockInterface)(nil).AdmissionregistrationV1))
}</span>

// AdmissionregistrationV1alpha1 mocks base method.
func (m *MockInterface) AdmissionregistrationV1alpha1() v1alpha1.AdmissionregistrationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1alpha1")
        ret0, _ := ret[0].(v1alpha1.AdmissionregistrationV1alpha1Interface)
        return ret0
}</span>

// AdmissionregistrationV1alpha1 indicates an expected call of AdmissionregistrationV1alpha1.
func (mr *MockInterfaceMockRecorder) AdmissionregistrationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1alpha1", reflect.TypeOf((*MockInterface)(nil).AdmissionregistrationV1alpha1))
}</span>

// AdmissionregistrationV1beta1 mocks base method.
func (m *MockInterface) AdmissionregistrationV1beta1() v1beta1.AdmissionregistrationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1beta1")
        ret0, _ := ret[0].(v1beta1.AdmissionregistrationV1beta1Interface)
        return ret0
}</span>

// AdmissionregistrationV1beta1 indicates an expected call of AdmissionregistrationV1beta1.
func (mr *MockInterfaceMockRecorder) AdmissionregistrationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1beta1", reflect.TypeOf((*MockInterface)(nil).AdmissionregistrationV1beta1))
}</span>

// AppsV1 mocks base method.
func (m *MockInterface) AppsV1() v10.AppsV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1")
        ret0, _ := ret[0].(v10.AppsV1Interface)
        return ret0
}</span>

// AppsV1 indicates an expected call of AppsV1.
func (mr *MockInterfaceMockRecorder) AppsV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1", reflect.TypeOf((*MockInterface)(nil).AppsV1))
}</span>

// AppsV1beta1 mocks base method.
func (m *MockInterface) AppsV1beta1() v1beta10.AppsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1beta1")
        ret0, _ := ret[0].(v1beta10.AppsV1beta1Interface)
        return ret0
}</span>

// AppsV1beta1 indicates an expected call of AppsV1beta1.
func (mr *MockInterfaceMockRecorder) AppsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1beta1", reflect.TypeOf((*MockInterface)(nil).AppsV1beta1))
}</span>

// AppsV1beta2 mocks base method.
func (m *MockInterface) AppsV1beta2() v1beta2.AppsV1beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1beta2")
        ret0, _ := ret[0].(v1beta2.AppsV1beta2Interface)
        return ret0
}</span>

// AppsV1beta2 indicates an expected call of AppsV1beta2.
func (mr *MockInterfaceMockRecorder) AppsV1beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1beta2", reflect.TypeOf((*MockInterface)(nil).AppsV1beta2))
}</span>

// AuthenticationV1 mocks base method.
func (m *MockInterface) AuthenticationV1() v11.AuthenticationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1")
        ret0, _ := ret[0].(v11.AuthenticationV1Interface)
        return ret0
}</span>

// AuthenticationV1 indicates an expected call of AuthenticationV1.
func (mr *MockInterfaceMockRecorder) AuthenticationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1", reflect.TypeOf((*MockInterface)(nil).AuthenticationV1))
}</span>

// AuthenticationV1alpha1 mocks base method.
func (m *MockInterface) AuthenticationV1alpha1() v1alpha11.AuthenticationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1alpha1")
        ret0, _ := ret[0].(v1alpha11.AuthenticationV1alpha1Interface)
        return ret0
}</span>

// AuthenticationV1alpha1 indicates an expected call of AuthenticationV1alpha1.
func (mr *MockInterfaceMockRecorder) AuthenticationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1alpha1", reflect.TypeOf((*MockInterface)(nil).AuthenticationV1alpha1))
}</span>

// AuthenticationV1beta1 mocks base method.
func (m *MockInterface) AuthenticationV1beta1() v1beta11.AuthenticationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1beta1")
        ret0, _ := ret[0].(v1beta11.AuthenticationV1beta1Interface)
        return ret0
}</span>

// AuthenticationV1beta1 indicates an expected call of AuthenticationV1beta1.
func (mr *MockInterfaceMockRecorder) AuthenticationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1beta1", reflect.TypeOf((*MockInterface)(nil).AuthenticationV1beta1))
}</span>

// AuthorizationV1 mocks base method.
func (m *MockInterface) AuthorizationV1() v12.AuthorizationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthorizationV1")
        ret0, _ := ret[0].(v12.AuthorizationV1Interface)
        return ret0
}</span>

// AuthorizationV1 indicates an expected call of AuthorizationV1.
func (mr *MockInterfaceMockRecorder) AuthorizationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthorizationV1", reflect.TypeOf((*MockInterface)(nil).AuthorizationV1))
}</span>

// AuthorizationV1beta1 mocks base method.
func (m *MockInterface) AuthorizationV1beta1() v1beta12.AuthorizationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthorizationV1beta1")
        ret0, _ := ret[0].(v1beta12.AuthorizationV1beta1Interface)
        return ret0
}</span>

// AuthorizationV1beta1 indicates an expected call of AuthorizationV1beta1.
func (mr *MockInterfaceMockRecorder) AuthorizationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthorizationV1beta1", reflect.TypeOf((*MockInterface)(nil).AuthorizationV1beta1))
}</span>

// AutoscalingV1 mocks base method.
func (m *MockInterface) AutoscalingV1() v13.AutoscalingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV1")
        ret0, _ := ret[0].(v13.AutoscalingV1Interface)
        return ret0
}</span>

// AutoscalingV1 indicates an expected call of AutoscalingV1.
func (mr *MockInterfaceMockRecorder) AutoscalingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV1", reflect.TypeOf((*MockInterface)(nil).AutoscalingV1))
}</span>

// AutoscalingV2 mocks base method.
func (m *MockInterface) AutoscalingV2() v2.AutoscalingV2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2")
        ret0, _ := ret[0].(v2.AutoscalingV2Interface)
        return ret0
}</span>

// AutoscalingV2 indicates an expected call of AutoscalingV2.
func (mr *MockInterfaceMockRecorder) AutoscalingV2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2", reflect.TypeOf((*MockInterface)(nil).AutoscalingV2))
}</span>

// AutoscalingV2beta1 mocks base method.
func (m *MockInterface) AutoscalingV2beta1() v2beta1.AutoscalingV2beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2beta1")
        ret0, _ := ret[0].(v2beta1.AutoscalingV2beta1Interface)
        return ret0
}</span>

// AutoscalingV2beta1 indicates an expected call of AutoscalingV2beta1.
func (mr *MockInterfaceMockRecorder) AutoscalingV2beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2beta1", reflect.TypeOf((*MockInterface)(nil).AutoscalingV2beta1))
}</span>

// AutoscalingV2beta2 mocks base method.
func (m *MockInterface) AutoscalingV2beta2() v2beta2.AutoscalingV2beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2beta2")
        ret0, _ := ret[0].(v2beta2.AutoscalingV2beta2Interface)
        return ret0
}</span>

// AutoscalingV2beta2 indicates an expected call of AutoscalingV2beta2.
func (mr *MockInterfaceMockRecorder) AutoscalingV2beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2beta2", reflect.TypeOf((*MockInterface)(nil).AutoscalingV2beta2))
}</span>

// BatchV1 mocks base method.
func (m *MockInterface) BatchV1() v14.BatchV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchV1")
        ret0, _ := ret[0].(v14.BatchV1Interface)
        return ret0
}</span>

// BatchV1 indicates an expected call of BatchV1.
func (mr *MockInterfaceMockRecorder) BatchV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchV1", reflect.TypeOf((*MockInterface)(nil).BatchV1))
}</span>

// BatchV1beta1 mocks base method.
func (m *MockInterface) BatchV1beta1() v1beta13.BatchV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchV1beta1")
        ret0, _ := ret[0].(v1beta13.BatchV1beta1Interface)
        return ret0
}</span>

// BatchV1beta1 indicates an expected call of BatchV1beta1.
func (mr *MockInterfaceMockRecorder) BatchV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchV1beta1", reflect.TypeOf((*MockInterface)(nil).BatchV1beta1))
}</span>

// CertificatesV1 mocks base method.
func (m *MockInterface) CertificatesV1() v15.CertificatesV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1")
        ret0, _ := ret[0].(v15.CertificatesV1Interface)
        return ret0
}</span>

// CertificatesV1 indicates an expected call of CertificatesV1.
func (mr *MockInterfaceMockRecorder) CertificatesV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1", reflect.TypeOf((*MockInterface)(nil).CertificatesV1))
}</span>

// CertificatesV1beta1 mocks base method.
func (m *MockInterface) CertificatesV1beta1() v1beta14.CertificatesV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1beta1")
        ret0, _ := ret[0].(v1beta14.CertificatesV1beta1Interface)
        return ret0
}</span>

// CertificatesV1beta1 indicates an expected call of CertificatesV1beta1.
func (mr *MockInterfaceMockRecorder) CertificatesV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1beta1", reflect.TypeOf((*MockInterface)(nil).CertificatesV1beta1))
}</span>

// CertificatesV1alpha1 mocks base method.
func (m *MockInterface) CertificatesV1alpha1() v1alpha19.CertificatesV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1alpha1")
        ret0, _ := ret[0].(v1alpha19.CertificatesV1alpha1Interface)
        return ret0
}</span>

// CertificatesV1alpha1 indicates an expected call of CertificatesV1alpha1.
func (mr *MockInterfaceMockRecorder) CertificatesV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1alpha1", reflect.TypeOf((*MockInterface)(nil).CertificatesV1alpha1))
}</span>

// CoordinationV1 mocks base method.
func (m *MockInterface) CoordinationV1() v16.CoordinationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1")
        ret0, _ := ret[0].(v16.CoordinationV1Interface)
        return ret0
}</span>

// CoordinationV1 indicates an expected call of CoordinationV1.
func (mr *MockInterfaceMockRecorder) CoordinationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1", reflect.TypeOf((*MockInterface)(nil).CoordinationV1))
}</span>

// CoordinationV1beta1 mocks base method.
func (m *MockInterface) CoordinationV1beta1() v1beta15.CoordinationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1beta1")
        ret0, _ := ret[0].(v1beta15.CoordinationV1beta1Interface)
        return ret0
}</span>

// CoordinationV1beta1 indicates an expected call of CoordinationV1beta1.
func (mr *MockInterfaceMockRecorder) CoordinationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1beta1", reflect.TypeOf((*MockInterface)(nil).CoordinationV1beta1))
}</span>

// CoordinationV1alpha2 mocks base method.
func (m *MockInterface) CoordinationV1alpha2() v1alpha211.CoordinationV1alpha2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1alpha2")
        ret0, _ := ret[0].(v1alpha211.CoordinationV1alpha2Interface)
        return ret0
}</span>

// CoordinationV1alpha2 indicates an expected call of CoordinationV1alpha2.
func (mr *MockInterfaceMockRecorder) CoordinationV1alpha2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1alpha2", reflect.TypeOf((*MockInterface)(nil).CoordinationV1alpha2))
}</span>

// CoreV1 mocks base method.
func (m *MockInterface) CoreV1() v17.CoreV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoreV1")
        ret0, _ := ret[0].(v17.CoreV1Interface)
        return ret0
}</span>

// CoreV1 indicates an expected call of CoreV1.
func (mr *MockInterfaceMockRecorder) CoreV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoreV1", reflect.TypeOf((*MockInterface)(nil).CoreV1))
}</span>

// Discovery mocks base method.
func (m *MockInterface) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Discovery")
        ret0, _ := ret[0].(discovery.DiscoveryInterface)
        return ret0
}</span>

// Discovery indicates an expected call of Discovery.
func (mr *MockInterfaceMockRecorder) Discovery() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Discovery", reflect.TypeOf((*MockInterface)(nil).Discovery))
}</span>

// DiscoveryV1 mocks base method.
func (m *MockInterface) DiscoveryV1() v18.DiscoveryV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DiscoveryV1")
        ret0, _ := ret[0].(v18.DiscoveryV1Interface)
        return ret0
}</span>

// DiscoveryV1 indicates an expected call of DiscoveryV1.
func (mr *MockInterfaceMockRecorder) DiscoveryV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscoveryV1", reflect.TypeOf((*MockInterface)(nil).DiscoveryV1))
}</span>

// DiscoveryV1beta1 mocks base method.
func (m *MockInterface) DiscoveryV1beta1() v1beta16.DiscoveryV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DiscoveryV1beta1")
        ret0, _ := ret[0].(v1beta16.DiscoveryV1beta1Interface)
        return ret0
}</span>

// DiscoveryV1beta1 indicates an expected call of DiscoveryV1beta1.
func (mr *MockInterfaceMockRecorder) DiscoveryV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscoveryV1beta1", reflect.TypeOf((*MockInterface)(nil).DiscoveryV1beta1))
}</span>

// EventsV1 mocks base method.
func (m *MockInterface) EventsV1() v19.EventsV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EventsV1")
        ret0, _ := ret[0].(v19.EventsV1Interface)
        return ret0
}</span>

// EventsV1 indicates an expected call of EventsV1.
func (mr *MockInterfaceMockRecorder) EventsV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EventsV1", reflect.TypeOf((*MockInterface)(nil).EventsV1))
}</span>

// EventsV1beta1 mocks base method.
func (m *MockInterface) EventsV1beta1() v1beta17.EventsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EventsV1beta1")
        ret0, _ := ret[0].(v1beta17.EventsV1beta1Interface)
        return ret0
}</span>

// EventsV1beta1 indicates an expected call of EventsV1beta1.
func (mr *MockInterfaceMockRecorder) EventsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EventsV1beta1", reflect.TypeOf((*MockInterface)(nil).EventsV1beta1))
}</span>

// ExtensionsV1beta1 mocks base method.
func (m *MockInterface) ExtensionsV1beta1() v1beta18.ExtensionsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ExtensionsV1beta1")
        ret0, _ := ret[0].(v1beta18.ExtensionsV1beta1Interface)
        return ret0
}</span>

// ExtensionsV1beta1 indicates an expected call of ExtensionsV1beta1.
func (mr *MockInterfaceMockRecorder) ExtensionsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtensionsV1beta1", reflect.TypeOf((*MockInterface)(nil).ExtensionsV1beta1))
}</span>

// FlowcontrolV1beta1 mocks base method.
func (m *MockInterface) FlowcontrolV1() flowcontrolv1.FlowcontrolV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1")
        ret0, _ := ret[0].(flowcontrolv1.FlowcontrolV1Interface)
        return ret0
}</span>

// FlowcontrolV1 indicates an expected call of FlowcontrolV1.
func (mr *MockInterfaceMockRecorder) FlowcontrolV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1", reflect.TypeOf((*MockInterface)(nil).FlowcontrolV1))
}</span>

// FlowcontrolV1beta1 mocks base method.
func (m *MockInterface) FlowcontrolV1beta1() v1beta19.FlowcontrolV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta1")
        ret0, _ := ret[0].(v1beta19.FlowcontrolV1beta1Interface)
        return ret0
}</span>

// FlowcontrolV1beta1 indicates an expected call of FlowcontrolV1beta1.
func (mr *MockInterfaceMockRecorder) FlowcontrolV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta1", reflect.TypeOf((*MockInterface)(nil).FlowcontrolV1beta1))
}</span>

// FlowcontrolV1beta2 mocks base method.
func (m *MockInterface) FlowcontrolV1beta2() v1beta20.FlowcontrolV1beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta2")
        ret0, _ := ret[0].(v1beta20.FlowcontrolV1beta2Interface)
        return ret0
}</span>

// FlowcontrolV1beta2 indicates an expected call of FlowcontrolV1beta2.
func (mr *MockInterfaceMockRecorder) FlowcontrolV1beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta2", reflect.TypeOf((*MockInterface)(nil).FlowcontrolV1beta2))
}</span>

// FlowcontrolV1beta3 mocks base method.
func (m *MockInterface) FlowcontrolV1beta3() v1beta3.FlowcontrolV1beta3Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta3")
        ret0, _ := ret[0].(v1beta3.FlowcontrolV1beta3Interface)
        return ret0
}</span>

// FlowcontrolV1beta3 indicates an expected call of FlowcontrolV1beta3.
func (mr *MockInterfaceMockRecorder) FlowcontrolV1beta3() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta3", reflect.TypeOf((*MockInterface)(nil).FlowcontrolV1beta3))
}</span>

// InternalV1alpha1 mocks base method.
func (m *MockInterface) InternalV1alpha1() v1alpha10.InternalV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InternalV1alpha1")
        ret0, _ := ret[0].(v1alpha10.InternalV1alpha1Interface)
        return ret0
}</span>

// InternalV1alpha1 indicates an expected call of InternalV1alpha1.
func (mr *MockInterfaceMockRecorder) InternalV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InternalV1alpha1", reflect.TypeOf((*MockInterface)(nil).InternalV1alpha1))
}</span>

// NetworkingV1 mocks base method.
func (m *MockInterface) NetworkingV1() v110.NetworkingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1")
        ret0, _ := ret[0].(v110.NetworkingV1Interface)
        return ret0
}</span>

// NetworkingV1 indicates an expected call of NetworkingV1.
func (mr *MockInterfaceMockRecorder) NetworkingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1", reflect.TypeOf((*MockInterface)(nil).NetworkingV1))
}</span>

// NetworkingV1alpha1 mocks base method.
func (m *MockInterface) NetworkingV1alpha1() v1alpha13.NetworkingV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1alpha1")
        ret0, _ := ret[0].(v1alpha13.NetworkingV1alpha1Interface)
        return ret0
}</span>

// NetworkingV1alpha1 indicates an expected call of NetworkingV1alpha1.
func (mr *MockInterfaceMockRecorder) NetworkingV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1alpha1", reflect.TypeOf((*MockInterface)(nil).NetworkingV1alpha1))
}</span>

// NetworkingV1beta1 mocks base method.
func (m *MockInterface) NetworkingV1beta1() v1beta110.NetworkingV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1beta1")
        ret0, _ := ret[0].(v1beta110.NetworkingV1beta1Interface)
        return ret0
}</span>

// NetworkingV1beta1 indicates an expected call of NetworkingV1beta1.
func (mr *MockInterfaceMockRecorder) NetworkingV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1beta1", reflect.TypeOf((*MockInterface)(nil).NetworkingV1beta1))
}</span>

// NodeV1 mocks base method.
func (m *MockInterface) NodeV1() v111.NodeV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1")
        ret0, _ := ret[0].(v111.NodeV1Interface)
        return ret0
}</span>

// NodeV1 indicates an expected call of NodeV1.
func (mr *MockInterfaceMockRecorder) NodeV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1", reflect.TypeOf((*MockInterface)(nil).NodeV1))
}</span>

// NodeV1alpha1 mocks base method.
func (m *MockInterface) NodeV1alpha1() v1alpha14.NodeV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1alpha1")
        ret0, _ := ret[0].(v1alpha14.NodeV1alpha1Interface)
        return ret0
}</span>

// NodeV1alpha1 indicates an expected call of NodeV1alpha1.
func (mr *MockInterfaceMockRecorder) NodeV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1alpha1", reflect.TypeOf((*MockInterface)(nil).NodeV1alpha1))
}</span>

// NodeV1beta1 mocks base method.
func (m *MockInterface) NodeV1beta1() v1beta111.NodeV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1beta1")
        ret0, _ := ret[0].(v1beta111.NodeV1beta1Interface)
        return ret0
}</span>

// NodeV1beta1 indicates an expected call of NodeV1beta1.
func (mr *MockInterfaceMockRecorder) NodeV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1beta1", reflect.TypeOf((*MockInterface)(nil).NodeV1beta1))
}</span>

// PolicyV1 mocks base method.
func (m *MockInterface) PolicyV1() v112.PolicyV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PolicyV1")
        ret0, _ := ret[0].(v112.PolicyV1Interface)
        return ret0
}</span>

// PolicyV1 indicates an expected call of PolicyV1.
func (mr *MockInterfaceMockRecorder) PolicyV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PolicyV1", reflect.TypeOf((*MockInterface)(nil).PolicyV1))
}</span>

// PolicyV1beta1 mocks base method.
func (m *MockInterface) PolicyV1beta1() v1beta112.PolicyV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PolicyV1beta1")
        ret0, _ := ret[0].(v1beta112.PolicyV1beta1Interface)
        return ret0
}</span>

// PolicyV1beta1 indicates an expected call of PolicyV1beta1.
func (mr *MockInterfaceMockRecorder) PolicyV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PolicyV1beta1", reflect.TypeOf((*MockInterface)(nil).PolicyV1beta1))
}</span>

// RbacV1 mocks base method.
func (m *MockInterface) RbacV1() v113.RbacV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1")
        ret0, _ := ret[0].(v113.RbacV1Interface)
        return ret0
}</span>

// RbacV1 indicates an expected call of RbacV1.
func (mr *MockInterfaceMockRecorder) RbacV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1", reflect.TypeOf((*MockInterface)(nil).RbacV1))
}</span>

// RbacV1alpha1 mocks base method.
func (m *MockInterface) RbacV1alpha1() v1alpha15.RbacV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1alpha1")
        ret0, _ := ret[0].(v1alpha15.RbacV1alpha1Interface)
        return ret0
}</span>

// RbacV1alpha1 indicates an expected call of RbacV1alpha1.
func (mr *MockInterfaceMockRecorder) RbacV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1alpha1", reflect.TypeOf((*MockInterface)(nil).RbacV1alpha1))
}</span>

// RbacV1beta1 mocks base method.
func (m *MockInterface) RbacV1beta1() v1beta113.RbacV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1beta1")
        ret0, _ := ret[0].(v1beta113.RbacV1beta1Interface)
        return ret0
}</span>

// RbacV1beta1 indicates an expected call of RbacV1beta1.
func (mr *MockInterfaceMockRecorder) RbacV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1beta1", reflect.TypeOf((*MockInterface)(nil).RbacV1beta1))
}</span>

// ResourceV1alpha2 mocks base method.
func (m *MockInterface) ResourceV1alpha3() v1alpha26.ResourceV1alpha3Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceV1alpha3")
        ret0, _ := ret[0].(v1alpha26.ResourceV1alpha3Interface)
        return ret0
}</span>

// ResourceV1alpha2 indicates an expected call of ResourceV1alpha2.
func (mr *MockInterfaceMockRecorder) ResourceV1alpha3() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceV1alpha3", reflect.TypeOf((*MockInterface)(nil).ResourceV1alpha3))
}</span>

// ResourceV1beta1 mocks base method.
func (m *MockInterface) ResourceV1beta1() v1beta126.ResourceV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceV1beta1")
        ret0, _ := ret[0].(v1beta126.ResourceV1beta1Interface)
        return ret0
}</span>

// ResourceV1beta1 indicates an expected call of ResourceV1beta1.
func (mr *MockInterfaceMockRecorder) ResourceV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceV1beta1", reflect.TypeOf((*MockInterface)(nil).ResourceV1beta1))
}</span>

// SchedulingV1 mocks base method.
func (m *MockInterface) SchedulingV1() v114.SchedulingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1")
        ret0, _ := ret[0].(v114.SchedulingV1Interface)
        return ret0
}</span>

// SchedulingV1 indicates an expected call of SchedulingV1.
func (mr *MockInterfaceMockRecorder) SchedulingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1", reflect.TypeOf((*MockInterface)(nil).SchedulingV1))
}</span>

// SchedulingV1alpha1 mocks base method.
func (m *MockInterface) SchedulingV1alpha1() v1alpha17.SchedulingV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1alpha1")
        ret0, _ := ret[0].(v1alpha17.SchedulingV1alpha1Interface)
        return ret0
}</span>

// SchedulingV1alpha1 indicates an expected call of SchedulingV1alpha1.
func (mr *MockInterfaceMockRecorder) SchedulingV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1alpha1", reflect.TypeOf((*MockInterface)(nil).SchedulingV1alpha1))
}</span>

// SchedulingV1beta1 mocks base method.
func (m *MockInterface) SchedulingV1beta1() v1beta114.SchedulingV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1beta1")
        ret0, _ := ret[0].(v1beta114.SchedulingV1beta1Interface)
        return ret0
}</span>

// SchedulingV1beta1 indicates an expected call of SchedulingV1beta1.
func (mr *MockInterfaceMockRecorder) SchedulingV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1beta1", reflect.TypeOf((*MockInterface)(nil).SchedulingV1beta1))
}</span>

// StorageV1 mocks base method.
func (m *MockInterface) StorageV1() v115.StorageV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1")
        ret0, _ := ret[0].(v115.StorageV1Interface)
        return ret0
}</span>

// StorageV1 indicates an expected call of StorageV1.
func (mr *MockInterfaceMockRecorder) StorageV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1", reflect.TypeOf((*MockInterface)(nil).StorageV1))
}</span>

// StorageV1alpha1 mocks base method.
func (m *MockInterface) StorageV1alpha1() v1alpha18.StorageV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1alpha1")
        ret0, _ := ret[0].(v1alpha18.StorageV1alpha1Interface)
        return ret0
}</span>

// StorageV1alpha1 indicates an expected call of StorageV1alpha1.
func (mr *MockInterfaceMockRecorder) StorageV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1alpha1", reflect.TypeOf((*MockInterface)(nil).StorageV1alpha1))
}</span>

// StorageV1beta1 mocks base method.
func (m *MockInterface) StorageV1beta1() v1beta115.StorageV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1beta1")
        ret0, _ := ret[0].(v1beta115.StorageV1beta1Interface)
        return ret0
}</span>

// StorageV1beta1 indicates an expected call of StorageV1beta1.
func (mr *MockInterfaceMockRecorder) StorageV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1beta1", reflect.TypeOf((*MockInterface)(nil).StorageV1beta1))
}</span>

// StoragemigrationV1alpha1 mocks base method.
func (m *MockInterface) StoragemigrationV1alpha1() v1alpha112.StoragemigrationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StoragemigrationV1alpha1")
        ret0, _ := ret[0].(v1alpha112.StoragemigrationV1alpha1Interface)
        return ret0
}</span>

// StoragemigrationV1alpha1 indicates an expected call of StoragemigrationV1alpha1.
func (mr *MockInterfaceMockRecorder) StoragemigrationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoragemigrationV1alpha1", reflect.TypeOf((*MockInterface)(nil).StoragemigrationV1alpha1))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mockpersistentvolume

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        corev1 "k8s.io/client-go/applyconfigurations/core/v1"

        v11 "k8s.io/client-go/kubernetes/typed/core/v1"
)

// MockPersistentVolumesGetter is a mock of PersistentVolumesGetter interface
type MockPersistentVolumesGetter struct {
        ctrl     *gomock.Controller
        recorder *MockPersistentVolumesGetterMockRecorder
}

// MockPersistentVolumesGetterMockRecorder is the mock recorder for MockPersistentVolumesGetter
type MockPersistentVolumesGetterMockRecorder struct {
        mock *MockPersistentVolumesGetter
}

// NewMockPersistentVolumesGetter creates a new mock instance
func NewMockPersistentVolumesGetter(ctrl *gomock.Controller) *MockPersistentVolumesGetter <span class="cov0" title="0">{
        mock := &amp;MockPersistentVolumesGetter{ctrl: ctrl}
        mock.recorder = &amp;MockPersistentVolumesGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPersistentVolumesGetter) EXPECT() *MockPersistentVolumesGetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// PersistentVolumes mocks base method
func (m *MockPersistentVolumesGetter) PersistentVolumes() v11.PersistentVolumeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PersistentVolumes")
        ret0, _ := ret[0].(v11.PersistentVolumeInterface)
        return ret0
}</span>

// PersistentVolumes indicates an expected call of PersistentVolumes
func (mr *MockPersistentVolumesGetterMockRecorder) PersistentVolumes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistentVolumes", reflect.TypeOf((*MockPersistentVolumesGetter)(nil).PersistentVolumes))
}</span>

// MockInterface is a mock of PersistentVolumeInterface interface
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov0" title="0">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method
func (m *MockInterface) Create(ctx context.Context, persistentVolume *v1.PersistentVolume, opts metav1.CreateOptions) (*v1.PersistentVolume, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, persistentVolume, opts)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create
func (mr *MockInterfaceMockRecorder) Create(ctx, persistentVolume, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockInterface)(nil).Create), ctx, persistentVolume, opts)
}</span>

// Update mocks base method
func (m *MockInterface) Update(ctx context.Context, persistentVolume *v1.PersistentVolume, opts metav1.UpdateOptions) (*v1.PersistentVolume, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, persistentVolume, opts)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update
func (mr *MockInterfaceMockRecorder) Update(ctx, persistentVolume, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockInterface)(nil).Update), ctx, persistentVolume, opts)
}</span>

// UpdateStatus mocks base method
func (m *MockInterface) UpdateStatus(ctx context.Context, persistentVolume *v1.PersistentVolume, opts metav1.UpdateOptions) (*v1.PersistentVolume, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateStatus", ctx, persistentVolume, opts)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateStatus indicates an expected call of UpdateStatus
func (mr *MockInterfaceMockRecorder) UpdateStatus(ctx, persistentVolume, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockInterface)(nil).UpdateStatus), ctx, persistentVolume, opts)
}</span>

// Delete mocks base method
func (m *MockInterface) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, name, opts)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete
func (mr *MockInterfaceMockRecorder) Delete(ctx, name, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockInterface)(nil).Delete), ctx, name, opts)
}</span>

// DeleteCollection mocks base method
func (m *MockInterface) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCollection", ctx, opts, listOpts)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteCollection indicates an expected call of DeleteCollection
func (mr *MockInterfaceMockRecorder) DeleteCollection(ctx, opts, listOpts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockInterface)(nil).DeleteCollection), ctx, opts, listOpts)
}</span>

// Get mocks base method
func (m *MockInterface) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.PersistentVolume, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, name, opts)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get
func (mr *MockInterfaceMockRecorder) Get(ctx, name, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockInterface)(nil).Get), ctx, name, opts)
}</span>

// List mocks base method
func (m *MockInterface) List(ctx context.Context, opts metav1.ListOptions) (*v1.PersistentVolumeList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", ctx, opts)
        ret0, _ := ret[0].(*v1.PersistentVolumeList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List
func (mr *MockInterfaceMockRecorder) List(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockInterface)(nil).List), ctx, opts)
}</span>

// Watch mocks base method
func (m *MockInterface) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Watch", ctx, opts)
        ret0, _ := ret[0].(watch.Interface)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Watch indicates an expected call of Watch
func (mr *MockInterfaceMockRecorder) Watch(ctx, opts interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockInterface)(nil).Watch), ctx, opts)
}</span>

// Patch mocks base method
func (m *MockInterface) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (*v1.PersistentVolume, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, name, pt, data, opts}
        for _, a := range subresources </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Patch", varargs...)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Patch indicates an expected call of Patch
func (mr *MockInterfaceMockRecorder) Patch(ctx, name, pt, data, opts interface{}, subresources ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, name, pt, data, opts}, subresources...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockInterface)(nil).Patch), varargs...)
}</span>

// Apply mocks base method
func (m *MockInterface) Apply(ctx context.Context, persistentVolume *corev1.PersistentVolumeApplyConfiguration, opts metav1.ApplyOptions) (result *v1.PersistentVolume, err error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, persistentVolume, opts}
        ret := m.ctrl.Call(m, "Apply", varargs...)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ApplyStatus mocks base method
func (m *MockInterface) ApplyStatus(ctx context.Context, persistentVolume *corev1.PersistentVolumeApplyConfiguration, opts metav1.ApplyOptions) (result *v1.PersistentVolume, err error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, persistentVolume, opts}
        ret := m.ctrl.Call(m, "ApplyStatus", varargs...)
        ret0, _ := ret[0].(*v1.PersistentVolume)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
        volumehelper "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        azcache "sigs.k8s.io/cloud-provider-azure/pkg/cache"
        "sigs.k8s.io/cloud-provider-azure/pkg/metrics"
        azure "sigs.k8s.io/cloud-provider-azure/pkg/provider"

        "github.com/container-storage-interface/spec/lib/go/csi"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        cloudprovider "k8s.io/cloud-provider"
        "k8s.io/klog/v2"
        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
)

const (
        defaultLinuxFsType              = "ext4"
        defaultWindowsFsType            = "ntfs"
        defaultAzureVolumeLimit         = 16
        volumeOperationAlreadyExistsFmt = "An operation with the given Volume ID %s already exists"
)

func getDefaultFsType() string <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return defaultWindowsFsType
        }</span>

        <span class="cov8" title="1">return defaultLinuxFsType</span>
}

// NodeStageVolume mount disk device to a staging path
func (d *Driver) NodeStageVolume(_ context.Context, req *csi.NodeStageVolumeRequest) (*csi.NodeStageVolumeResponse, error) <span class="cov8" title="1">{
        diskURI := req.GetVolumeId()
        if len(diskURI) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetStagingTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">volumeCapability := req.GetVolumeCapability()
        if volumeCapability == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not provided")
        }</span>

        <span class="cov8" title="1">params := req.GetVolumeContext()
        maxShares, err := azureutils.GetMaxShares(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "MaxShares value not supported")
        }</span>

        <span class="cov8" title="1">if err := azureutils.IsValidVolumeCapabilities([]*csi.VolumeCapability{volumeCapability}, maxShares); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "node_stage_volume", d.cloud.ResourceGroup, "", d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, diskURI)
        }</span>()

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(diskURI); !acquired </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, diskURI)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(diskURI)

        lun, ok := req.PublishContext[consts.LUN]
        if !ok </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "lun not provided")
        }</span>

        <span class="cov8" title="1">source, err := d.getDevicePathWithLUN(lun)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to find disk on lun %s. %v", lun, err)
        }</span>

        // If perf optimizations are enabled
        // tweak device settings to enhance performance
        <span class="cov8" title="1">if d.getPerfOptimizationEnabled() </span><span class="cov8" title="1">{
                profile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettings, err := optimization.GetDiskPerfAttributes(req.GetVolumeContext())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "failed to get perf attributes for %s. Error: %v", source, err)
                }</span>

                <span class="cov8" title="1">if d.getDeviceHelper().DiskSupportsPerfOptimization(profile, accountType) </span><span class="cov8" title="1">{
                        if err := d.getDeviceHelper().OptimizeDiskPerformance(d.getNodeInfo(), source, profile, accountType,
                                diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettings); err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.Internal, "failed to optimize device performance for target(%s) error(%s)", source, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        klog.V(6).Infof("NodeStageVolume: perf optimization is disabled for %s. perfProfile %s accountType %s", source, profile, accountType)
                }</span>
        }

        // If the access type is block, do nothing for stage
        <span class="cov8" title="1">switch req.GetVolumeCapability().GetAccessType().(type) </span>{
        case *csi.VolumeCapability_Block:<span class="cov0" title="0">
                return &amp;csi.NodeStageVolumeResponse{}, nil</span>
        }

        <span class="cov8" title="1">mnt, err := d.ensureMountPoint(target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "could not mount target %q: %v", target, err)
        }</span>
        <span class="cov8" title="1">if mnt </span><span class="cov0" title="0">{
                klog.V(2).Infof("NodeStageVolume: already mounted on target %s", target)
                return &amp;csi.NodeStageVolumeResponse{}, nil
        }</span>

        // Get fsType and mountOptions that the volume will be formatted and mounted with
        <span class="cov8" title="1">fstype := getDefaultFsType()
        options := []string{}
        if mnt := volumeCapability.GetMount(); mnt != nil </span><span class="cov8" title="1">{
                if mnt.FsType != "" </span><span class="cov8" title="1">{
                        fstype = mnt.FsType
                }</span>
                <span class="cov8" title="1">options = append(options, collectMountOptions(fstype, mnt.MountFlags)...)</span>
        }

        <span class="cov8" title="1">volContextFSType := azureutils.GetFStype(req.GetVolumeContext())
        if volContextFSType != "" </span><span class="cov8" title="1">{
                // respect "fstype" setting in storage class parameters
                fstype = volContextFSType
        }</span>

        // If partition is specified, should mount it only instead of the entire disk.
        <span class="cov8" title="1">if partition, ok := req.GetVolumeContext()[consts.VolumeAttributePartition]; ok </span><span class="cov0" title="0">{
                source = source + "-part" + partition
        }</span>

        // FormatAndMount will format only if needed
        <span class="cov8" title="1">klog.V(2).Infof("NodeStageVolume: formatting %s and mounting at %s with mount options(%s)", source, target, options)
        if err := d.formatAndMount(source, target, fstype, options); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "could not format %s(lun: %s), and mount it at %s, failed with %v", source, lun, target, err)
        }</span>
        <span class="cov8" title="1">klog.V(2).Infof("NodeStageVolume: format %s and mounting at %s successfully.", source, target)

        var needResize bool
        if required, ok := req.GetVolumeContext()[consts.ResizeRequired]; ok &amp;&amp; strings.EqualFold(required, consts.TrueValue) </span><span class="cov8" title="1">{
                needResize = true
        }</span>
        <span class="cov8" title="1">if !needResize </span><span class="cov8" title="1">{
                // Filesystem resize is required after snapshot restore / volume clone
                // https://github.com/kubernetes/kubernetes/issues/94929
                if needResize, err = needResizeVolume(source, target, d.mounter); err != nil </span><span class="cov8" title="1">{
                        klog.Errorf("NodeStageVolume: could not determine if volume %s needs to be resized: %v", diskURI, err)
                }</span>
        }

        // if resize is required, resize filesystem
        <span class="cov8" title="1">if needResize </span><span class="cov8" title="1">{
                klog.V(2).Infof("NodeStageVolume: fs resize initiating on target(%s) volumeid(%s)", target, diskURI)
                if err := resizeVolume(source, target, d.mounter); err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "NodeStageVolume: could not resize volume %s (%s):  %v", source, target, err)
                }</span>
                <span class="cov8" title="1">klog.V(2).Infof("NodeStageVolume: fs resize successful on target(%s) volumeid(%s).", target, diskURI)</span>
        }
        <span class="cov8" title="1">isOperationSucceeded = true
        return &amp;csi.NodeStageVolumeResponse{}, nil</span>
}

// NodeUnstageVolume unmount disk device from a staging path
func (d *Driver) NodeUnstageVolume(_ context.Context, req *csi.NodeUnstageVolumeRequest) (*csi.NodeUnstageVolumeResponse, error) <span class="cov8" title="1">{
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">stagingTargetPath := req.GetStagingTargetPath()
        if len(stagingTargetPath) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "node_unstage_volume", d.cloud.ResourceGroup, "", d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, volumeID)
        }</span>()

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(volumeID); !acquired </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, volumeID)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(volumeID)

        klog.V(2).Infof("NodeUnstageVolume: unmounting %s", stagingTargetPath)
        if err := CleanupMountPoint(stagingTargetPath, d.mounter, true /*extensiveMountPointCheck*/); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to unmount staging target %q: %v", stagingTargetPath, err)
        }</span>
        <span class="cov8" title="1">klog.V(2).Infof("NodeUnstageVolume: unmount %s successfully", stagingTargetPath)

        isOperationSucceeded = true
        return &amp;csi.NodeUnstageVolumeResponse{}, nil</span>
}

// NodePublishVolume mount the volume from staging to target path
func (d *Driver) NodePublishVolume(_ context.Context, req *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) <span class="cov8" title="1">{
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>

        <span class="cov8" title="1">volumeCapability := req.GetVolumeCapability()
        if volumeCapability == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability missing in request")
        }</span>

        <span class="cov8" title="1">params := req.GetVolumeContext()
        maxShares, err := azureutils.GetMaxShares(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "MaxShares value not supported")
        }</span>

        <span class="cov8" title="1">if err := azureutils.IsValidVolumeCapabilities([]*csi.VolumeCapability{volumeCapability}, maxShares); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">source := req.GetStagingTargetPath()
        if len(source) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Target path not provided")
        }</span>

        <span class="cov8" title="1">err = preparePublishPath(target, d.mounter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("Target path could not be prepared: %v", err))
        }</span>

        <span class="cov8" title="1">mountOptions := []string{"bind"}
        if req.GetReadonly() </span><span class="cov8" title="1">{
                mountOptions = append(mountOptions, "ro")
        }</span>

        <span class="cov8" title="1">switch req.GetVolumeCapability().GetAccessType().(type) </span>{
        case *csi.VolumeCapability_Block:<span class="cov8" title="1">
                lun, ok := req.PublishContext[consts.LUN]
                if !ok </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, "lun not provided")
                }</span>
                <span class="cov8" title="1">var err error
                source, err = d.getDevicePathWithLUN(lun)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "failed to find device path with lun %s. %v", lun, err)
                }</span>
                <span class="cov0" title="0">klog.V(2).Infof("NodePublishVolume [block]: found device path %s with lun %s", source, lun)
                if err = d.ensureBlockTargetFile(target); err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "%v", err)
                }</span>
        case *csi.VolumeCapability_Mount:<span class="cov8" title="1">
                mnt, err := d.ensureMountPoint(target)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "could not mount target %q: %v", target, err)
                }</span>
                <span class="cov8" title="1">if mnt </span><span class="cov8" title="1">{
                        klog.V(2).Infof("NodePublishVolume: already mounted on target %s", target)
                        return &amp;csi.NodePublishVolumeResponse{}, nil
                }</span>
        }

        <span class="cov8" title="1">klog.V(2).Infof("NodePublishVolume: mounting %s at %s", source, target)
        if err := d.mounter.Mount(source, target, "", mountOptions); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "could not mount %q at %q: %v", source, target, err)
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("NodePublishVolume: mount %s at %s successfully", source, target)

        return &amp;csi.NodePublishVolumeResponse{}, nil</span>
}

// NodeUnpublishVolume unmount the volume from the target path
func (d *Driver) NodeUnpublishVolume(_ context.Context, req *csi.NodeUnpublishVolumeRequest) (*csi.NodeUnpublishVolumeResponse, error) <span class="cov8" title="1">{
        targetPath := req.GetTargetPath()
        volumeID := req.GetVolumeId()

        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID missing in the request")
        }</span>
        <span class="cov8" title="1">if len(targetPath) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Target path missing in request")
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("NodeUnpublishVolume: unmounting volume %s on %s", volumeID, targetPath)
        extensiveMountPointCheck := true
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // on Windows, this parameter indicates whether to unmount volume, not necessary in NodeUnpublishVolume
                extensiveMountPointCheck = false
        }</span>
        <span class="cov8" title="1">if err := CleanupMountPoint(targetPath, d.mounter, extensiveMountPointCheck); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to unmount target %q: %v", targetPath, err)
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("NodeUnpublishVolume: unmount volume %s on %s successfully", volumeID, targetPath)

        return &amp;csi.NodeUnpublishVolumeResponse{}, nil</span>
}

// NodeGetCapabilities return the capabilities of the Node plugin
func (d *Driver) NodeGetCapabilities(_ context.Context, _ *csi.NodeGetCapabilitiesRequest) (*csi.NodeGetCapabilitiesResponse, error) <span class="cov8" title="1">{
        return &amp;csi.NodeGetCapabilitiesResponse{
                Capabilities: d.NSCap,
        }, nil
}</span>

// NodeGetInfo return info of the node on which this plugin is running
func (d *Driver) NodeGetInfo(ctx context.Context, _ *csi.NodeGetInfoRequest) (*csi.NodeGetInfoResponse, error) <span class="cov8" title="1">{
        topology := &amp;csi.Topology{
                Segments: map[string]string{topologyKey: ""},
        }

        var failureDomainFromLabels, instanceTypeFromLabels string
        var err error

        if d.supportZone </span><span class="cov8" title="1">{
                var zone cloudprovider.Zone
                if d.getNodeInfoFromLabels </span><span class="cov0" title="0">{
                        failureDomainFromLabels, instanceTypeFromLabels, err = GetNodeInfoFromLabels(ctx, d.NodeID, d.cloud.KubeClient)
                }</span> else<span class="cov8" title="1"> {
                        if runtime.GOOS == "windows" &amp;&amp; (!d.cloud.UseInstanceMetadata || d.cloud.Metadata == nil) </span><span class="cov0" title="0">{
                                zone, err = d.cloud.VMSet.GetZoneByNodeName(ctx, d.NodeID)
                        }</span> else<span class="cov8" title="1"> {
                                zone, err = d.cloud.GetZone(ctx)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                klog.Warningf("get zone(%s) failed with: %v, fall back to get zone from node labels", d.NodeID, err)
                                failureDomainFromLabels, instanceTypeFromLabels, err = GetNodeInfoFromLabels(ctx, d.NodeID, d.cloud.KubeClient)
                        }</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("GetNodeInfoFromLabels on node(%s) failed with %v", d.NodeID, err))
                }</span>
                <span class="cov8" title="1">if zone.FailureDomain == "" </span><span class="cov0" title="0">{
                        zone.FailureDomain = failureDomainFromLabels
                }</span>

                <span class="cov8" title="1">klog.V(2).Infof("NodeGetInfo, nodeName: %s, failureDomain: %s", d.NodeID, zone.FailureDomain)
                if azureutils.IsValidAvailabilityZone(zone.FailureDomain, d.cloud.Location) </span><span class="cov8" title="1">{
                        topology.Segments[topologyKey] = zone.FailureDomain
                        topology.Segments[consts.WellKnownTopologyKey] = zone.FailureDomain
                }</span>
        }

        <span class="cov8" title="1">maxDataDiskCount := d.VolumeAttachLimit
        if maxDataDiskCount &lt; 0 </span><span class="cov8" title="1">{
                var instanceType string
                var err error
                if d.getNodeInfoFromLabels </span><span class="cov0" title="0">{
                        if instanceTypeFromLabels == "" </span><span class="cov0" title="0">{
                                _, instanceTypeFromLabels, err = GetNodeInfoFromLabels(ctx, d.NodeID, d.cloud.KubeClient)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if runtime.GOOS == "windows" &amp;&amp; d.cloud.UseInstanceMetadata &amp;&amp; d.cloud.Metadata != nil </span><span class="cov0" title="0">{
                                var metadata *azure.InstanceMetadata
                                metadata, err = d.cloud.Metadata.GetMetadata(ctx, azcache.CacheReadTypeDefault)
                                if err == nil &amp;&amp; metadata != nil &amp;&amp; metadata.Compute != nil </span><span class="cov0" title="0">{
                                        instanceType = metadata.Compute.VMSize
                                        klog.V(2).Infof("NodeGetInfo: nodeName(%s), VM Size(%s)", d.NodeID, instanceType)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                instances, ok := d.cloud.Instances()
                                if !ok </span><span class="cov0" title="0">{
                                        klog.Warningf("failed to get instances from cloud provider")
                                }</span> else<span class="cov8" title="1"> {
                                        instanceType, err = instances.InstanceType(ctx, types.NodeName(d.NodeID))
                                }</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                klog.Warningf("get instance type(%s) failed with: %v", d.NodeID, err)
                        }</span>
                        <span class="cov8" title="1">if instanceType == "" &amp;&amp; instanceTypeFromLabels == "" </span><span class="cov0" title="0">{
                                klog.Warningf("fall back to get instance type from node labels")
                                _, instanceTypeFromLabels, err = GetNodeInfoFromLabels(ctx, d.NodeID, d.cloud.KubeClient)
                        }</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("GetNodeInfoFromLabels on node(%s) failed with %v", d.NodeID, err)
                }</span>
                <span class="cov8" title="1">if instanceType == "" </span><span class="cov0" title="0">{
                        instanceType = instanceTypeFromLabels
                }</span>
                <span class="cov8" title="1">totalDiskDataCount, _ := GetMaxDataDiskCount(instanceType)
                maxDataDiskCount = totalDiskDataCount - d.ReservedDataDiskSlotNum</span>
        }

        <span class="cov8" title="1">nodeID := d.NodeID
        if d.getNodeIDFromIMDS &amp;&amp; d.cloud.UseInstanceMetadata &amp;&amp; d.cloud.Metadata != nil </span><span class="cov0" title="0">{
                metadata, err := d.cloud.Metadata.GetMetadata(ctx, azcache.CacheReadTypeDefault)
                if err == nil &amp;&amp; metadata != nil &amp;&amp; metadata.Compute != nil </span><span class="cov0" title="0">{
                        klog.V(2).Infof("NodeGetInfo: NodeID(%s), metadata.Compute.Name(%s)", d.NodeID, metadata.Compute.Name)
                        if metadata.Compute.Name != "" </span><span class="cov0" title="0">{
                                if metadata.Compute.VMScaleSetName != "" </span><span class="cov0" title="0">{
                                        id, err := getVMSSInstanceName(metadata.Compute.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                klog.Errorf("getVMSSInstanceName failed with %v", err)
                                                if nodeID == "" </span><span class="cov0" title="0">{
                                                        klog.V(2).Infof("NodeGetInfo: NodeID is empty, use metadata.Compute.Name(%s)", metadata.Compute.Name)
                                                        nodeID = metadata.Compute.Name
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                nodeID = id
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        nodeID = metadata.Compute.Name
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        klog.Warningf("get instance type(%s) failed with: %v", d.NodeID, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;csi.NodeGetInfoResponse{
                NodeId:             nodeID,
                MaxVolumesPerNode:  maxDataDiskCount,
                AccessibleTopology: topology,
        }, nil</span>
}

func GetMaxDataDiskCount(instanceType string) (int64, bool) <span class="cov8" title="1">{
        vmsize := strings.ToUpper(instanceType)
        maxDataDiskCount, exists := maxDataDiskCountMap[vmsize]
        if exists </span><span class="cov8" title="1">{
                klog.V(5).Infof("got a matching size in getMaxDataDiskCount, VM Size: %s, MaxDataDiskCount: %d", vmsize, maxDataDiskCount)
                return maxDataDiskCount, true
        }</span>

        <span class="cov8" title="1">klog.V(5).Infof("not found a matching size in getMaxDataDiskCount, VM Size: %s, use default volume limit: %d", vmsize, defaultAzureVolumeLimit)
        return defaultAzureVolumeLimit, false</span>
}

func (d *Driver) NodeGetVolumeStats(ctx context.Context, req *csi.NodeGetVolumeStatsRequest) (*csi.NodeGetVolumeStatsResponse, error) <span class="cov8" title="1">{
        if len(req.VolumeId) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats volume ID was empty")
        }</span>
        <span class="cov8" title="1">if len(req.VolumePath) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats volume path was empty")
        }</span>

        <span class="cov8" title="1">volUsage, err := d.GetVolumeStats(ctx, d.mounter, req.VolumeId, req.VolumePath, d.hostUtil)
        if err != nil </span><span class="cov8" title="1">{
                klog.Errorf("NodeGetVolumeStats: failed to get volume stats for volume %s path %s: %v", req.VolumeId, req.VolumePath, err)
        }</span>
        <span class="cov8" title="1">return &amp;csi.NodeGetVolumeStatsResponse{
                Usage: volUsage,
        }, err</span>
}

// NodeExpandVolume node expand volume
func (d *Driver) NodeExpandVolume(_ context.Context, req *csi.NodeExpandVolumeRequest) (*csi.NodeExpandVolumeResponse, error) <span class="cov8" title="1">{
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>
        <span class="cov8" title="1">capacityBytes := req.GetCapacityRange().GetRequiredBytes()
        volSizeBytes := int64(capacityBytes)
        requestGiB := volumehelper.RoundUpGiB(volSizeBytes)

        volumePath := req.GetVolumePath()
        if len(volumePath) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "volume path must be provided")
        }</span>

        <span class="cov8" title="1">isBlock, err := d.getHostUtil().PathIsDevice(volumePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.NotFound, "failed to determine device path for volumePath [%v]: %v", volumePath, err)
        }</span>
        <span class="cov8" title="1">if !isBlock </span><span class="cov8" title="1">{
                volumeCapability := req.GetVolumeCapability()
                if volumeCapability != nil </span><span class="cov8" title="1">{
                        isBlock = volumeCapability.GetBlock() != nil
                }</span>
        }

        <span class="cov8" title="1">if isBlock </span><span class="cov8" title="1">{
                if d.enableDiskOnlineResize </span><span class="cov0" title="0">{
                        klog.V(2).Infof("NodeExpandVolume begin to rescan all devices on block volume(%s)", volumeID)
                        if err := rescanAllVolumes(d.ioHandler); err != nil </span><span class="cov0" title="0">{
                                klog.Errorf("NodeExpandVolume rescanAllVolumes failed with error: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">klog.V(2).Infof("NodeExpandVolume skip resize operation on block volume(%s)", volumeID)
                return &amp;csi.NodeExpandVolumeResponse{}, nil</span>
        }

        <span class="cov8" title="1">mc := metrics.NewMetricContext(consts.AzureDiskCSIDriverName, "node_expand_volume", d.cloud.ResourceGroup, "", d.Name)
        isOperationSucceeded := false
        defer func() </span><span class="cov8" title="1">{
                mc.ObserveOperationWithResult(isOperationSucceeded, consts.VolumeID, volumeID)
        }</span>()

        <span class="cov8" title="1">if acquired := d.volumeLocks.TryAcquire(volumeID); !acquired </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Aborted, volumeOperationAlreadyExistsFmt, volumeID)
        }</span>
        <span class="cov8" title="1">defer d.volumeLocks.Release(volumeID)

        devicePath, err := getDevicePathWithMountPath(volumePath, d.mounter)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.NotFound, "%v", err)
        }</span>

        <span class="cov8" title="1">if d.enableDiskOnlineResize </span><span class="cov0" title="0">{
                klog.V(2).Infof("NodeExpandVolume begin to rescan device %s on volume(%s)", devicePath, volumeID)
                if err := rescanVolume(d.ioHandler, devicePath); err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("NodeExpandVolume rescanVolume failed with error: %v", err)
                }</span>
        }

        <span class="cov8" title="1">var retErr error
        if err := resizeVolume(devicePath, volumePath, d.mounter); err != nil </span><span class="cov8" title="1">{
                retErr = status.Errorf(codes.Internal, "could not resize volume %q (%q):  %v", volumeID, devicePath, err)
                klog.Errorf("%v, will continue checking whether the volume has been resized", retErr)
        }</span>

        <span class="cov8" title="1">if runtime.GOOS == "windows" &amp;&amp; d.enableWindowsHostProcess </span><span class="cov0" title="0">{
                // in windows host process mode, this driver could get the volume size from the volume path
                devicePath = volumePath
        }</span>
        <span class="cov8" title="1">gotBlockSizeBytes, err := getBlockSizeBytes(devicePath, d.mounter)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("could not get size of block volume at path %s: %v", devicePath, err))
        }</span>
        <span class="cov8" title="1">gotBlockGiB := volumehelper.RoundUpGiB(gotBlockSizeBytes)
        if gotBlockGiB &lt; requestGiB </span><span class="cov8" title="1">{
                if retErr != nil </span><span class="cov8" title="1">{
                        return nil, retErr
                }</span>
                // Because size was rounded up, getting more size than requested will be a success.
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "resize requested for %v, but after resizing volume size was %v", requestGiB, gotBlockGiB)</span>
        }

        <span class="cov8" title="1">klog.V(2).Infof("NodeExpandVolume succeeded on resizing volume %v to %v", volumeID, gotBlockSizeBytes)

        isOperationSucceeded = true
        return &amp;csi.NodeExpandVolumeResponse{
                CapacityBytes: gotBlockSizeBytes,
        }, nil</span>
}

// ensureMountPoint: create mount point if not exists
// return &lt;true, nil&gt; if it's already a mounted point otherwise return &lt;false, nil&gt;
func (d *Driver) ensureMountPoint(target string) (bool, error) <span class="cov8" title="1">{
        notMnt, err := d.mounter.IsLikelyNotMountPoint(target)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov8" title="1">{
                if azureutils.IsCorruptedDir(target) </span><span class="cov0" title="0">{
                        notMnt = false
                        klog.Warningf("detected corrupted mount for targetPath [%s]", target)
                }</span> else<span class="cov8" title="1"> {
                        return !notMnt, err
                }</span>
        }

        <span class="cov8" title="1">if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                // Check all the mountpoints in case IsLikelyNotMountPoint
                // cannot handle --bind mount
                mountList, err := d.mounter.List()
                if err != nil </span><span class="cov0" title="0">{
                        return !notMnt, err
                }</span>

                <span class="cov8" title="1">targetAbs, err := filepath.Abs(target)
                if err != nil </span><span class="cov0" title="0">{
                        return !notMnt, err
                }</span>

                <span class="cov8" title="1">for _, mountPoint := range mountList </span><span class="cov8" title="1">{
                        if mountPoint.Path == targetAbs </span><span class="cov0" title="0">{
                                notMnt = false
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if !notMnt </span><span class="cov8" title="1">{
                // testing original mount point, make sure the mount link is valid
                _, err := os.ReadDir(target)
                if err == nil </span><span class="cov8" title="1">{
                        klog.V(2).Infof("already mounted to target %s", target)
                        return !notMnt, nil
                }</span>
                // mount link is invalid, now unmount and remount later
                <span class="cov0" title="0">klog.Warningf("ReadDir %s failed with %v, unmount this directory", target, err)
                if err := d.mounter.Unmount(target); err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("Unmount directory %s failed with %v", target, err)
                        return !notMnt, err
                }</span>
                <span class="cov0" title="0">notMnt = true
                return !notMnt, err</span>
        }

        <span class="cov8" title="1">if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                // in windows, we will use mklink to mount, will MkdirAll in Mount func
                if err := volumehelper.MakeDir(target); err != nil </span><span class="cov8" title="1">{
                        klog.Errorf("mkdir failed on target: %s (%v)", target, err)
                        return !notMnt, err
                }</span>
        }

        <span class="cov8" title="1">return !notMnt, nil</span>
}

func (d *Driver) formatAndMount(source, target, fstype string, options []string) error <span class="cov8" title="1">{
        return formatAndMount(source, target, fstype, options, d.mounter)
}</span>

func (d *Driver) getDevicePathWithLUN(lunStr string) (string, error) <span class="cov8" title="1">{
        lun, err := azureutils.GetDiskLUN(lunStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">scsiHostRescan(d.ioHandler, d.mounter)

        newDevicePath := ""
        err = wait.PollImmediate(1*time.Second, 2*time.Minute, func() (bool, error) </span><span class="cov8" title="1">{
                var err error
                if newDevicePath, err = findDiskByLun(int(lun), d.ioHandler, d.mounter); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("azureDisk - findDiskByLun(%v) failed with error(%s)", lun, err)
                }</span>

                // did we find it?
                <span class="cov8" title="1">if newDevicePath != "" </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
                // wait until timeout
                <span class="cov0" title="0">return false, nil</span>
        })
        <span class="cov8" title="1">if err == nil &amp;&amp; newDevicePath == "" </span><span class="cov0" title="0">{
                err = fmt.Errorf("azureDisk - findDiskByLun(%v) failed within timeout", lun)
        }</span>
        <span class="cov8" title="1">return newDevicePath, err</span>
}

func (d *Driver) ensureBlockTargetFile(target string) error <span class="cov8" title="1">{
        // Since the block device target path is file, its parent directory should be ensured to be valid.
        parentDir := filepath.Dir(target)
        if _, err := d.ensureMountPoint(parentDir); err != nil </span><span class="cov8" title="1">{
                return status.Errorf(codes.Internal, "could not mount target %q: %v", parentDir, err)
        }</span>
        // Create the mount point as a file since bind mount device node requires it to be a file
        <span class="cov8" title="1">klog.V(2).Infof("ensureBlockTargetFile [block]: making target file %s", target)
        err := volumehelper.MakeFile(target)
        if err != nil </span><span class="cov0" title="0">{
                if removeErr := os.Remove(target); removeErr != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "could not remove mount target %q: %v", target, removeErr)
                }</span>
                <span class="cov0" title="0">return status.Errorf(codes.Internal, "could not create file %q: %v", target, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func collectMountOptions(fsType string, mntFlags []string) []string <span class="cov8" title="1">{
        var options []string
        options = append(options, mntFlags...)

        // By default, xfs does not allow mounting of two volumes with the same filesystem uuid.
        // Force ignore this uuid to be able to mount volume + its clone / restored snapshot on the same node.
        if fsType == "xfs" </span><span class="cov0" title="0">{
                options = append(options, "nouuid")
        }</span>
        <span class="cov8" title="1">return options</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2023 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        "k8s.io/klog/v2"
)

func InitOtelTracing() (*otlptrace.Exporter, error) <span class="cov0" title="0">{
        // Setup OTLP exporter
        ctx := context.Background()
        exporter, err := otlptracegrpc.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create the OTLP exporter: %w", err)
        }</span>

        // Resource will auto populate spans with common attributes
        <span class="cov0" title="0">resource, err := resource.New(ctx,
                resource.WithFromEnv(), // pull attributes from OTEL_RESOURCE_ATTRIBUTES and OTEL_SERVICE_NAME environment variables
                resource.WithProcess(),
                resource.WithOS(),
                resource.WithContainer(),
                resource.WithHost(),
        )
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "Failed to create the OTLP resource, spans will lack some metadata")
        }</span>

        // Create a trace provider with the exporter.
        // Use propagator and sampler defined in environment variables.
        <span class="cov0" title="0">traceProvider := trace.NewTracerProvider(trace.WithBatcher(exporter), trace.WithResource(resource))

        // Register the trace provider as global.
        otel.SetTracerProvider(traceProvider)

        return exporter, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import "sync"

// lockMap used to lock on entries
type lockMap struct {
        sync.Mutex
        mutexMap map[string]*sync.Mutex
}

// NewLockMap returns a new lock map
func newLockMap() *lockMap <span class="cov8" title="1">{
        return &amp;lockMap{
                mutexMap: make(map[string]*sync.Mutex),
        }
}</span>

// LockEntry acquires a lock associated with the specific entry
func (lm *lockMap) LockEntry(entry string) <span class="cov8" title="1">{
        lm.Lock()
        // check if entry does not exists, then add entry
        mutex, exists := lm.mutexMap[entry]
        if !exists </span><span class="cov8" title="1">{
                mutex = &amp;sync.Mutex{}
                lm.mutexMap[entry] = mutex
        }</span>
        <span class="cov8" title="1">lm.Unlock()
        mutex.Lock()</span>
}

// UnlockEntry release the lock associated with the specific entry
func (lm *lockMap) UnlockEntry(entry string) <span class="cov8" title="1">{
        lm.Lock()
        defer lm.Unlock()

        mutex, exists := lm.mutexMap[entry]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">mutex.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azuredisk

import (
        "fmt"
        "runtime"
        "strings"

        "sigs.k8s.io/yaml"
)

// These are set during build time via -ldflags
var (
        driverVersion = "N/A"
        gitCommit     = "N/A"
        buildDate     = "N/A"
        topologyKey   = "N/A"
)

// VersionInfo holds the version information of the driver
type VersionInfo struct {
        DriverName    string `json:"Driver Name"`
        DriverVersion string `json:"Driver Version"`
        GitCommit     string `json:"Git Commit"`
        BuildDate     string `json:"Build Date"`
        GoVersion     string `json:"Go Version"`
        Compiler      string `json:"Compiler"`
        Platform      string `json:"Platform"`
        TopologyKey   string `json:"Topology Key"`
}

// GetVersion returns the version information of the driver
func GetVersion(driverName string) VersionInfo <span class="cov8" title="1">{
        return VersionInfo{
                DriverName:    driverName,
                DriverVersion: driverVersion,
                GitCommit:     gitCommit,
                BuildDate:     buildDate,
                GoVersion:     runtime.Version(),
                Compiler:      runtime.Compiler,
                Platform:      fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
                TopologyKey:   topologyKey,
        }
}</span>

// GetVersionYAML returns the version information of the driver
// in YAML format
func GetVersionYAML(driverName string) (string, error) <span class="cov8" title="1">{
        info := GetVersion(driverName)
        marshalled, err := yaml.Marshal(&amp;info)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(marshalled)), nil</span>
}

// GetUserAgent returns user agent of the driver
func GetUserAgent(driverName, customUserAgent, userAgentSuffix string) string <span class="cov8" title="1">{
        customUserAgent = strings.TrimSpace(customUserAgent)
        userAgent := customUserAgent
        if customUserAgent == "" </span><span class="cov8" title="1">{
                userAgent = fmt.Sprintf("%s/%s", driverName, driverVersion)
        }</span>

        <span class="cov8" title="1">userAgentSuffix = strings.TrimSpace(userAgentSuffix)
        if userAgentSuffix != "" </span><span class="cov8" title="1">{
                userAgent = userAgent + " " + userAgentSuffix
        }</span>
        <span class="cov8" title="1">return userAgent</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package hooks

import (
        "context"
        "errors"
        "fmt"
        "os"

        v1 "k8s.io/api/core/v1"
        storagev1 "k8s.io/api/storage/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/klog/v2"
        "k8s.io/utils/ptr"
)

/*
When a node is terminated, persistent workflows using Azure disk volumes can take 6+ minutes to start up again.
This happens when a volume is not cleanly unmounted, which causes the Attach/Detach controller (in kube-controller-manager)
to wait for 6 minutes before issuing a force detach and allowing the volume to be attached to another node.

This PreStop lifecycle hook aims to ensure that before the node (and the CSI driver node pod running on it) is shut down,
all VolumeAttachment objects associated with that node are removed, thereby indicating that all volumes have been successfully unmounted and detached.

No unnecessary delay is added to the termination workflow, as the PreStop hook logic is only executed when the node is being drained
(thus preventing delays in termination where the node pod is killed due to a rolling restart, or during driver upgrades, but the workload pods are expected to be running).
If the PreStop hook hangs during its execution, the driver node pod will be forcefully terminated after terminationGracePeriodSeconds, defined in the pod spec.
*/

const clusterAutoscalerTaint = "ToBeDeletedByClusterAutoscaler"
const v1KarpenterTaint = "karpenter.sh/disrupted"
const v1beta1KarpenterTaint = "karpenter.sh/disruption"

// drainTaints includes taints used by K8s or autoscalers that signify node draining or pod eviction.
var drainTaints = map[string]struct{}{
        v1.TaintNodeUnschedulable: {}, // Kubernetes common eviction taint (kubectl drain)
        clusterAutoscalerTaint:    {},
        v1KarpenterTaint:          {},
        v1beta1KarpenterTaint:     {},
}

func PreStop(clientset kubernetes.Interface) error <span class="cov8" title="1">{
        klog.V(2).Info("PreStop: executing PreStop lifecycle hook")

        nodeName := os.Getenv("KUBE_NODE_NAME")
        if nodeName == "" </span><span class="cov8" title="1">{
                return errors.New("PreStop: KUBE_NODE_NAME missing")
        }</span>

        <span class="cov0" title="0">node, err := fetchNode(clientset, nodeName)
        switch </span>{
        case k8serrors.IsNotFound(err):<span class="cov0" title="0">
                klog.V(2).Infof("PreStop: node(%s) does not exist - assuming this is a termination event, checking for remaining VolumeAttachments", nodeName)</span>
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case !isNodeBeingDrained(node):<span class="cov0" title="0">
                klog.V(2).Infof("PreStop: node(%s) is not being drained, skipping VolumeAttachments check node", nodeName)
                return nil</span>
        default:<span class="cov0" title="0">
                klog.V(2).Infof("PreStop: node(%s) is being drained, checking for remaining VolumeAttachments", nodeName)</span>
        }

        <span class="cov0" title="0">return waitForVolumeAttachments(clientset, nodeName)</span>
}

func fetchNode(clientset kubernetes.Interface, nodeName string) (*v1.Node, error) <span class="cov0" title="0">{
        node, err := clientset.CoreV1().Nodes().Get(context.Background(), nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetchNode: failed to retrieve node information: %w", err)
        }</span>
        <span class="cov0" title="0">return node, nil</span>
}

// isNodeBeingDrained returns true if node resource has a known drain/eviction taint.
func isNodeBeingDrained(node *v1.Node) bool <span class="cov8" title="1">{
        for _, taint := range node.Spec.Taints </span><span class="cov8" title="1">{
                if _, isDrainTaint := drainTaints[taint.Key]; isDrainTaint </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func waitForVolumeAttachments(clientset kubernetes.Interface, nodeName string) error <span class="cov0" title="0">{
        allAttachmentsDeleted := make(chan struct{})

        factory := informers.NewSharedInformerFactory(clientset, 0)
        informer := factory.Storage().V1().VolumeAttachments().Informer()

        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                DeleteFunc: func(obj interface{}) </span><span class="cov0" title="0">{
                        klog.V(2).Infof("DeleteFunc: VolumeAttachment deleted node %s", nodeName)
                        va, ok := obj.(*storagev1.VolumeAttachment)
                        if !ok </span><span class="cov0" title="0">{
                                klog.Errorf("UpdateFunc: error asserting object as type VolumeAttachment obj %s", va)
                        }</span>
                        <span class="cov0" title="0">if va.Spec.NodeName == nodeName </span><span class="cov0" title="0">{
                                if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("checkVolumeAttachments failed: %v", err)
                                }</span>
                        }
                },
                UpdateFunc: func(_, newObj interface{}) <span class="cov0" title="0">{
                        klog.V(2).Infof("UpdateFunc: VolumeAttachment updated node %s", nodeName)
                        va, ok := newObj.(*storagev1.VolumeAttachment)
                        if !ok </span><span class="cov0" title="0">{
                                klog.Errorf("UpdateFunc: error asserting object as type VolumeAttachment obj %s", va)
                        }</span>
                        <span class="cov0" title="0">if va.Spec.NodeName == nodeName </span><span class="cov0" title="0">{
                                if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("checkVolumeAttachments failed: %v", err)
                                }</span>
                        }
                },
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add event handler to VolumeAttachment informer: %w", err)
        }</span>

        <span class="cov0" title="0">go informer.Run(allAttachmentsDeleted)

        if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("checkVolumeAttachments failed: %v", err)
        }</span>

        <span class="cov0" title="0">&lt;-allAttachmentsDeleted
        klog.V(2).Info("waitForVolumeAttachments: finished waiting for VolumeAttachments to be deleted. preStopHook completed")
        return nil</span>
}

func checkVolumeAttachments(clientset kubernetes.Interface, nodeName string, allAttachmentsDeleted chan struct{}) error <span class="cov0" title="0">{
        allAttachments, err := clientset.StorageV1().VolumeAttachments().List(context.Background(), metav1.ListOptions{TimeoutSeconds: ptr.To(int64(2))})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("checkVolumeAttachments: failed to list VolumeAttachments: %w", err)
        }</span>
        <span class="cov0" title="0">klog.V(2).Infof("volumeAttachments count: %d, nodeName: %s", len(allAttachments.Items), nodeName)

        for _, attachment := range allAttachments.Items </span><span class="cov0" title="0">{
                if attachment.Spec.NodeName == nodeName </span><span class="cov0" title="0">{
                        klog.V(2).Infof("isVolumeAttachmentEmpty: not ready to exit, found VolumeAttachment %v node %s", attachment, nodeName)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">close(allAttachmentsDeleted)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "flag"
        "fmt"
        "net"
        "net/http"
        "os"
        "runtime"
        "strings"

        "k8s.io/component-base/metrics/legacyregistry"
        "k8s.io/klog/v2"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azuredisk"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azurediskplugin/hooks"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/azureutils"
)

func init() <span class="cov8" title="1">{
        klog.InitFlags(nil)
        driverOptions.AddFlags().VisitAll(func(f *flag.Flag) </span><span class="cov8" title="1">{
                flag.CommandLine.Var(f.Value, f.Name, f.Usage)
        }</span>)
}

var (
        version        = flag.Bool("version", false, "Print the version and exit.")
        metricsAddress = flag.String("metrics-address", "", "export the metrics")
        preStopHook    = flag.Bool("pre-stop-hook", false, "enable pre-stop hook")
        driverOptions  azuredisk.DriverOptions
)

// exit is a separate function to handle program termination
var exit = func(code int) <span class="cov0" title="0">{
        os.Exit(code)
}</span>

func main() <span class="cov8" title="1">{
        flag.Parse()
        if *version </span><span class="cov8" title="1">{
                info, err := azuredisk.GetVersionYAML(driverOptions.DriverName)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Fatalln(err)
                }</span>
                <span class="cov8" title="1">fmt.Println(info)</span> // nolint
        } else<span class="cov0" title="0"> if *preStopHook </span><span class="cov0" title="0">{
                handlePreStopHook(driverOptions.Kubeconfig)
        }</span> else<span class="cov0" title="0"> {
                exportMetrics()
                handle()
        }</span>
        <span class="cov8" title="1">exit(0)</span>
}

func handlePreStopHook(kubeconfig string) <span class="cov0" title="0">{
        kubeClient, err := azureutils.GetKubeClient(kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("failed to get kube client: %v", err)
        }</span> else<span class="cov0" title="0"> {
                if err := hooks.PreStop(kubeClient); err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("execute PreStop lifecycle hook failed with error: %v", err)
                        klog.FlushAndExit(klog.ExitFlushTimeout, 1)
                }</span>
        }
        <span class="cov0" title="0">klog.FlushAndExit(klog.ExitFlushTimeout, 0)</span>
}

func handle() <span class="cov0" title="0">{
        runtime.GOMAXPROCS(int(driverOptions.GoMaxProcs))
        klog.Infof("Sys info: NumCPU: %v MAXPROC: %v", runtime.NumCPU(), runtime.GOMAXPROCS(0))

        driver := azuredisk.NewDriver(&amp;driverOptions)
        if driver == nil </span><span class="cov0" title="0">{
                klog.Fatalln("Failed to initialize azuredisk CSI Driver")
        }</span>
        <span class="cov0" title="0">if err := driver.Run(context.Background()); err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to run azuredisk CSI Driver: %v", err)
        }</span>
}

func exportMetrics() <span class="cov0" title="0">{
        if *metricsAddress == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l, err := net.Listen("tcp", *metricsAddress)
        if err != nil </span><span class="cov0" title="0">{
                klog.Warningf("failed to get listener for metrics endpoint: %v", err)
                return
        }</span>
        <span class="cov0" title="0">serve(context.Background(), l, serveMetrics)</span>
}

func serve(_ context.Context, l net.Listener, serveFunc func(net.Listener) error) <span class="cov0" title="0">{
        path := l.Addr().String()
        klog.V(2).Infof("set up prometheus server on %v", path)
        go func() </span><span class="cov0" title="0">{
                defer l.Close()
                if err := serveFunc(l); err != nil </span><span class="cov0" title="0">{
                        klog.Fatalf("serve failure(%v), address(%v)", err, path)
                }</span>
        }()
}

func serveMetrics(l net.Listener) error <span class="cov0" title="0">{
        m := http.NewServeMux()
        m.Handle("/metrics", legacyregistry.Handler()) //nolint, because azure cloud provider uses legacyregistry currently
        return trapClosedConnErr(http.Serve(l, m))
}</span>

func trapClosedConnErr(err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if strings.Contains(err.Error(), "use of closed network connection") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azureutils

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/container-storage-interface/spec/lib/go/csi"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/uuid"
        clientset "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/klog/v2"
        api "k8s.io/kubernetes/pkg/apis/core"
        "k8s.io/mount-utils"
        "k8s.io/utils/ptr"
        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/filewatcher"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
        "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
        "sigs.k8s.io/cloud-provider-azure/pkg/azclient/configloader"
        azure "sigs.k8s.io/cloud-provider-azure/pkg/provider"
        azureconfig "sigs.k8s.io/cloud-provider-azure/pkg/provider/config"
)

const (
        azurePublicCloud                          = "AZUREPUBLICCLOUD"
        azureStackCloud                           = "AZURESTACKCLOUD"
        azurePublicCloudDefaultStorageAccountType = armcompute.DiskStorageAccountTypesStandardSSDLRS
        azureStackCloudDefaultStorageAccountType  = armcompute.DiskStorageAccountTypesStandardLRS
        defaultAzureDataDiskCachingMode           = v1.AzureDataDiskCachingReadOnly
        // default IOPS Caps &amp; Throughput Cap (MBps) per https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disks-ultra-ssd
        // see https://docs.microsoft.com/en-us/rest/api/compute/disks/createorupdate#uri-parameters
        diskNameMinLength         = 1
        diskNameMaxLength         = 80
        diskNameGenerateMaxLength = 76 // maxLength = 80 - (4 for ".vhd") = 76
        MaxPathLengthWindows      = 260
)

var (
        // see https://docs.microsoft.com/en-us/rest/api/compute/disks/createorupdate#create-a-managed-disk-by-copying-a-snapshot.
        diskSnapshotPath      = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/snapshots/%s"
        diskSnapshotPathRE    = regexp.MustCompile(`(?i).*/subscriptions/(?:.*)/resourceGroups/(?:.*)/providers/Microsoft.Compute/snapshots/(.+)`)
        lunPathRE             = regexp.MustCompile(`/dev(?:.*)/disk/azure/scsi(?:.*)/lun(.+)`)
        supportedCachingModes = sets.NewString(
                string(api.AzureDataDiskCachingNone),
                string(api.AzureDataDiskCachingReadOnly),
                string(api.AzureDataDiskCachingReadWrite),
        )

        // volumeCaps represents how the volume could be accessed.
        volumeCaps = []*csi.VolumeCapability_AccessMode{
                {Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER},
                {Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_READER_ONLY},
                {Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_SINGLE_WRITER},
                {Mode: csi.VolumeCapability_AccessMode_SINGLE_NODE_MULTI_WRITER},
                {Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY},
                {Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_SINGLE_WRITER},
                {Mode: csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER},
        }
)

type ManagedDiskParameters struct {
        AccountType             string
        CachingMode             v1.AzureDataDiskCachingMode
        DeviceSettings          map[string]string
        DiskAccessID            string
        DiskEncryptionSetID     string
        DiskEncryptionType      string
        DiskIOPSReadWrite       string
        DiskMBPSReadWrite       string
        DiskName                string
        EnableBursting          *bool
        PerformancePlus         *bool
        FsType                  string
        Location                string
        LogicalSectorSize       int
        MaxShares               int
        NetworkAccessPolicy     string
        PublicNetworkAccess     string
        PerfProfile             string
        SubscriptionID          string
        ResourceGroup           string
        Tags                    map[string]string
        UserAgent               string
        VolumeContext           map[string]string
        WriteAcceleratorEnabled string
        Zoned                   string
}

func GetCachingMode(attributes map[string]string) (armcompute.CachingTypes, error) <span class="cov8" title="1">{
        var (
                cachingMode v1.AzureDataDiskCachingMode
                err         error
        )

        for k, v := range attributes </span><span class="cov8" title="1">{
                if strings.EqualFold(k, consts.CachingModeField) </span><span class="cov8" title="1">{
                        cachingMode = v1.AzureDataDiskCachingMode(v)
                        break</span>
                }
        }

        <span class="cov8" title="1">cachingMode, err = NormalizeCachingMode(cachingMode)
        return armcompute.CachingTypes(cachingMode), err</span>
}

// GetAttachDiskInitialDelay gttachDiskInitialDelay from attributes
// return -1 if not found
func GetAttachDiskInitialDelay(attributes map[string]string) int <span class="cov8" title="1">{
        for k, v := range attributes </span><span class="cov8" title="1">{
                switch strings.ToLower(k) </span>{
                case consts.AttachDiskInitialDelayField:<span class="cov8" title="1">
                        if v, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                                return v
                        }</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}

// GetCloudProviderFromClient get Azure Cloud Provider
func GetCloudProviderFromClient(ctx context.Context, kubeClient clientset.Interface, secretName, secretNamespace, userAgent string,
        allowEmptyCloudConfig bool, enableTrafficMgr bool, enableMinimumRetryAfter bool, trafficMgrPort int64) (*azure.Cloud, error) <span class="cov8" title="1">{
        var config *azureconfig.Config
        var fromSecret bool
        var err error
        az := &amp;azure.Cloud{}
        if kubeClient != nil </span><span class="cov8" title="1">{
                klog.V(2).Infof("reading cloud config from secret %s/%s", secretNamespace, secretName)
                config, err = configloader.Load[azureconfig.Config](ctx, &amp;configloader.K8sSecretLoaderConfig{
                        K8sSecretConfig: configloader.K8sSecretConfig{
                                SecretName:      secretName,
                                SecretNamespace: secretNamespace,
                                CloudConfigKey:  "cloud-config",
                        },
                        KubeClient: kubeClient,
                }, nil)
                if err != nil </span><span class="cov8" title="1">{
                        klog.V(2).Infof("InitializeCloudFromSecret: failed to get cloud config from secret %s/%s: %v", secretNamespace, secretName, err)
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; config != nil </span><span class="cov0" title="0">{
                        fromSecret = true
                }</span>
                <span class="cov8" title="1">az.KubeClient = kubeClient</span>
        }

        <span class="cov8" title="1">if config == nil </span><span class="cov8" title="1">{
                klog.V(2).Infof("could not read cloud config from secret %s/%s", secretNamespace, secretName)
                credFile, ok := os.LookupEnv(consts.DefaultAzureCredentialFileEnv)
                if ok &amp;&amp; strings.TrimSpace(credFile) != "" </span><span class="cov8" title="1">{
                        klog.V(2).Infof("%s env var set as %v", consts.DefaultAzureCredentialFileEnv, credFile)
                }</span> else<span class="cov8" title="1"> {
                        if util.IsWindowsOS() </span><span class="cov0" title="0">{
                                credFile = consts.DefaultCredFilePathWindows
                        }</span> else<span class="cov8" title="1"> {
                                credFile = consts.DefaultCredFilePathLinux
                        }</span>
                        <span class="cov8" title="1">klog.V(2).Infof("use default %s env var: %v", consts.DefaultAzureCredentialFileEnv, credFile)</span>
                }
                <span class="cov8" title="1">config, err = configloader.Load[azureconfig.Config](ctx, nil, &amp;configloader.FileLoaderConfig{FilePath: credFile})
                if err != nil </span><span class="cov8" title="1">{
                        klog.Warningf("load azure config from file(%s) failed with %v", credFile, err)
                }</span>
        }

        <span class="cov8" title="1">if config == nil </span><span class="cov8" title="1">{
                if allowEmptyCloudConfig </span><span class="cov8" title="1">{
                        klog.V(2).Infof("no cloud config provided, error: %v, driver will run without cloud config", err)
                }</span> else<span class="cov8" title="1"> {
                        return nil, fmt.Errorf("no cloud config provided, error: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Location may be either upper case with spaces (e.g. "East US") or lower case without spaces (e.g. "eastus")
                // Kubernetes does not allow whitespaces in label values, e.g. for topology keys
                // ensure Kubernetes compatible format for Location by enforcing lowercase-no-space format
                config.Location = strings.ToLower(strings.ReplaceAll(config.Location, " ", ""))

                // disable disk related rate limit
                /* todo: reconfigure rate limit
                config.DiskRateLimit = &amp;ratelimit.CloudProviderRateLimitConfig{
                        CloudProviderRateLimit: false,
                }
                config.SnapshotRateLimit = &amp;ratelimit.CloudProviderRateLimitConfig{
                        CloudProviderRateLimit: false,
                }
                */
                config.UserAgent = userAgent
                if enableTrafficMgr &amp;&amp; trafficMgrPort &gt; 0 </span><span class="cov0" title="0">{
                        trafficMgrAddr := fmt.Sprintf("http://localhost:%d/", trafficMgrPort)
                        klog.V(2).Infof("set ResourceManagerEndpoint as %s", trafficMgrAddr)
                        config.ResourceManagerEndpoint = trafficMgrAddr
                }</span>
                // these environment variables are injected by workload identity webhook
                <span class="cov8" title="1">if tenantID := os.Getenv("AZURE_TENANT_ID"); tenantID != "" </span><span class="cov0" title="0">{
                        config.TenantID = tenantID
                }</span>
                <span class="cov8" title="1">if clientID := os.Getenv("AZURE_CLIENT_ID"); clientID != "" </span><span class="cov0" title="0">{
                        config.AADClientID = clientID
                }</span>
                <span class="cov8" title="1">if federatedTokenFile := os.Getenv("AZURE_FEDERATED_TOKEN_FILE"); federatedTokenFile != "" </span><span class="cov0" title="0">{
                        config.AADFederatedTokenFile = federatedTokenFile
                        config.UseFederatedWorkloadIdentityExtension = true
                }</span>
                <span class="cov8" title="1">if len(config.AADClientCertPath) &gt; 0 </span><span class="cov0" title="0">{
                        // Watch the certificate for changes; if the certificate changes, the pod will be restarted
                        err = filewatcher.WatchFileForChanges(config.AADClientCertPath)
                        klog.Warningf("Failed to watch certificate file for changes: %v", err)
                }</span>
                <span class="cov8" title="1">if enableMinimumRetryAfter </span><span class="cov0" title="0">{
                        config.EnableMinimumRetryAfter = enableMinimumRetryAfter
                }</span>
                <span class="cov8" title="1">if err = az.InitializeCloudFromConfig(ctx, config, fromSecret, false); err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("InitializeCloudFromConfig failed with error: %v", err)
                }</span>
        }

        // reassign kubeClient
        <span class="cov8" title="1">if kubeClient != nil &amp;&amp; az.KubeClient == nil </span><span class="cov0" title="0">{
                az.KubeClient = kubeClient
        }</span>
        <span class="cov8" title="1">return az, nil</span>
}

func GetKubeClient(kubeconfig string) (clientset.Interface, error) <span class="cov8" title="1">{
        config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return clientset.NewForConfig(config)</span>
}

// GetDiskLUN : deviceInfo could be a LUN number or a device path, e.g. /dev/disk/azure/scsi1/lun2
func GetDiskLUN(deviceInfo string) (int32, error) <span class="cov8" title="1">{
        var diskLUN string
        if len(deviceInfo) &lt;= 2 </span><span class="cov8" title="1">{
                diskLUN = deviceInfo
        }</span> else<span class="cov8" title="1"> {
                // extract the LUN num from a device path
                matches := lunPathRE.FindStringSubmatch(deviceInfo)
                if len(matches) == 2 </span><span class="cov8" title="1">{
                        diskLUN = matches[1]
                }</span> else<span class="cov8" title="1"> {
                        return -1, fmt.Errorf("cannot parse deviceInfo: %s", deviceInfo)
                }</span>
        }

        <span class="cov8" title="1">lun, err := strconv.Atoi(diskLUN)
        if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>
        <span class="cov8" title="1">return int32(lun), nil</span>
}

// Disk name must begin with a letter or number, end with a letter, number or underscore,
// and may contain only letters, numbers, underscores, periods, or hyphens.
// See https://docs.microsoft.com/en-us/rest/api/compute/disks/createorupdate#uri-parameters
//
// Snapshot name must begin with a letter or number, end with a letter, number or underscore,
// and may contain only letters, numbers, underscores, periods, or hyphens.
// See https://docs.microsoft.com/en-us/rest/api/compute/snapshots/createorupdate#uri-parameters
//
// Since the naming rule of disk is same with snapshot's, here we use the same function to handle disks and snapshots.
func CreateValidDiskName(volumeName string) string <span class="cov8" title="1">{
        diskName := volumeName
        if len(diskName) &gt; diskNameMaxLength </span><span class="cov8" title="1">{
                diskName = diskName[0:diskNameMaxLength]
                klog.Warningf("since the maximum volume name length is %d, so it is truncated as (%q)", diskNameMaxLength, diskName)
        }</span>
        <span class="cov8" title="1">if !checkDiskName(diskName) || len(diskName) &lt; diskNameMinLength </span><span class="cov8" title="1">{
                // todo: get cluster name
                diskName = GenerateVolumeName("pvc-disk", string(uuid.NewUUID()), diskNameGenerateMaxLength)
                klog.Warningf("the requested volume name (%q) is invalid, so it is regenerated as (%q)", volumeName, diskName)
        }</span>

        <span class="cov8" title="1">return diskName</span>
}

func GetFStype(attributes map[string]string) string <span class="cov8" title="1">{
        for k, v := range attributes </span><span class="cov8" title="1">{
                switch strings.ToLower(k) </span>{
                case consts.FsTypeField:<span class="cov8" title="1">
                        return strings.ToLower(v)</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func GetMaxShares(attributes map[string]string) (int, error) <span class="cov8" title="1">{
        for k, v := range attributes </span><span class="cov8" title="1">{
                switch strings.ToLower(k) </span>{
                case consts.MaxSharesField:<span class="cov8" title="1">
                        maxShares, err := strconv.Atoi(v)
                        if err != nil </span><span class="cov8" title="1">{
                                return 0, fmt.Errorf("parse %s failed with error: %v", v, err)
                        }</span>
                        <span class="cov8" title="1">if maxShares &lt; 1 </span><span class="cov8" title="1">{
                                return 0, fmt.Errorf("parse %s returned with invalid value: %d", v, maxShares)
                        }</span>
                        <span class="cov8" title="1">return maxShares, nil</span>
                }
        }
        <span class="cov8" title="1">return 1, nil</span> // disk is not shared
}

// GetInfoFromURI get subscriptionID, resourceGroup, diskName from diskURI
// examples:
// diskURI: /subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.Compute/disks/{disk-name}
// snapshotURI: /subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.Compute/snapshots/{snapshot-name}
func GetInfoFromURI(diskURI string) (string, string, string, error) <span class="cov8" title="1">{
        parts := strings.Split(diskURI, "/")
        if len(parts) != 9 </span><span class="cov8" title="1">{
                return "", "", "", fmt.Errorf("invalid URI: %s", diskURI)
        }</span>
        <span class="cov8" title="1">return parts[2], parts[4], parts[8], nil</span>
}

func GetValidCreationData(subscriptionID, resourceGroup, sourceResourceID, sourceType string) (armcompute.CreationData, error) <span class="cov8" title="1">{
        if sourceResourceID == "" </span><span class="cov8" title="1">{
                return armcompute.CreationData{
                        CreateOption: to.Ptr(armcompute.DiskCreateOptionEmpty),
                }, nil
        }</span>

        <span class="cov8" title="1">switch sourceType </span>{
        case consts.SourceSnapshot:<span class="cov8" title="1">
                if match := diskSnapshotPathRE.FindString(sourceResourceID); match == "" </span><span class="cov8" title="1">{
                        sourceResourceID = fmt.Sprintf(diskSnapshotPath, subscriptionID, resourceGroup, sourceResourceID)
                }</span>

        case consts.SourceVolume:<span class="cov8" title="1">
                if match := consts.ManagedDiskPathRE.FindString(sourceResourceID); match == "" </span><span class="cov8" title="1">{
                        sourceResourceID = fmt.Sprintf(consts.ManagedDiskPath, subscriptionID, resourceGroup, sourceResourceID)
                }</span>
        default:<span class="cov8" title="1">
                return armcompute.CreationData{
                        CreateOption: to.Ptr(armcompute.DiskCreateOptionEmpty),
                }, nil</span>
        }

        <span class="cov8" title="1">splits := strings.Split(sourceResourceID, "/")
        if len(splits) &gt; 9 </span><span class="cov8" title="1">{
                if sourceType == consts.SourceSnapshot </span><span class="cov8" title="1">{
                        return armcompute.CreationData{}, fmt.Errorf("sourceResourceID(%s) is invalid, correct format: %s", sourceResourceID, diskSnapshotPathRE)
                }</span>

                <span class="cov8" title="1">return armcompute.CreationData{}, fmt.Errorf("sourceResourceID(%s) is invalid, correct format: %s", sourceResourceID, consts.ManagedDiskPathRE)</span>
        }
        <span class="cov8" title="1">return armcompute.CreationData{
                CreateOption:     to.Ptr(armcompute.DiskCreateOptionCopy),
                SourceResourceID: &amp;sourceResourceID,
        }, nil</span>
}

func IsCorruptedDir(dir string) bool <span class="cov8" title="1">{
        _, pathErr := mount.PathExists(dir)
        return pathErr != nil &amp;&amp; mount.IsCorruptedMnt(pathErr)
}</span>

// IsARMResourceID check whether resourceID is an ARM ResourceID
func IsARMResourceID(resourceID string) bool <span class="cov8" title="1">{
        id := strings.ToLower(resourceID)
        return strings.Contains(id, "/subscriptions/")
}</span>

// IsAzureStackCloud decides whether the driver is running on Azure Stack Cloud.
func IsAzureStackCloud(cloud string, disableAzureStackCloud bool) bool <span class="cov8" title="1">{
        return !disableAzureStackCloud &amp;&amp; strings.EqualFold(cloud, azureStackCloud)
}</span>

// IsValidAvailabilityZone returns true if the zone is in format of &lt;region&gt;-&lt;zone-id&gt;.
func IsValidAvailabilityZone(zone, region string) bool <span class="cov8" title="1">{
        if region == "" </span><span class="cov8" title="1">{
                index := strings.Index(zone, "-")
                return index &gt; 0 &amp;&amp; index &lt; len(zone)-1
        }</span>
        <span class="cov8" title="1">return strings.HasPrefix(zone, fmt.Sprintf("%s-", region))</span>
}

// GetRegionFromAvailabilityZone returns region from availability zone if it's in format of &lt;region&gt;-&lt;zone-id&gt;
func GetRegionFromAvailabilityZone(zone string) string <span class="cov8" title="1">{
        parts := strings.Split(zone, "-")
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return parts[0]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// IsValidVolumeCapabilities checks whether the volume capabilities are valid
func IsValidVolumeCapabilities(volCaps []*csi.VolumeCapability, maxShares int) error <span class="cov8" title="1">{
        if ok := IsValidAccessModes(volCaps); !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid access mode: %v", volCaps)
        }</span>
        <span class="cov8" title="1">for _, c := range volCaps </span><span class="cov8" title="1">{
                blockVolume := c.GetBlock()
                mountVolume := c.GetMount()
                accessMode := c.GetAccessMode().GetMode()

                if blockVolume == nil &amp;&amp; mountVolume == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("blockVolume and mountVolume are both nil")
                }</span>

                <span class="cov8" title="1">if blockVolume != nil &amp;&amp; mountVolume != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("blockVolume and mountVolume are both not nil")
                }</span>
                <span class="cov8" title="1">if mountVolume != nil &amp;&amp; (accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER ||
                        accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY ||
                        accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_SINGLE_WRITER) </span><span class="cov8" title="1">{
                        return fmt.Errorf("mountVolume is not supported for access mode: %s", accessMode.String())
                }</span>
                <span class="cov8" title="1">if maxShares &lt; 2 &amp;&amp; (accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER ||
                        accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY ||
                        accessMode == csi.VolumeCapability_AccessMode_MULTI_NODE_SINGLE_WRITER) </span><span class="cov8" title="1">{
                        return fmt.Errorf("access mode: %s is not supported for non-shared disk", accessMode.String())
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func IsValidAccessModes(volCaps []*csi.VolumeCapability) bool <span class="cov8" title="1">{
        hasSupport := func(capability *csi.VolumeCapability) bool </span><span class="cov8" title="1">{
                for _, c := range volumeCaps </span><span class="cov8" title="1">{
                        if c.GetMode() == capability.AccessMode.GetMode() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">foundAll := true
        for _, c := range volCaps </span><span class="cov8" title="1">{
                if !hasSupport(c) </span><span class="cov8" title="1">{
                        foundAll = false
                }</span>
        }
        <span class="cov8" title="1">return foundAll</span>
}

func NormalizeCachingMode(cachingMode v1.AzureDataDiskCachingMode) (v1.AzureDataDiskCachingMode, error) <span class="cov8" title="1">{
        if cachingMode == "" </span><span class="cov8" title="1">{
                return defaultAzureDataDiskCachingMode, nil
        }</span>

        <span class="cov8" title="1">if !supportedCachingModes.Has(string(cachingMode)) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("azureDisk - %s is not supported cachingmode. Supported values are %s", cachingMode, supportedCachingModes.List())
        }</span>

        <span class="cov8" title="1">return cachingMode, nil</span>
}

func NormalizeNetworkAccessPolicy(networkAccessPolicy string) (armcompute.NetworkAccessPolicy, error) <span class="cov8" title="1">{
        if networkAccessPolicy == "" </span><span class="cov8" title="1">{
                return armcompute.NetworkAccessPolicy(networkAccessPolicy), nil
        }</span>
        <span class="cov8" title="1">policy := armcompute.NetworkAccessPolicy(networkAccessPolicy)
        for _, s := range armcompute.PossibleNetworkAccessPolicyValues() </span><span class="cov8" title="1">{
                if policy == s </span><span class="cov8" title="1">{
                        return policy, nil
                }</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("azureDisk - %s is not supported NetworkAccessPolicy. Supported values are %s", networkAccessPolicy, armcompute.PossibleNetworkAccessPolicyValues())</span>
}

func NormalizePublicNetworkAccess(publicNetworkAccess string) (armcompute.PublicNetworkAccess, error) <span class="cov8" title="1">{
        if publicNetworkAccess == "" </span><span class="cov8" title="1">{
                return armcompute.PublicNetworkAccess(publicNetworkAccess), nil
        }</span>
        <span class="cov8" title="1">access := armcompute.PublicNetworkAccess(publicNetworkAccess)
        for _, s := range armcompute.PossiblePublicNetworkAccessValues() </span><span class="cov8" title="1">{
                if access == s </span><span class="cov8" title="1">{
                        return access, nil
                }</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("azureDisk - %s is not supported PublicNetworkAccess. Supported values are %s", publicNetworkAccess, armcompute.PossiblePublicNetworkAccessValues())</span>
}

func NormalizeStorageAccountType(storageAccountType, cloud string, disableAzureStackCloud bool) (armcompute.DiskStorageAccountTypes, error) <span class="cov8" title="1">{
        if storageAccountType == "" </span><span class="cov8" title="1">{
                if IsAzureStackCloud(cloud, disableAzureStackCloud) </span><span class="cov8" title="1">{
                        return azureStackCloudDefaultStorageAccountType, nil
                }</span>
                <span class="cov8" title="1">return azurePublicCloudDefaultStorageAccountType, nil</span>
        }

        <span class="cov8" title="1">sku := armcompute.DiskStorageAccountTypes(storageAccountType)
        supportedSkuNames := armcompute.PossibleDiskStorageAccountTypesValues()
        if IsAzureStackCloud(cloud, disableAzureStackCloud) </span><span class="cov8" title="1">{
                supportedSkuNames = []armcompute.DiskStorageAccountTypes{armcompute.DiskStorageAccountTypesStandardLRS, armcompute.DiskStorageAccountTypesPremiumLRS}
        }</span>
        <span class="cov8" title="1">for _, s := range supportedSkuNames </span><span class="cov8" title="1">{
                if sku == s </span><span class="cov8" title="1">{
                        return sku, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("azureDisk - %s is not supported sku/storageaccounttype. Supported values are %s", storageAccountType, supportedSkuNames)</span>
}

func ValidateDiskEncryptionType(encryptionType string) error <span class="cov8" title="1">{
        if encryptionType == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">supportedTypes := armcompute.PossibleEncryptionTypeValues()
        for _, s := range supportedTypes </span><span class="cov8" title="1">{
                if encryptionType == string(s) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("DiskEncryptionType(%s) is not supported", encryptionType)</span>
}

func ValidateDataAccessAuthMode(dataAccessAuthMode string) error <span class="cov8" title="1">{
        if dataAccessAuthMode == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">supportedModes := armcompute.PossibleDataAccessAuthModeValues()
        for _, s := range supportedModes </span><span class="cov8" title="1">{
                if dataAccessAuthMode == string(s) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("dataAccessAuthMode(%s) is not supported", dataAccessAuthMode)</span>
}

func ParseDiskParameters(parameters map[string]string) (ManagedDiskParameters, error) <span class="cov8" title="1">{
        var err error
        if parameters == nil </span><span class="cov8" title="1">{
                parameters = make(map[string]string)
        }</span>

        <span class="cov8" title="1">diskParams := ManagedDiskParameters{
                DeviceSettings: make(map[string]string),
                Tags:           make(map[string]string),
                VolumeContext:  parameters,
        }
        var originTags, tagValueDelimiter string
        for k, v := range parameters </span><span class="cov8" title="1">{
                switch strings.ToLower(k) </span>{
                case consts.SkuNameField:<span class="cov8" title="1">
                        diskParams.AccountType = v</span>
                case consts.LocationField:<span class="cov8" title="1">
                        diskParams.Location = v</span>
                case consts.StorageAccountTypeField:<span class="cov0" title="0">
                        diskParams.AccountType = v</span>
                case consts.CachingModeField:<span class="cov8" title="1">
                        diskParams.CachingMode = v1.AzureDataDiskCachingMode(v)</span>
                case consts.SubscriptionIDField:<span class="cov0" title="0">
                        diskParams.SubscriptionID = v</span>
                case consts.ResourceGroupField:<span class="cov8" title="1">
                        diskParams.ResourceGroup = v</span>
                case consts.DiskIOPSReadWriteField:<span class="cov8" title="1">
                        if _, err = strconv.Atoi(v); err != nil </span><span class="cov8" title="1">{
                                return diskParams, fmt.Errorf("parse %s:%s failed with error: %v", consts.DiskIOPSReadWriteField, v, err)
                        }</span>
                        <span class="cov8" title="1">diskParams.DiskIOPSReadWrite = v</span>
                case consts.DiskMBPSReadWriteField:<span class="cov8" title="1">
                        if _, err = strconv.Atoi(v); err != nil </span><span class="cov8" title="1">{
                                return diskParams, fmt.Errorf("parse %s:%s failed with error: %v", consts.DiskMBPSReadWriteField, v, err)
                        }</span>
                        <span class="cov8" title="1">diskParams.DiskMBPSReadWrite = v</span>
                case consts.LogicalSectorSizeField:<span class="cov8" title="1">
                        diskParams.LogicalSectorSize, err = strconv.Atoi(v)
                        if err != nil </span><span class="cov8" title="1">{
                                return diskParams, fmt.Errorf("parse %s failed with error: %v", v, err)
                        }</span>
                case consts.DiskNameField:<span class="cov8" title="1">
                        diskParams.DiskName = v</span>
                case consts.DesIDField:<span class="cov8" title="1">
                        diskParams.DiskEncryptionSetID = v</span>
                case consts.DiskEncryptionTypeField:<span class="cov0" title="0">
                        diskParams.DiskEncryptionType = v</span>
                case consts.TagsField:<span class="cov8" title="1">
                        originTags = v</span>
                case azure.WriteAcceleratorEnabled:<span class="cov8" title="1">
                        diskParams.WriteAcceleratorEnabled = v</span>
                case consts.MaxSharesField:<span class="cov8" title="1">
                        diskParams.MaxShares, err = strconv.Atoi(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return diskParams, fmt.Errorf("parse %s failed with error: %v", v, err)
                        }</span>
                        <span class="cov8" title="1">if diskParams.MaxShares &lt; 1 </span><span class="cov0" title="0">{
                                return diskParams, fmt.Errorf("parse %s returned with invalid value: %d", v, diskParams.MaxShares)
                        }</span>
                case consts.PvcNameKey:<span class="cov8" title="1">
                        diskParams.Tags[consts.PvcNameTag] = v</span>
                case consts.PvcNamespaceKey:<span class="cov8" title="1">
                        diskParams.Tags[consts.PvcNamespaceTag] = v</span>
                case consts.PvNameKey:<span class="cov8" title="1">
                        diskParams.Tags[consts.PvNameTag] = v</span>
                case consts.FsTypeField:<span class="cov8" title="1">
                        diskParams.FsType = strings.ToLower(v)</span>
                case consts.KindField:<span class="cov8" title="1">
                        // fix csi migration issue: https://github.com/kubernetes/kubernetes/issues/103433
                        diskParams.VolumeContext[consts.KindField] = string(v1.AzureManagedDisk)</span>
                case consts.PerfProfileField:<span class="cov8" title="1">
                        if !optimization.IsValidPerfProfile(v) </span><span class="cov0" title="0">{
                                return diskParams, fmt.Errorf("perf profile %s is not supported, supported tuning modes are none and basic", v)
                        }</span>
                        <span class="cov8" title="1">diskParams.PerfProfile = v</span>
                case consts.NetworkAccessPolicyField:<span class="cov8" title="1">
                        diskParams.NetworkAccessPolicy = v</span>
                case consts.PublicNetworkAccessField:<span class="cov0" title="0">
                        diskParams.PublicNetworkAccess = v</span>
                case consts.DiskAccessIDField:<span class="cov8" title="1">
                        diskParams.DiskAccessID = v</span>
                case consts.EnableBurstingField:<span class="cov8" title="1">
                        if strings.EqualFold(v, consts.TrueValue) </span><span class="cov8" title="1">{
                                diskParams.EnableBursting = ptr.To(true)
                        }</span>
                case consts.UserAgentField:<span class="cov8" title="1">
                        diskParams.UserAgent = v</span>
                case consts.EnableAsyncAttachField:<span class="cov8" title="1"></span>
                        // no op, only for backward compatibility
                case consts.ZonedField:<span class="cov8" title="1"></span>
                        // no op, only for backward compatibility with in-tree driver
                case consts.PerformancePlusField:<span class="cov0" title="0">
                        value, err := strconv.ParseBool(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return diskParams, fmt.Errorf("invalid %s: %s in storage class", consts.PerformancePlusField, v)
                        }</span>
                        <span class="cov0" title="0">diskParams.PerformancePlus = &amp;value</span>
                case consts.AttachDiskInitialDelayField:<span class="cov8" title="1">
                        if _, err = strconv.Atoi(v); err != nil </span><span class="cov8" title="1">{
                                return diskParams, fmt.Errorf("parse %s failed with error: %v", v, err)
                        }</span>
                case consts.TagValueDelimiterField:<span class="cov0" title="0">
                        tagValueDelimiter = v</span>
                default:<span class="cov8" title="1">
                        // accept all device settings params
                        // device settings need to start with azureconstants.DeviceSettingsKeyPrefix
                        if deviceSettings, err := optimization.GetDeviceSettingFromAttribute(k); err == nil </span><span class="cov0" title="0">{
                                diskParams.DeviceSettings[filepath.Join(consts.DummyBlockDevicePathLinux, deviceSettings)] = v
                        }</span> else<span class="cov8" title="1"> {
                                return diskParams, fmt.Errorf("invalid parameter %s in storage class", k)
                        }</span>
                }
        }
        <span class="cov8" title="1">customTagsMap, err := util.ConvertTagsToMap(originTags, tagValueDelimiter)
        if err != nil </span><span class="cov0" title="0">{
                return diskParams, err
        }</span>
        <span class="cov8" title="1">for k, v := range customTagsMap </span><span class="cov8" title="1">{
                diskParams.Tags[k] = v
        }</span>

        <span class="cov8" title="1">if strings.EqualFold(diskParams.AccountType, string(armcompute.DiskStorageAccountTypesPremiumV2LRS)) </span><span class="cov8" title="1">{
                if diskParams.CachingMode != "" &amp;&amp; !strings.EqualFold(string(diskParams.CachingMode), string(v1.AzureDataDiskCachingNone)) </span><span class="cov8" title="1">{
                        return diskParams, fmt.Errorf("cachingMode %s is not supported for %s", diskParams.CachingMode, armcompute.DiskStorageAccountTypesPremiumV2LRS)
                }</span>
        }

        // support disk name with $ in it, e.g. ${pvc.metadata.name}
        <span class="cov8" title="1">if strings.Contains(diskParams.DiskName, "$") </span><span class="cov0" title="0">{
                if pvcName, ok := diskParams.Tags[consts.PvcNameTag]; ok &amp;&amp; pvcName != "" </span><span class="cov0" title="0">{
                        diskParams.DiskName = strings.ReplaceAll(diskParams.DiskName, "${pvc.metadata.name}", pvcName)
                }</span>
                <span class="cov0" title="0">if pvcNamespace, ok := diskParams.Tags[consts.PvcNamespaceTag]; ok &amp;&amp; pvcNamespace != "" </span><span class="cov0" title="0">{
                        diskParams.DiskName = strings.ReplaceAll(diskParams.DiskName, "${pvc.metadata.namespace}", pvcNamespace)
                }</span>
                <span class="cov0" title="0">if pvName, ok := diskParams.Tags[consts.PvNameTag]; ok &amp;&amp; pvName != "" </span><span class="cov0" title="0">{
                        diskParams.DiskName = strings.ReplaceAll(diskParams.DiskName, "${pv.metadata.name}", pvName)
                }</span>
        }

        <span class="cov8" title="1">return diskParams, nil</span>
}

// PickAvailabilityZone selects 1 zone given topology requirement.
// if not found or topology requirement is not zone format, empty string is returned.
func PickAvailabilityZone(requirement *csi.TopologyRequirement, region, topologyKey string) string <span class="cov8" title="1">{
        if requirement == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, topology := range requirement.GetPreferred() </span><span class="cov8" title="1">{
                if zone, exists := topology.GetSegments()[consts.WellKnownTopologyKey]; exists </span><span class="cov8" title="1">{
                        if IsValidAvailabilityZone(zone, region) </span><span class="cov8" title="1">{
                                return zone
                        }</span>
                }
                <span class="cov8" title="1">if zone, exists := topology.GetSegments()[topologyKey]; exists </span><span class="cov8" title="1">{
                        if IsValidAvailabilityZone(zone, region) </span><span class="cov8" title="1">{
                                return zone
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, topology := range requirement.GetRequisite() </span><span class="cov8" title="1">{
                if zone, exists := topology.GetSegments()[consts.WellKnownTopologyKey]; exists </span><span class="cov8" title="1">{
                        if IsValidAvailabilityZone(zone, region) </span><span class="cov8" title="1">{
                                return zone
                        }</span>
                }
                <span class="cov8" title="1">if zone, exists := topology.GetSegments()[topologyKey]; exists </span><span class="cov8" title="1">{
                        if IsValidAvailabilityZone(zone, region) </span><span class="cov8" title="1">{
                                return zone
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func checkDiskName(diskName string) bool <span class="cov8" title="1">{
        length := len(diskName)

        for i, v := range diskName </span><span class="cov8" title="1">{
                if !(unicode.IsLetter(v) || unicode.IsDigit(v) || v == '_' || v == '.' || v == '-') ||
                        (i == 0 &amp;&amp; !(unicode.IsLetter(v) || unicode.IsDigit(v))) ||
                        (i == length-1 &amp;&amp; !(unicode.IsLetter(v) || unicode.IsDigit(v) || v == '_')) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// InsertProperties: insert disk properties to map
func InsertDiskProperties(disk *armcompute.Disk, publishConext map[string]string) <span class="cov8" title="1">{
        if disk == nil || publishConext == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if disk.SKU != nil </span><span class="cov8" title="1">{
                publishConext[consts.SkuNameField] = string(*disk.SKU.Name)
        }</span>
        <span class="cov8" title="1">prop := disk.Properties
        if prop != nil </span><span class="cov8" title="1">{
                publishConext[consts.NetworkAccessPolicyField] = string(*prop.NetworkAccessPolicy)
                if prop.DiskIOPSReadWrite != nil </span><span class="cov8" title="1">{
                        publishConext[consts.DiskIOPSReadWriteField] = strconv.Itoa(int(*prop.DiskIOPSReadWrite))
                }</span>
                <span class="cov8" title="1">if prop.DiskMBpsReadWrite != nil </span><span class="cov8" title="1">{
                        publishConext[consts.DiskMBPSReadWriteField] = strconv.Itoa(int(*prop.DiskMBpsReadWrite))
                }</span>
                <span class="cov8" title="1">if prop.CreationData != nil &amp;&amp; prop.CreationData.LogicalSectorSize != nil </span><span class="cov8" title="1">{
                        publishConext[consts.LogicalSectorSizeField] = strconv.Itoa(int(*prop.CreationData.LogicalSectorSize))
                }</span>
                <span class="cov8" title="1">if prop.Encryption != nil &amp;&amp;
                        prop.Encryption.DiskEncryptionSetID != nil </span><span class="cov8" title="1">{
                        publishConext[consts.DesIDField] = *prop.Encryption.DiskEncryptionSetID
                }</span>
                <span class="cov8" title="1">if prop.MaxShares != nil </span><span class="cov8" title="1">{
                        publishConext[consts.MaxSharesField] = strconv.Itoa(int(*prop.MaxShares))
                }</span>
        }
}

func SleepIfThrottled(err error, defaultSleepSec int) <span class="cov8" title="1">{
        if err != nil &amp;&amp; IsThrottlingError(err) </span><span class="cov8" title="1">{
                retryAfter := getRetryAfterSeconds(err)
                if retryAfter == 0 </span><span class="cov8" title="1">{
                        retryAfter = defaultSleepSec
                }</span>
                <span class="cov8" title="1">klog.Warningf("sleep %d more seconds, waiting for throttling complete", retryAfter)
                time.Sleep(time.Duration(retryAfter) * time.Second)</span>
        }
}

func IsThrottlingError(err error) bool <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                errMsg := strings.ToLower(err.Error())
                return strings.Contains(errMsg, strings.ToLower(consts.TooManyRequests)) || strings.Contains(errMsg, consts.ClientThrottled)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// getRetryAfterSeconds returns the number of seconds to wait from the error message
func getRetryAfterSeconds(err error) int <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">re := regexp.MustCompile(`RetryAfter: (\d+)s`)
        match := re.FindStringSubmatch(err.Error())
        if len(match) &gt; 1 </span><span class="cov8" title="1">{
                if retryAfter, err := strconv.Atoi(match[1]); err == nil </span><span class="cov8" title="1">{
                        if retryAfter &gt; consts.MaxThrottlingSleepSec </span><span class="cov8" title="1">{
                                return consts.MaxThrottlingSleepSec
                        }</span>
                        <span class="cov8" title="1">return retryAfter</span>
                }
        }
        <span class="cov8" title="1">return 0</span>
}

// SetKeyValueInMap set key/value pair in map
// key in the map is case insensitive, if key already exists, overwrite existing value
func SetKeyValueInMap(m map[string]string, key, value string) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for k := range m </span><span class="cov8" title="1">{
                if strings.EqualFold(k, key) </span><span class="cov8" title="1">{
                        m[k] = value
                        return
                }</span>
        }
        <span class="cov8" title="1">m[key] = value</span>
}

// GenerateVolumeName returns a PV name with clusterName prefix. The function
// should be used to generate a name of GCE PD or Cinder volume. It basically
// adds "&lt;clusterName&gt;-dynamic-" before the PV name, making sure the resulting
// string fits given length and cuts "dynamic" if not.
func GenerateVolumeName(clusterName, pvName string, maxLength int) string <span class="cov8" title="1">{
        prefix := clusterName + "-dynamic"
        pvLen := len(pvName)
        // cut the "&lt;clusterName&gt;-dynamic" to fit full pvName into maxLength
        // +1 for the '-' dash
        if pvLen+1+len(prefix) &gt; maxLength </span><span class="cov8" title="1">{
                prefix = prefix[:maxLength-pvLen-1]
        }</span>
        <span class="cov8" title="1">return prefix + "-" + pvName</span>
}

// RemoveOptionIfExists removes the given option from the list of options
// return the new list and a boolean indicating whether the option was found.
func RemoveOptionIfExists(options []string, removeOption string) ([]string, bool) <span class="cov8" title="1">{
        for i, option := range options </span><span class="cov8" title="1">{
                if option == removeOption </span><span class="cov8" title="1">{
                        return append(options[:i], options[i+1:]...), true
                }</span>
        }
        <span class="cov8" title="1">return options, false</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azureutils

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/container-storage-interface/spec/lib/go/csi"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
        "k8s.io/klog/v2"
        volumehelper "sigs.k8s.io/azuredisk-csi-driver/pkg/util"
)

func GenerateCSISnapshot(sourceVolumeID string, snapshot *armcompute.Snapshot) (*csi.Snapshot, error) <span class="cov8" title="1">{
        if snapshot == nil || snapshot.Properties == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("snapshot property is nil")
        }</span>

        <span class="cov8" title="1">if snapshot.Properties.TimeCreated == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TimeCreated of snapshot property is nil")
        }</span>

        <span class="cov8" title="1">if snapshot.Properties.DiskSizeGB == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("diskSizeGB of snapshot property is nil")
        }</span>

        <span class="cov8" title="1">ready, _ := isCSISnapshotReady(*snapshot.Properties.ProvisioningState)
        if sourceVolumeID == "" </span><span class="cov8" title="1">{
                sourceVolumeID = GetSourceVolumeID(snapshot)
        }</span>

        // The provisioningState represents the state of resource provisioning which indicates whether the snapshot
        // is created successfully or not. However the snapshot may not be ready to use immediately after creation.
        // We need to check the CompletionPercent if exists to determine if the snapshot is ready to use.
        // This is needed because of Premium V2 disks &amp; Ultra disks, which take some time to be ready to use after creation.
        // In case of Premium V1 disks, the snapshot is ready to use immediately after creation and so we won't have that
        // completionPercent field in the properties. Hence we will treat it 100% if CompletionPercent is nil.
        <span class="cov8" title="1">if ready </span><span class="cov8" title="1">{
                completionPercent := float32(0.0)
                if snapshot.Properties.CompletionPercent == nil </span><span class="cov8" title="1">{
                        // If CompletionPercent is nil, it means the snapshot is complete
                        completionPercent = float32(100.0)
                }</span> else<span class="cov8" title="1"> {
                        completionPercent = *snapshot.Properties.CompletionPercent
                }</span>

                <span class="cov8" title="1">if completionPercent &lt; float32(100.0) </span><span class="cov8" title="1">{
                        klog.V(2).Infof("snapshot(%s) in progress, completion percent: %f", *snapshot.Name, completionPercent)
                        ready = false
                }</span>
        }

        <span class="cov8" title="1">return &amp;csi.Snapshot{
                SizeBytes:      volumehelper.GiBToBytes(int64(*snapshot.Properties.DiskSizeGB)),
                SnapshotId:     *snapshot.ID,
                SourceVolumeId: sourceVolumeID,
                CreationTime:   timestamppb.New(*snapshot.Properties.TimeCreated),
                ReadyToUse:     ready,
        }, nil</span>
}

// There are 4 scenarios for listing snapshots.
// 1. StartingToken is null, and MaxEntries is null. Return all snapshots from zero.
// 2. StartingToken is null, and MaxEntries is not null. Return `MaxEntries` snapshots from zero.
// 3. StartingToken is not null, and MaxEntries is null. Return all snapshots from `StartingToken`.
// 4. StartingToken is not null, and MaxEntries is not null. Return `MaxEntries` snapshots from `StartingToken`.
func GetEntriesAndNextToken(req *csi.ListSnapshotsRequest, snapshots []*armcompute.Snapshot) (*csi.ListSnapshotsResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, "request is nil")
        }</span>

        <span class="cov8" title="1">var err error
        start := 0
        if req.StartingToken != "" </span><span class="cov8" title="1">{
                start, err = strconv.Atoi(req.StartingToken)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Aborted, "ListSnapshots starting token(%s) parsing with error: %v", req.StartingToken, err)

                }</span>
                <span class="cov8" title="1">if start &gt;= len(snapshots) </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Aborted, "ListSnapshots starting token(%d) is greater than total number of snapshots", start)
                }</span>
                <span class="cov8" title="1">if start &lt; 0 </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Aborted, "ListSnapshots starting token(%d) can not be negative", start)
                }</span>
        }

        <span class="cov8" title="1">maxEntries := len(snapshots) - start
        if req.MaxEntries &gt; 0 &amp;&amp; int(req.MaxEntries) &lt; maxEntries </span><span class="cov8" title="1">{
                maxEntries = int(req.MaxEntries)
        }</span>
        <span class="cov8" title="1">entries := []*csi.ListSnapshotsResponse_Entry{}
        for count := 0; start &lt; len(snapshots) &amp;&amp; count &lt; maxEntries; start++ </span><span class="cov8" title="1">{
                if (req.SourceVolumeId != "" &amp;&amp; req.SourceVolumeId == GetSourceVolumeID(snapshots[start])) || req.SourceVolumeId == "" </span><span class="cov8" title="1">{
                        csiSnapshot, err := GenerateCSISnapshot(req.SourceVolumeId, snapshots[start])
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to generate snapshot entry: %v", err)
                        }</span>
                        <span class="cov8" title="1">entries = append(entries, &amp;csi.ListSnapshotsResponse_Entry{Snapshot: csiSnapshot})
                        count++</span>
                }
        }

        <span class="cov8" title="1">nextToken := len(snapshots)
        if start &lt; len(snapshots) </span><span class="cov8" title="1">{
                nextToken = start
        }</span>

        <span class="cov8" title="1">listSnapshotResp := &amp;csi.ListSnapshotsResponse{
                Entries:   entries,
                NextToken: strconv.Itoa(nextToken),
        }

        return listSnapshotResp, nil</span>
}

func GetSnapshotNameFromURI(snapshotURI string) (string, error) <span class="cov8" title="1">{
        matches := diskSnapshotPathRE.FindStringSubmatch(snapshotURI)
        if len(matches) != 2 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not get snapshot name from %s, correct format: %s", snapshotURI, diskSnapshotPathRE)
        }</span>
        <span class="cov8" title="1">return matches[1], nil</span>
}

func GetSourceVolumeID(snapshot *armcompute.Snapshot) string <span class="cov8" title="1">{
        if snapshot != nil &amp;&amp;
                snapshot.Properties != nil &amp;&amp;
                snapshot.Properties.CreationData != nil &amp;&amp;
                snapshot.Properties.CreationData.SourceResourceID != nil </span><span class="cov8" title="1">{
                return *snapshot.Properties.CreationData.SourceResourceID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func isCSISnapshotReady(state string) (bool, error) <span class="cov8" title="1">{
        switch strings.ToLower(state) </span>{
        case "succeeded":<span class="cov8" title="1">
                return true, nil</span>
        default:<span class="cov8" title="1">
                return false, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azureutils

import (
        "fmt"
        "os"
)

type FakeHostUtil struct {
        pathIsDeviceResult map[string]struct {
                isDevice bool
                err      error
        }
}

// NewFakeHostUtil returns a FakeHostUtil object suitable for use in unit tests.
func NewFakeHostUtil() *FakeHostUtil <span class="cov8" title="1">{
        return &amp;FakeHostUtil{
                pathIsDeviceResult: make(map[string]struct {
                        isDevice bool
                        err      error
                }),
        }
}</span>

// PathIsDevice return whether the path references a block device.
func (f *FakeHostUtil) PathIsDevice(path string) (bool, error) <span class="cov8" title="1">{
        if result, ok := f.pathIsDeviceResult[path]; ok </span><span class="cov8" title="1">{
                return result.isDevice, result.err
        }</span>

        <span class="cov8" title="1">_, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, fmt.Errorf("path %q does not exist", path)
        }</span>

        <span class="cov8" title="1">return false, err</span>
}

// SetPathIsDeviceResult set the result of calling IsBlockDevicePath for the specified path.
func (f *FakeHostUtil) SetPathIsDeviceResult(path string, isDevice bool, err error) <span class="cov8" title="1">{
        result := struct {
                isDevice bool
                err      error
        }{isDevice, err}

        f.pathIsDeviceResult[path] = result
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azureutils

import (
        "fmt"
        "io/fs"
        "os"
        "strings"
        "time"
)

type fakeDirEntry struct {
        name string
}

type fakeFileInfo struct {
        name string
}

func (f fakeFileInfo) Name() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f fakeFileInfo) Size() int64 <span class="cov8" title="1">{
        return 0
}</span>

func (f fakeFileInfo) Mode() os.FileMode <span class="cov8" title="1">{
        return 777
}</span>

func (f fakeFileInfo) ModTime() time.Time <span class="cov8" title="1">{
        return time.Now()
}</span>
func (f fakeFileInfo) IsDir() bool <span class="cov8" title="1">{
        return false
}</span>

func (f fakeFileInfo) Sys() interface{} <span class="cov8" title="1">{
        return nil
}</span>

func (fd *fakeDirEntry) Type() fs.FileMode <span class="cov0" title="0">{
        return 777
}</span>

func (fd *fakeDirEntry) Info() (fs.FileInfo, error) <span class="cov8" title="1">{
        return fakeFileInfo{
                name: fd.name,
        }, nil
}</span>

func (fd *fakeDirEntry) Name() string <span class="cov8" title="1">{
        return fd.name
}</span>

func (fd *fakeDirEntry) IsDir() bool <span class="cov0" title="0">{
        return false
}</span>

var (
        lunStr    = "1"
        diskPath  = "4:0:0:" + lunStr
        devName   = "sdd"
        lunStr1   = "2"
        diskPath1 = "3:0:0:" + lunStr1
        devName1  = "sde"
)

type fakeIOHandler struct{}

func NewFakeIOHandler() IOHandler <span class="cov8" title="1">{
        return &amp;fakeIOHandler{}
}</span>

func (handler *fakeIOHandler) ReadDir(dirname string) ([]os.DirEntry, error) <span class="cov8" title="1">{
        switch dirname </span>{
        case "/sys/bus/scsi/devices":<span class="cov8" title="1">
                f1 := &amp;fakeDirEntry{
                        name: "3:0:0:1",
                }
                f2 := &amp;fakeDirEntry{
                        name: "4:0:0:0",
                }
                f3 := &amp;fakeDirEntry{
                        name: diskPath,
                }
                f4 := &amp;fakeDirEntry{
                        name: "host1",
                }
                f5 := &amp;fakeDirEntry{
                        name: "target2:0:0",
                }
                return []os.DirEntry{f1, f2, f3, f4, f5}, nil</span>
        case "/sys/bus/scsi/devices/" + diskPath + "/block":<span class="cov8" title="1">
                n := &amp;fakeDirEntry{
                        name: devName,
                }
                return []os.DirEntry{n}, nil</span>
        case "/sys/bus/scsi/devices/" + diskPath1 + "/block":<span class="cov8" title="1">
                n := &amp;fakeDirEntry{
                        name: devName1,
                }
                return []os.DirEntry{n}, nil</span>
        case "/sys/class/scsi_host/":<span class="cov8" title="1">
                n := &amp;fakeDirEntry{
                        name: "host0",
                }
                return []os.DirEntry{n}, nil</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("bad dir")</span>
}

func (handler *fakeIOHandler) WriteFile(_ string, _ []byte, _ os.FileMode) error <span class="cov8" title="1">{
        return nil
}</span>

func (handler *fakeIOHandler) Readlink(_ string) (string, error) <span class="cov8" title="1">{
        return "/dev/azure/disk/sda", nil
}</span>

func (handler *fakeIOHandler) ReadFile(filename string) ([]byte, error) <span class="cov8" title="1">{
        if strings.HasSuffix(filename, "vendor") </span><span class="cov8" title="1">{
                return []byte("Msft    \n"), nil
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(filename, "model") </span><span class="cov8" title="1">{
                return []byte("Virtual Disk \n"), nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("unknown file")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azureutils

import (
        "os"
)

type IOHandler interface {
        ReadDir(dirname string) ([]os.DirEntry, error)
        WriteFile(filename string, data []byte, perm os.FileMode) error
        Readlink(name string) (string, error)
        ReadFile(filename string) ([]byte, error)
}

type osIOHandler struct{}

func NewOSIOHandler() IOHandler <span class="cov8" title="1">{
        return &amp;osIOHandler{}
}</span>

func (handler *osIOHandler) ReadDir(dirname string) ([]os.DirEntry, error) <span class="cov8" title="1">{
        return os.ReadDir(dirname)
}</span>

func (handler *osIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov8" title="1">{
        return os.WriteFile(filename, data, perm)
}</span>

func (handler *osIOHandler) Readlink(name string) (string, error) <span class="cov8" title="1">{
        return os.Readlink(name)
}</span>

func (handler *osIOHandler) ReadFile(filename string) ([]byte, error) <span class="cov8" title="1">{
        return os.ReadFile(filename)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package csicommon

import (
        "github.com/container-storage-interface/spec/lib/go/csi"
        "k8s.io/klog/v2"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type CSIDriver struct {
        Name                    string
        NodeID                  string
        Version                 string
        VolumeAttachLimit       int64
        ReservedDataDiskSlotNum int64
        Cap                     []*csi.ControllerServiceCapability
        VC                      []*csi.VolumeCapability_AccessMode
        NSCap                   []*csi.NodeServiceCapability
}

// Creates a NewCSIDriver object. Assumes vendor version is equal to driver version &amp;
// does not support optional driver plugin info manifest field. Refer to CSI spec for more details.
func NewCSIDriver(name string, v string, nodeID string) *CSIDriver <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                klog.Errorf("Driver name missing")
                return nil
        }</span>

        <span class="cov8" title="1">if nodeID == "" </span><span class="cov8" title="1">{
                klog.Errorf("NodeID missing")
                return nil
        }</span>
        // TODO version format and validation
        <span class="cov8" title="1">if len(v) == 0 </span><span class="cov8" title="1">{
                klog.Errorf("Version argument missing, now skip it")
                //return nil
        }</span>

        <span class="cov8" title="1">driver := CSIDriver{
                Name:    name,
                Version: v,
                NodeID:  nodeID,
        }

        return &amp;driver</span>
}

func (d *CSIDriver) ValidateControllerServiceRequest(c csi.ControllerServiceCapability_RPC_Type) error <span class="cov8" title="1">{
        if c == csi.ControllerServiceCapability_RPC_UNKNOWN </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, cap := range d.Cap </span><span class="cov8" title="1">{
                if c == cap.GetRpc().GetType() </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return status.Error(codes.InvalidArgument, c.String())</span>
}

func (d *CSIDriver) AddControllerServiceCapabilities(cl []csi.ControllerServiceCapability_RPC_Type) <span class="cov8" title="1">{
        var csc []*csi.ControllerServiceCapability

        for _, c := range cl </span><span class="cov8" title="1">{
                klog.Infof("Enabling controller service capability: %v", c.String())
                csc = append(csc, NewControllerServiceCapability(c))
        }</span>

        <span class="cov8" title="1">d.Cap = csc</span>
}

func (d *CSIDriver) AddNodeServiceCapabilities(nl []csi.NodeServiceCapability_RPC_Type) <span class="cov8" title="1">{
        var nsc []*csi.NodeServiceCapability
        for _, n := range nl </span><span class="cov8" title="1">{
                klog.V(2).Infof("Enabling node service capability: %v", n.String())
                nsc = append(nsc, NewNodeServiceCapability(n))
        }</span>
        <span class="cov8" title="1">d.NSCap = nsc</span>
}

func (d *CSIDriver) AddVolumeCapabilityAccessModes(vc []csi.VolumeCapability_AccessMode_Mode) []*csi.VolumeCapability_AccessMode <span class="cov8" title="1">{
        var vca []*csi.VolumeCapability_AccessMode
        for _, c := range vc </span><span class="cov8" title="1">{
                klog.Infof("Enabling volume access mode: %v", c.String())
                vca = append(vca, NewVolumeCapabilityAccessMode(c))
        }</span>
        <span class="cov8" title="1">d.VC = vca
        return vca</span>
}

func (d *CSIDriver) GetVolumeCapabilityAccessModes() []*csi.VolumeCapability_AccessMode <span class="cov8" title="1">{
        return d.VC
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package csicommon

const (
        fakeCSIDriverName = "disk.csi.azure.com"
        fakeNodeID        = "fakeNodeID"
)

var (
        vendorVersion = "0.3.0"
)

func NewFakeCSIDriver() *CSIDriver <span class="cov8" title="1">{

        driver := NewCSIDriver(fakeCSIDriverName, vendorVersion, fakeNodeID)

        return driver
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package csicommon

import (
        "fmt"
        "net"
        "os"
        "runtime"
        "strings"

        "golang.org/x/net/context"
        "google.golang.org/grpc"
        "k8s.io/klog/v2"

        "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/kubernetes-csi/csi-lib-utils/protosanitizer"
)

func ParseEndpoint(ep string) (string, string, error) <span class="cov8" title="1">{
        if strings.HasPrefix(strings.ToLower(ep), "unix://") || strings.HasPrefix(strings.ToLower(ep), "tcp://") </span><span class="cov8" title="1">{
                s := strings.SplitN(ep, "://", 2)
                if s[1] != "" </span><span class="cov8" title="1">{
                        return s[0], s[1], nil
                }</span>
        }
        <span class="cov8" title="1">return "", "", fmt.Errorf("Invalid endpoint: %v", ep)</span>
}

func Listen(ctx context.Context, endpoint string) (net.Listener, error) <span class="cov8" title="1">{
        proto, addr, err := ParseEndpoint(endpoint)
        if err != nil </span><span class="cov8" title="1">{
                klog.Errorf("%v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if proto == "unix" </span><span class="cov8" title="1">{
                if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                        addr = "/" + addr
                }</span>
                <span class="cov8" title="1">if err := os.Remove(addr); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        klog.Errorf("Failed to remove %s, error: %v", addr, err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">listenConfig := net.ListenConfig{}
        listener, err := listenConfig.Listen(ctx, proto, addr)
        if err != nil </span><span class="cov8" title="1">{
                klog.Errorf("Failed to listen: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return listener, nil</span>
}

func NewVolumeCapabilityAccessMode(mode csi.VolumeCapability_AccessMode_Mode) *csi.VolumeCapability_AccessMode <span class="cov8" title="1">{
        return &amp;csi.VolumeCapability_AccessMode{Mode: mode}
}</span>

func NewControllerServiceCapability(c csi.ControllerServiceCapability_RPC_Type) *csi.ControllerServiceCapability <span class="cov8" title="1">{
        return &amp;csi.ControllerServiceCapability{
                Type: &amp;csi.ControllerServiceCapability_Rpc{
                        Rpc: &amp;csi.ControllerServiceCapability_RPC{
                                Type: c,
                        },
                },
        }
}</span>

func NewNodeServiceCapability(c csi.NodeServiceCapability_RPC_Type) *csi.NodeServiceCapability <span class="cov8" title="1">{
        return &amp;csi.NodeServiceCapability{
                Type: &amp;csi.NodeServiceCapability_Rpc{
                        Rpc: &amp;csi.NodeServiceCapability_RPC{
                                Type: c,
                        },
                },
        }
}</span>

func getLogLevel(method string) int32 <span class="cov8" title="1">{
        if method == "/csi.v1.Identity/Probe" ||
                method == "/csi.v1.Node/NodeGetCapabilities" ||
                method == "/csi.v1.Node/NodeGetVolumeStats" ||
                method == "/csi.v1.Controller/ListVolumes" </span><span class="cov8" title="1">{
                return 6
        }</span>
        <span class="cov8" title="1">return 2</span>
}

func LogGRPC(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        level := klog.Level(getLogLevel(info.FullMethod))
        klog.V(level).Infof("GRPC call: %s", info.FullMethod)
        klog.V(level).Infof("GRPC request: %s", protosanitizer.StripSecrets(req))

        resp, err := handler(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("GRPC error: %v", err)
        }</span> else<span class="cov8" title="1"> {
                klog.V(level).Infof("GRPC response: %s", protosanitizer.StripSecrets(resp))
        }</span>
        <span class="cov8" title="1">return resp, err</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package filewatcher

import (
        "os"
        "path/filepath"
        "sync"

        "github.com/fsnotify/fsnotify"
        "k8s.io/klog/v2"
)

// exit is a separate function to handle program termination
var exit = func(code int) <span class="cov0" title="0">{
        os.Exit(code)
}</span>

var watchCertificateFileOnce sync.Once

// resetWatchCertificateFileOnce resets the watchCertificateFileOnce variable. This is used for testing purposes.
func resetWatchCertificateFileOnce() <span class="cov8" title="1">{
        watchCertificateFileOnce = sync.Once{}
}</span>

// WatchFileForChanges watches the file, fileToWatch, for changes. If the file contents have changed, the pod this
// function is running on will be restarted.
func WatchFileForChanges(fileToWatch string) error <span class="cov8" title="1">{
        var err error

        // This starts only one occurrence of the file watcher, which watches the file, fileToWatch.
        watchCertificateFileOnce.Do(func() </span><span class="cov8" title="1">{
                klog.V(2).Infof("Starting the file change watcher on file, %s", fileToWatch)

                // Update the file path to watch in case this is a symlink
                fileToWatch, err = filepath.EvalSymlinks(fileToWatch)
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">klog.V(2).Infof("Watching file, %s", fileToWatch)

                // Start the file watcher to monitor file changes
                err = checkForFileChanges(fileToWatch)</span>
        })
        <span class="cov8" title="1">return err</span>
}

// checkForFileChanges starts a new file watcher. If the file is changed, the pod running this function will exit.
func checkForFileChanges(path string) error <span class="cov8" title="1">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case event, ok := &lt;-watcher.Events:<span class="cov8" title="1">
                                if ok &amp;&amp; (event.Has(fsnotify.Write) || event.Has(fsnotify.Chmod) || event.Has(fsnotify.Remove)) </span><span class="cov8" title="1">{
                                        klog.V(2).Infof("file, %s, was modified, exiting...", event.Name)
                                        exit(0)
                                }</span>
                        case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                                if ok </span><span class="cov0" title="0">{
                                        klog.Errorf("file watcher error: %v", err)
                                }</span>
                        }
                }
        }()

        <span class="cov8" title="1">return watcher.Add(path)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mounter

import (
        "fmt"
        "runtime"
        "strings"
        "time"

        "k8s.io/mount-utils"
        "k8s.io/utils/exec"
        testingexec "k8s.io/utils/exec/testing"
)

// FakeSafeMounter implements a mount.Interface interface suitable for use in unit tests.
type FakeSafeMounter struct {
        mount.FakeMounter
        testingexec.FakeExec
}

// NewFakeSafeMounter creates a mount.SafeFormatAndMount instance suitable for use in unit tests.
func NewFakeSafeMounter() (*mount.SafeFormatAndMount, error) <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return NewSafeMounter(true, true, true, 2, time.Duration(120)*time.Second)
        }</span>

        <span class="cov8" title="1">fakeSafeMounter := FakeSafeMounter{}
        fakeSafeMounter.ExactOrder = true

        return &amp;mount.SafeFormatAndMount{
                Interface: &amp;fakeSafeMounter,
                Exec:      &amp;fakeSafeMounter,
        }, nil</span>
}

// Mount overrides mount.FakeMounter.Mount.
func (f *FakeSafeMounter) Mount(source, target, _ string, _ []string) error <span class="cov8" title="1">{
        if strings.Contains(source, "error_mount") </span><span class="cov8" title="1">{
                return fmt.Errorf("fake Mount: source error")
        }</span> else<span class="cov8" title="1"> if strings.Contains(target, "error_mount") </span><span class="cov8" title="1">{
                return fmt.Errorf("fake Mount: target error")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MountSensitive overrides mount.FakeMounter.MountSensitive.
func (f *FakeSafeMounter) MountSensitive(source, target, _ string, _, _ []string) error <span class="cov8" title="1">{
        if strings.Contains(source, "error_mount_sens") </span><span class="cov8" title="1">{
                return fmt.Errorf("fake MountSensitive: source error")
        }</span> else<span class="cov8" title="1"> if strings.Contains(target, "error_mount_sens") </span><span class="cov8" title="1">{
                return fmt.Errorf("fake MountSensitive: target error")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsLikelyNotMountPoint overrides mount.FakeMounter.IsLikelyNotMountPoint.
func (f *FakeSafeMounter) IsLikelyNotMountPoint(file string) (bool, error) <span class="cov8" title="1">{
        if strings.Contains(file, "error_is_likely") </span><span class="cov8" title="1">{
                return false, fmt.Errorf("fake IsLikelyNotMountPoint: fake error")
        }</span>
        <span class="cov8" title="1">if strings.Contains(file, "false_is_likely") </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// IsMountPoint overrides mount.FakeMounter.IsMountPoint.
func (f *FakeSafeMounter) IsMountPoint(file string) (bool, error) <span class="cov0" title="0">{
        notMnt, err := f.IsLikelyNotMountPoint(file)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return !notMnt, nil</span>
}

// SetNextCommandOutputScripts sets the output scripts for the next sequence of command invocations.
func (f *FakeSafeMounter) SetNextCommandOutputScripts(scripts ...testingexec.FakeAction) <span class="cov8" title="1">{
        for _, script := range scripts </span><span class="cov8" title="1">{
                outputScripts := []testingexec.FakeAction{script}
                fakeCmdAction := func(cmd string, args ...string) exec.Cmd </span><span class="cov8" title="1">{
                        fakeCmd := &amp;testingexec.FakeCmd{}
                        fakeCmd.OutputScript = outputScripts
                        fakeCmd.CombinedOutputScript = outputScripts
                        fakeCmd.OutputCalls = 0

                        return testingexec.InitFakeCmd(fakeCmd, cmd, args...)
                }</span>

                <span class="cov8" title="1">f.CommandScript = append(f.CommandScript, fakeCmdAction)</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">//go:build linux || darwin
// +build linux darwin

/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mounter

import (
        "time"

        "k8s.io/mount-utils"
        utilexec "k8s.io/utils/exec"
)

func NewSafeMounter(_, _, _ bool, maxConcurrentFormat int, concurrentFormatTimeout time.Duration) (*mount.SafeFormatAndMount, error) <span class="cov8" title="1">{
        opt := mount.WithMaxConcurrentFormat(maxConcurrentFormat, concurrentFormatTimeout)
        return mount.NewSafeFormatAndMount(mount.New(""), utilexec.New(), opt), nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package optimization

import consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"

// This is the interface for DeviceHelper
type Interface interface {
        DiskSupportsPerfOptimization(diskPerfProfile, diskAccountType string) bool
        OptimizeDiskPerformance(nodeInfo *NodeInfo,
                devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string, deviceSettingsFromCtx map[string]string) error
}

// Compile-time check to ensure all Mounter DeviceHelper satisfy
// the DeviceHelper interface.
var _ Interface = &amp;DeviceHelper{blockDeviceRootPath: consts.BlockDeviceRootPathLinux}

func NewSafeDeviceHelper() *SafeDeviceHelper <span class="cov8" title="1">{
        return &amp;SafeDeviceHelper{
                Interface: &amp;DeviceHelper{blockDeviceRootPath: consts.BlockDeviceRootPathLinux},
        }
}</span>

// IdentityServer is the server API for Identity service.
type SafeDeviceHelper struct {
        Interface
}

func (dh *SafeDeviceHelper) DeviceSupportsPerfOptimization(diskPerfProfile, diskAccountType string) bool <span class="cov8" title="1">{
        return dh.Interface.DiskSupportsPerfOptimization(diskPerfProfile, diskAccountType)
}</span>

func (dh *SafeDeviceHelper) OptimizeDiskPerformance(nodeInfo *NodeInfo,
        devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string, deviceSettingsFromCtx map[string]string) error <span class="cov8" title="1">{
        return dh.Interface.OptimizeDiskPerformance(nodeInfo, devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettingsFromCtx)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package optimization

import (
        "fmt"
        "path/filepath"
        "strings"

        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
)

// IsValidPerfProfile Checks to see if perf profile passed is correct
// Right now we are only supporting basic profile
// Other advanced profiles to come later
func IsValidPerfProfile(profile string) bool <span class="cov8" title="1">{
        return isPerfTuningEnabled(profile) || strings.EqualFold(profile, consts.PerfProfileNone)
}</span>

// getDiskPerfAttributes gets the per tuning mode and profile set in attributes
func GetDiskPerfAttributes(attributes map[string]string) (profile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string, deviceSettings map[string]string, err error) <span class="cov8" title="1">{
        deviceSettings = make(map[string]string)
        perfProfilePresent := false
        for k, v := range attributes </span><span class="cov8" title="1">{
                key := strings.ToLower(k)
                switch strings.ToLower(k) </span>{
                case consts.PerfProfileField:<span class="cov8" title="1">
                        perfProfilePresent = true
                        profile = v</span>
                case consts.SkuNameField:<span class="cov8" title="1">
                        accountType = v</span>
                case consts.RequestedSizeGib:<span class="cov8" title="1">
                        diskSizeGibStr = v</span>
                case consts.DiskIOPSReadWriteField:<span class="cov8" title="1">
                        diskIopsStr = v</span>
                case consts.DiskMBPSReadWriteField:<span class="cov8" title="1">
                        diskBwMbpsStr = v</span>
                default:<span class="cov8" title="1">
                        if setting, err := GetDeviceSettingFromAttribute(key); err == nil </span><span class="cov8" title="1">{
                                deviceSettings[setting] = v
                        }</span>
                }
        }

        // If perfProfile was present in the volume attributes, use it
        <span class="cov8" title="1">if perfProfilePresent </span><span class="cov8" title="1">{
                // Make sure it's a valid perf profile
                if !IsValidPerfProfile(profile) </span><span class="cov8" title="1">{
                        return profile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettings, fmt.Errorf("Perf profile %s is invalid", profile)
                }</span>
        } else<span class="cov8" title="1"> {
                // if perfProfile parameter was not provided in the attributes
                // set it to 'None'. Which means no optimization will be done.
                profile = consts.PerfProfileNone
        }</span>

        <span class="cov8" title="1">return profile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettings, nil</span>
}

// isPerfTuningEnabled checks to see if perf tuning is enabled
func isPerfTuningEnabled(profile string) bool <span class="cov8" title="1">{
        switch strings.ToLower(profile) </span>{
        case consts.PerfProfileBasic:<span class="cov8" title="1">
                return true</span>
        case consts.PerfProfileAdvanced:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// accountSupportsPerfOptimization checks to see if account type supports perf optimization
func accountSupportsPerfOptimization(accountType string) bool <span class="cov8" title="1">{
        accountTypeLower := strings.ToLower(accountType)
        if strings.HasPrefix(accountTypeLower, "premium") || strings.HasPrefix(accountTypeLower, "standardssd") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Gets device setting from the Disk attribute/param but trimming the consts.DeviceSettingsKeyPrefix prefix
func GetDeviceSettingFromAttribute(key string) (deviceSetting string, err error) <span class="cov8" title="1">{
        if !strings.HasPrefix(key, consts.DeviceSettingsKeyPrefix) </span><span class="cov0" title="0">{
                return key, fmt.Errorf("GetDeviceSettingFromAttribute: %s is not a valid device setting override", key)
        }</span>
        <span class="cov8" title="1">return strings.TrimPrefix(key, consts.DeviceSettingsKeyPrefix), nil</span>
}

// Checks to see if deviceSettings passed are valid
func AreDeviceSettingsValid(deviceRoot string, deviceSettings map[string]string) error <span class="cov8" title="1">{
        if len(deviceSettings) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("AreDeviceSettingsValid: No deviceSettings passed")
        }</span>

        <span class="cov8" title="1">for setting := range deviceSettings </span><span class="cov8" title="1">{
                // Use absolute setting path
                absSetting, err := filepath.Abs(setting)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("AreDeviceSettingsValid: Failed to get absolute path. Can not allow setting %s for device %s",
                                setting,
                                deviceRoot)
                }</span>

                <span class="cov8" title="1">if !strings.HasPrefix(absSetting, filepath.Clean(deviceRoot)+"/") </span><span class="cov8" title="1">{
                        return fmt.Errorf("AreDeviceSettingsValid: Setting %s is not a valid file path under %s", setting, deviceRoot)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">//go:build linux
// +build linux

/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package optimization

import (
        "fmt"
        "math"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"

        "k8s.io/klog/v2"

        consts "sigs.k8s.io/azuredisk-csi-driver/pkg/azureconstants"
)

type DeviceHelper struct {
        blockDeviceRootPath string
}

func NewDeviceHelper() *DeviceHelper <span class="cov8" title="1">{
        return &amp;DeviceHelper{blockDeviceRootPath: consts.BlockDeviceRootPathLinux}
}</span>

func (deviceHelper *DeviceHelper) DiskSupportsPerfOptimization(diskPerfProfile, diskAccountType string) bool <span class="cov8" title="1">{
        return isPerfTuningEnabled(diskPerfProfile) &amp;&amp; accountSupportsPerfOptimization(diskAccountType)
}</span>

// OptimizeDiskPerformance optimizes device performance by setting tuning block device settings
func (deviceHelper *DeviceHelper) OptimizeDiskPerformance(nodeInfo *NodeInfo, devicePath,
        perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string, deviceSettingsFromCtx map[string]string) (err error) <span class="cov8" title="1">{

        if nodeInfo == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("OptimizeDiskPerformance: Node info is not provided. Error: invalid parameter")
        }</span>

        <span class="cov8" title="1">deviceName, err := getDeviceName(devicePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("OptimizeDiskPerformance: Could not get deviceName for %s. Error: %v", devicePath, err)
        }</span>

        <span class="cov8" title="1">var deviceSettings map[string]string
        deviceRoot := filepath.Join(deviceHelper.blockDeviceRootPath, deviceName)
        switch strings.ToLower(perfProfile) </span>{
        case consts.PerfProfileBasic:<span class="cov8" title="1">
                deviceSettings, err = getDeviceSettingsForBasicProfile(nodeInfo,
                        deviceRoot, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr)</span>
        case consts.PerfProfileAdvanced:<span class="cov0" title="0">
                deviceSettings, err = getDeviceSettingsForAdvancedProfile(deviceRoot, deviceSettingsFromCtx)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("OptimizeDiskPerformance: Invalid perfProfile %s", perfProfile)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("OptimizeDiskPerformance: Failed to optimize disk for deviceName %s perfProfile %s. Error: %v",
                        deviceName, perfProfile, err)
        }</span>

        <span class="cov8" title="1">klog.V(2).Infof("OptimizeDiskPerformance: Tuning settings for deviceRoot %s perfProfile %s accountType %s deviceSettings %v",
                deviceRoot,
                perfProfile,
                accountType,
                deviceSettings)
        return applyDeviceSettings(deviceRoot, deviceSettings)</span>
}

func getDeviceSettingsForBasicProfile(nodeInfo *NodeInfo,
        deviceRoot, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string) (deviceSettings map[string]string, err error) <span class="cov8" title="1">{
        klog.V(2).Infof("getDeviceSettingsForBasicProfile: Getting settings for deviceRoot %s",
                deviceRoot)
        queueDepth, nrRequests, scheduler, maxSectorsKb, _, err := getOptimalDeviceSettings(nodeInfo, DiskSkuMap, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getDeviceSettingsForBasicProfile: Failed to get optimal settings for profile %s accountType %s. Error: %v", perfProfile, accountType, err)
        }</span>

        <span class="cov8" title="1">deviceSettings = make(map[string]string)
        deviceSettings[filepath.Join(deviceRoot, "queue/max_sectors_kb")] = maxSectorsKb
        deviceSettings[filepath.Join(deviceRoot, "queue/scheduler")] = scheduler
        deviceSettings[filepath.Join(deviceRoot, "device/queue_depth")] = queueDepth
        deviceSettings[filepath.Join(deviceRoot, "queue/nr_requests")] = nrRequests
        deviceSettings[filepath.Join(deviceRoot, "queue/read_ahead_kb")] = "8"

        return deviceSettings, nil</span>
}

func getDeviceSettingsForAdvancedProfile(deviceRoot string, deviceSettingsFromCtx map[string]string) (deviceSettings map[string]string, err error) <span class="cov8" title="1">{
        klog.V(2).Infof("getDeviceSettingsForAdvancedProfile: Getting settings for deviceRoot %s deviceSettingsFromCtx %v",
                deviceRoot,
                deviceSettingsFromCtx)
        deviceSettings = make(map[string]string)
        for setting, value := range deviceSettingsFromCtx </span><span class="cov8" title="1">{
                deviceSettings[filepath.Join(deviceRoot, setting)] = value
        }</span>

        <span class="cov8" title="1">return deviceSettings, nil</span>
}

func applyDeviceSettings(deviceRoot string, deviceSettings map[string]string) (err error) <span class="cov8" title="1">{
        if err = AreDeviceSettingsValid(deviceRoot, deviceSettings); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for setting, value := range deviceSettings </span><span class="cov8" title="1">{
                err = echoToFile(value, setting)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("applyDeviceSettings: Could not set %s with value %s. Error: %v",
                                setting,
                                value,
                                err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getDeviceName gets the device name from the device lunpath
// Device lun path is of the format /dev/disk/azure/scsi1/lun0
func getDeviceName(lunPath string) (deviceName string, err error) <span class="cov8" title="1">{
        devicePath, err := filepath.EvalSymlinks(lunPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path %s is not a symlink. Error: %v", lunPath, err)
        }</span>

        <span class="cov8" title="1">return filepath.Base(devicePath), nil</span>
}

// echoToFile echos setting value to the file
func echoToFile(content, filePath string) (err error) <span class="cov8" title="1">{
        outfile, err := os.Create(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer outfile.Close()

        cmd := exec.Command("echo", content)
        cmd.Stdout = outfile
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return cmd.Wait()</span>
}

func getOptimalDeviceSettings(nodeInfo *NodeInfo, diskSkus map[string]map[string]DiskSkuInfo, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string) (queueDepth, nrRequests, scheduler, maxSectorsKb, readAheadKb string, err error) <span class="cov8" title="1">{
        klog.V(12).Infof("Calculating perf optimizations for rofile %s accountType %s diskSize %s", perfProfile, accountType, diskSizeGibStr)
        iopsHeadRoom := .25
        maxHwSectorsKb := 512.0

        // TODO: Get matching disk SKU
        // In future get the disk SKU using disk size ex. P10, P30 etc
        diskSku, err := getMatchingDiskSku(diskSkus, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr)

        if err != nil || diskSku == nil </span><span class="cov8" title="1">{
                return queueDepth, nrRequests, scheduler, maxSectorsKb, readAheadKb, fmt.Errorf("could not find sku for account %s size %s. Error: sku not found", accountType, diskSizeGibStr)
        }</span>

        <span class="cov8" title="1">diskIopsFloat := float64(diskSku.MaxBurstIops)
        maxBurstIops := math.Min(diskIopsFloat, float64(nodeInfo.MaxBurstIops))

        // Some VM SKUs don't have IOPS published
        // for such VMs set the properties based on disk IOPs limits
        if maxBurstIops &lt;= 0 </span><span class="cov8" title="1">{
                maxBurstIops = diskIopsFloat
        }</span>

        <span class="cov8" title="1">diskBwFloat := float64(diskSku.MaxBurstBwMbps)
        // unless otherwise specified, BW Units are in kB (not KB) which is 1000 bytes
        maxBurstBw := math.Min(diskBwFloat, float64(nodeInfo.MaxBurstBwMbps)) * 1000

        // Some VM SKUs don't have BW published
        // for such VMs set the properties based on disk BW limits
        if maxBurstBw &lt;= 0 </span><span class="cov8" title="1">{
                maxBurstBw = diskBwFloat
        }</span>

        // Adjusted burst IOs possible
        <span class="cov8" title="1">iopsSeqIo := maxBurstIops * (1 - iopsHeadRoom)

        // Request size needed to get max Burst BW, capped at maxHwSectorsKb
        rsMinSeqIo := math.Ceil(math.Min(maxHwSectorsKb, (maxBurstBw / iopsSeqIo)))

        // TODO: dynamically calculate this
        latencyPerIoToGetMaxBwInSec := diskSku.GetSequentialOLatencyInSec()
        latencyForSmallRandOperationInSec := diskSku.GetRandomIOLatencyInSec()

        // queue_depth needed to drive maxBurstBw with IO size rsMinSeqIo and each IO taking latencyPerIoToGetMaxBwInSec
        qdMaxSeqBw := math.Ceil(maxBurstBw * latencyPerIoToGetMaxBwInSec / rsMinSeqIo)

        // queue_depth needed for random IOs to hit IOPS reserved for them
        qdMaxRandomIops := math.Ceil(maxBurstIops * latencyForSmallRandOperationInSec)

        maxSectorsKb = fmt.Sprintf("%g", rsMinSeqIo)
        scheduler = "mq-deadline"

        qdTotal := fmt.Sprintf("%g", math.Ceil(math.Max(((qdMaxRandomIops*iopsHeadRoom)+qdMaxSeqBw), qdMaxRandomIops)))
        queueDepth = qdTotal
        nrRequests = qdTotal

        readAheadKb = fmt.Sprintf("%g", math.Ceil(qdMaxSeqBw*rsMinSeqIo))

        klog.V(2).Infof("Returning perf attributes for perfProfile %s accountType %s queueDepth %s nrRequests %s scheduler %s maxSectorsKb %s readAheadKb %s",
                perfProfile,
                accountType,
                queueDepth,
                nrRequests,
                scheduler,
                maxSectorsKb,
                readAheadKb)
        return queueDepth, nrRequests, scheduler, maxSectorsKb, readAheadKb, err</span>
}

// getMatchingDiskSku gets the smallest SKU which matches the size, io and bw requirement
// TODO: Query the disk size (e.g. P10, P30 etc) and use that to find the sku
func getMatchingDiskSku(diskSkus map[string]map[string]DiskSkuInfo, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string) (matchingSku *DiskSkuInfo, err error) <span class="cov8" title="1">{
        accountTypeLower := strings.ToLower(accountType)
        skus, ok := diskSkus[accountTypeLower]

        if !ok || skus == nil || len(diskSkus[accountTypeLower]) &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not find sku for account %s. Error: sku not found", accountType)
        }</span>

        <span class="cov8" title="1">diskSizeGb, err := strconv.Atoi(diskSizeGibStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not parse disk size %s. Error: incorrect sku size", diskSizeGibStr)
        }</span>

        // Treating these as non required field, as they come as part of the provisioned size
        // If these are explicitly set then that will be used to get the best possible match
        <span class="cov8" title="1">diskIops, err := strconv.Atoi(diskIopsStr)
        if err != nil </span><span class="cov8" title="1">{
                diskIops = 0
        }</span>
        <span class="cov8" title="1">diskBwMbps, err := strconv.Atoi(diskBwMbpsStr)
        if err != nil </span><span class="cov8" title="1">{
                diskBwMbps = 0
        }</span>

        <span class="cov8" title="1">for _, sku := range diskSkus[accountTypeLower] </span><span class="cov8" title="1">{
                // Use the smallest sku size which can fulfil Size, IOs and BW requirements
                if meetsRequest(&amp;sku, diskSizeGb, diskIops, diskBwMbps) </span><span class="cov8" title="1">{
                        if matchingSku == nil || sku.MaxSizeGiB &lt; matchingSku.MaxSizeGiB </span><span class="cov8" title="1">{
                                tempSku := sku
                                matchingSku = &amp;tempSku
                        }</span>
                }
        }

        <span class="cov8" title="1">return matchingSku, nil</span>
}

// meetsRequest checks to see if given SKU meets\has enough size, iops and bw limits
func meetsRequest(sku *DiskSkuInfo, diskSizeGb, diskIops, diskBwMbps int) bool <span class="cov8" title="1">{
        if sku == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if sku.MaxSizeGiB &gt;= diskSizeGb &amp;&amp; sku.MaxBwMbps &gt;= diskBwMbps &amp;&amp; sku.MaxIops &gt;= diskIops </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/optimization/device_perf.go

// Package mockoptimization is a generated GoMock package.
package mockoptimization

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        optimization "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
)

// MockInterface is a mock of Interface interface.
type MockInterface struct {
        ctrl     *gomock.Controller
        recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface.
type MockInterfaceMockRecorder struct {
        mock *MockInterface
}

// NewMockInterface creates a new mock instance.
func NewMockInterface(ctrl *gomock.Controller) *MockInterface <span class="cov0" title="0">{
        mock := &amp;MockInterface{ctrl: ctrl}
        mock.recorder = &amp;MockInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DiskSupportsPerfOptimization mocks base method.
func (m *MockInterface) DiskSupportsPerfOptimization(diskPerfProfile, diskAccountType string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DiskSupportsPerfOptimization", diskPerfProfile, diskAccountType)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// DiskSupportsPerfOptimization indicates an expected call of DiskSupportsPerfOptimization.
func (mr *MockInterfaceMockRecorder) DiskSupportsPerfOptimization(diskPerfProfile, diskAccountType interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskSupportsPerfOptimization", reflect.TypeOf((*MockInterface)(nil).DiskSupportsPerfOptimization), diskPerfProfile, diskAccountType)
}</span>

// OptimizeDiskPerformance mocks base method.
func (m *MockInterface) OptimizeDiskPerformance(nodeInfo *optimization.NodeInfo, devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr string, deviceSettingsFromCtx map[string]string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "OptimizeDiskPerformance", nodeInfo, devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettingsFromCtx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// OptimizeDiskPerformance indicates an expected call of OptimizeDiskPerformance.
func (mr *MockInterfaceMockRecorder) OptimizeDiskPerformance(nodeInfo, devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettingsFromCtx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OptimizeDiskPerformance", reflect.TypeOf((*MockInterface)(nil).OptimizeDiskPerformance), nodeInfo, devicePath, perfProfile, accountType, diskSizeGibStr, diskIopsStr, diskBwMbpsStr, deviceSettingsFromCtx)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package optimization

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "k8s.io/apimachinery/pkg/types"
        cloudprovider "k8s.io/cloud-provider"
        "k8s.io/klog/v2"
)

// NodeInfo stores VM/Node specific static information
// VM information is present in sku.json in below format
//
//        {
//                "resourceType": "virtualmachines",
//                "name": "Standard_E16-4ds_v4",
//                "tier": "Standard",
//                "size": "E16-4ds_v4",
//                "capabilities": [
//                 {
//                  "name": "vCPUs",
//                  "value": "16"
//                 },
//                 {
//                  "name": "MemoryGB",
//                  "value": "128"
//                 },
//                 {
//                  "name": "MaxDataDiskCount",
//                  "value": "32"
//                 },
//                 {
//                  "name": "UncachedDiskIOPS",
//                  "value": "25600"
//                 },
//                 {
//                  "name": "UncachedDiskBytesPerSecond",
//                  "value": "402653184"
//                 }
//                ]
//        }
type NodeInfo struct {
        SkuName          string
        MaxDataDiskCount int
        VCpus            int
        MaxBurstIops     int
        MaxIops          int
        MaxBwMbps        int
        MaxBurstBwMbps   int
}

// DiskSkuInfo stores disk sku information
// disk sku information is present in sku.json in below format
//
//        {
//                "resourceType": "disks",
//                "name": "Premium_LRS",
//                "tier": "Premium",
//                "size": "P4",
//                "capabilities": [
//                 {
//                  "name": "MaxSizeGiB",
//                  "value": "32"
//                 {
//                  "name": "MaxIOps",
//                  "value": "120"
//                 },
//                 {
//                  "name": "MaxBandwidthMBps",
//                  "value": "25"
//                 },
//                 {
//                  "name": "MaxValueOfMaxShares",
//                  "value": "1"
//                 },
//                 {
//                  "name": "MaxBurstIops",
//                  "value": "3500"
//                 },
//                 {
//                  "name": "MaxBurstBandwidthMBps",
//                  "value": "170"
//                 }
//                ]
//        }
type DiskSkuInfo struct {
        StorageAccountType string
        StorageTier        string
        DiskSize           string
        MaxAllowedShares   int
        MaxBurstIops       int
        MaxIops            int
        MaxBwMbps          int
        MaxBurstBwMbps     int
        MaxSizeGiB         int
}

// NewNodeInfo populates Node and Sku related information in memory
func NewNodeInfo(ctx context.Context, cloud cloudprovider.Interface, nodeID string) (*NodeInfo, error) <span class="cov8" title="1">{
        klog.V(2).Infof("NewNodeInfo: Starting to populate node and disk sku information.")

        instances, ok := cloud.Instances()
        if !ok </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, "NewNodeInfo: Failed to get instances from Azure cloud provider")
        }</span>

        <span class="cov8" title="1">instanceType, err := instances.InstanceType(ctx, types.NodeName(nodeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NewNodeInfo: Failed to get instance type from Azure cloud provider, nodeName: %v, error: %v", nodeID, err)
        }</span>

        <span class="cov8" title="1">nodeInfo := &amp;NodeInfo{}
        nodeInfo.SkuName = instanceType

        nodeSkuNameLower := strings.ToLower(nodeInfo.SkuName)

        vmSku, ok := NodeInfoMap[nodeSkuNameLower]
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("NewNodeInfo: Could not find SKU %s in the sku map", nodeSkuNameLower)
        }</span>

        <span class="cov8" title="1">nodeInfo.MaxBurstBwMbps = vmSku.MaxBurstBwMbps
        nodeInfo.MaxBurstIops = vmSku.MaxBurstIops
        nodeInfo.MaxBwMbps = vmSku.MaxBwMbps
        nodeInfo.MaxIops = vmSku.MaxIops
        nodeInfo.MaxDataDiskCount = vmSku.MaxDataDiskCount
        nodeInfo.VCpus = vmSku.VCpus

        return nodeInfo, nil</span>
}

func GetDiskSkuInfoMap() map[string]map[string]DiskSkuInfo <span class="cov0" title="0">{
        return DiskSkuMap
}</span>

// GetRandomIOLatencyInSec gets the estimated random IP latency for a small write for a disk size
// These latencies are manually calculated and stored
// ToDo: Make this estimation dynamic
func (sku *DiskSkuInfo) GetRandomIOLatencyInSec() float64 <span class="cov8" title="1">{
        if sku.MaxSizeGiB &lt;= 4096 </span><span class="cov8" title="1">{
                return 0.0022
        }</span>

        <span class="cov8" title="1">if sku.MaxSizeGiB &lt;= 8192 </span><span class="cov8" title="1">{
                return 0.0028
        }</span>

        <span class="cov8" title="1">if sku.MaxSizeGiB &lt;= 16384 </span><span class="cov8" title="1">{
                return 0.0034
        }</span>

        <span class="cov8" title="1">return 0.004</span>
}

// GetSequentialOLatencyInSec gets the estimated sequential IO latency for a disk size
// These latencies are manually calculated and stored
// ToDo: Make this estimation dynamic
func (sku *DiskSkuInfo) GetSequentialOLatencyInSec() float64 <span class="cov8" title="1">{
        if sku.MaxSizeGiB &lt;= 4096 </span><span class="cov8" title="1">{
                return 0.0033
        }</span>

        <span class="cov8" title="1">if sku.MaxSizeGiB &lt;= 8192 </span><span class="cov8" title="1">{
                return 0.0041
        }</span>

        <span class="cov8" title="1">if sku.MaxSizeGiB &lt;= 16384 </span><span class="cov8" title="1">{
                return 0.0046
        }</span>

        <span class="cov8" title="1">return 0.0052</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strconv"
        "strings"

        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "k8s.io/klog/v2"

        "sigs.k8s.io/azuredisk-csi-driver/pkg/optimization"
)

var (
        MaxValueOfMaxSharesCapability        = "maxvalueofmaxshares"
        MaxBurstIopsCapability               = "maxburstiops"
        MaxIOpsCapability                    = "maxiops"
        MaxBandwidthMBpsCapability           = "maxbandwidthmbps"
        MaxBurstBandwidthMBpsCapability      = "maxburstbandwidthmbps"
        MaxSizeGiBCapability                 = "maxsizegib"
        UncachedDiskIOPSCapability           = "uncacheddiskiops"
        UncachedDiskBytesPerSecondCapability = "uncacheddiskbytespersecond"
        MaxDataDiskCountCapability           = "maxdatadiskcount"
        VCPUsCapability                      = "vcpus"
        SkusFullfilePath                     = "skus-full.json"
)

func init() <span class="cov8" title="1">{
        klog.InitFlags(nil)
}</span>

// exit is a separate function to handle program termination
var exit = func(code int) <span class="cov0" title="0">{
        os.Exit(code)
}</span>

func main() <span class="cov8" title="1">{

        boilerPlate := `/*
Copyright 2021 The Kubernetes Authors.
        
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0
        
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
        
package optimization
        
import (
)`
        var sb strings.Builder
        diskMapStart := "        DiskSkuMap = map[string]map[string]DiskSkuInfo{"
        diskMapEnd := "        }"
        accStart := `        "%s": map[string]DiskSkuInfo {`
        accEnd := "                },"
        diskSku := `                "%s": DiskSkuInfo{StorageAccountType: "%s", StorageTier: "%s", DiskSize: "%s", MaxAllowedShares: %s, MaxBurstIops: %s, MaxIops: %s, MaxBwMbps: %s, MaxBurstBwMbps: %s, MaxSizeGiB: %s},`

        nodeMapStart := "        NodeInfoMap = map[string]NodeInfo{"
        nodeInfo := `        "%s": NodeInfo{SkuName: "%s", MaxDataDiskCount: %s, VCpus: %s, MaxBurstIops: %s, MaxIops: %s, MaxBwMbps: %s, MaxBurstBwMbps: %s},`
        nodeMapEnd := "        }"

        defer os.Remove(SkusFullfilePath)
        skusFilePath := "pkg/azuredisk/azure_skus_map.go"

        skuMap := map[string]bool{}

        var resources []*armcompute.ResourceSKU

        if err := getAllSkus(); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Could not get skus. Error: %v", err)
        }</span>

        <span class="cov8" title="1">diskSkusFullJSON, err := os.Open(SkusFullfilePath)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Could not read file. Error: %v, FilePath: %s", err, SkusFullfilePath)
                return
        }</span>
        <span class="cov8" title="1">defer diskSkusFullJSON.Close()

        byteValue, _ := io.ReadAll(diskSkusFullJSON)

        err = json.Unmarshal([]byte(byteValue), &amp;resources)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Could not parse json file file. Error: %v, FilePath: %s", err, SkusFullfilePath)
                return
        }</span>

        <span class="cov8" title="1">diskSkuInfoMap := map[string]map[string]optimization.DiskSkuInfo{}
        vmSkuInfoMap := map[string]optimization.NodeInfo{}

        for _, sku := range resources </span><span class="cov8" title="1">{
                resType := strings.ToLower(*sku.ResourceType)
                skuKey := ""
                if resType == "disks" </span><span class="cov8" title="1">{
                        skuKey = fmt.Sprintf("%s-%s-%s", *sku.Name, *sku.Tier, *sku.Size)
                }</span> else<span class="cov8" title="1"> if resType == "virtualmachines" </span><span class="cov8" title="1">{
                        skuKey = *sku.Name
                }</span> else<span class="cov8" title="1"> {
                        continue</span>
                }
                // If we already added the sku, skip
                <span class="cov8" title="1">skuKeyLower := strings.ToLower(skuKey)
                if _, ok := skuMap[skuKeyLower]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">skuMap[skuKeyLower] = true
                if resType == "disks" </span><span class="cov8" title="1">{
                        account := strings.ToLower(*sku.Name)
                        diskSize := strings.ToLower(*sku.Size)
                        if _, ok := diskSkuInfoMap[account]; !ok </span><span class="cov8" title="1">{
                                diskSkuInfoMap[account] = map[string]optimization.DiskSkuInfo{}
                        }</span>
                        <span class="cov8" title="1">diskSkuInfoMap[account][diskSize], err = getDiskCapabilities(sku)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.Errorf("populateSkuMap: Failed to get disk capabilities for disk %s %s %s. Error: %v", *sku.Name, *sku.Size, *sku.Tier, err)
                                exit(1)
                        }</span>
                } else<span class="cov8" title="1"> if resType == "virtualmachines" </span><span class="cov8" title="1">{
                        nodeInfo := optimization.NodeInfo{}
                        nodeInfo.SkuName = *sku.Name
                        err = populateNodeCapabilities(sku, &amp;nodeInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.Errorf("populateSkuMap: Failed to populate node capabilities. Error: %v", err)
                                exit(1)
                        }</span>
                        <span class="cov8" title="1">vmSkuInfoMap[strings.ToLower(*sku.Name)] = nodeInfo</span>
                }
        }

        // Write the boiler plate stuff
        <span class="cov8" title="1">appendWithErrCheck(&amp;sb, boilerPlate)
        appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, "var (")
        appendWithErrCheck(&amp;sb, "\n")

        // Write the disk map
        appendWithErrCheck(&amp;sb, diskMapStart)
        for account, sizes := range diskSkuInfoMap </span><span class="cov8" title="1">{
                appendWithErrCheck(&amp;sb, "\n")
                appendWithErrCheck(&amp;sb, fmt.Sprintf(accStart, account))

                for size, sku := range sizes </span><span class="cov8" title="1">{
                        //diskSku := `"%s": DiskSkuInfo{storageAccountType: "%s", storageTier: "%s", diskSize: "%s",
                        //maxAllowedShares: %s, maxBurstIops: %s, maxIops: %s, maxBwMbps: %s, maxBurstBwMbps: %s, maxSizeGiB: %s},`
                        appendWithErrCheck(&amp;sb, "\n")
                        appendWithErrCheck(&amp;sb, fmt.Sprintf(diskSku, size, sku.StorageAccountType, sku.StorageTier, sku.DiskSize, strconv.Itoa(sku.MaxAllowedShares),
                                strconv.Itoa(sku.MaxBurstIops), strconv.Itoa(sku.MaxIops), strconv.Itoa(sku.MaxBwMbps), strconv.Itoa(sku.MaxBurstBwMbps), strconv.Itoa(sku.MaxSizeGiB)))
                }</span>
                <span class="cov8" title="1">appendWithErrCheck(&amp;sb, "\n")
                appendWithErrCheck(&amp;sb, accEnd)</span>
        }

        <span class="cov8" title="1">appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, diskMapEnd)
        appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, "\n")

        // Write the VM Sku map
        appendWithErrCheck(&amp;sb, nodeMapStart)

        //nodeInfo := `        "%s": NodeInfo{skuName: "%s", maxDataDiskCount: %s, vcpus: %s, maxBurstIops: %s, maxIops: %s, maxBwMbps: %s, maxBurstBwMbps: %s},`
        for vm, sku := range vmSkuInfoMap </span><span class="cov8" title="1">{
                appendWithErrCheck(&amp;sb, "\n")
                appendWithErrCheck(&amp;sb, fmt.Sprintf(nodeInfo, vm, sku.SkuName, strconv.Itoa(sku.MaxDataDiskCount), strconv.Itoa(sku.VCpus),
                        strconv.Itoa(sku.MaxBurstIops), strconv.Itoa(sku.MaxIops), formatInt(sku.MaxBwMbps), formatInt(sku.MaxBurstBwMbps)))
        }</span>
        <span class="cov8" title="1">appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, nodeMapEnd)
        appendWithErrCheck(&amp;sb, "\n")
        appendWithErrCheck(&amp;sb, ")")
        appendWithErrCheck(&amp;sb, "\n")

        err = os.WriteFile(skusFilePath, []byte(sb.String()), 0644)
        if err != nil </span><span class="cov8" title="1">{
                klog.Errorf("Could write file. Error: %v, FilePath: %s", err, skusFilePath)
        }</span>
        <span class="cov8" title="1">klog.Info("Wrote to file ", skusFilePath)</span>
}

func formatInt(value int) string <span class="cov8" title="1">{
        if value &lt;= 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov8" title="1">return strconv.Itoa(value)</span>
}
func getAllSkus() (err error) <span class="cov8" title="1">{
        if os.Getenv("TEST_SCENARIO") == "true" </span><span class="cov8" title="1">{
                if _, err := os.Stat("skus-sample.json"); err == nil </span><span class="cov8" title="1">{
                        SkusFullfilePath = "skus-sample.json"
                        return nil
                }</span>
        }
        <span class="cov0" title="0">klog.V(2).Infof("Getting skus and writing to %s", SkusFullfilePath)
        cmd := exec.Command("az", "vm", "list-skus")
        outfile, err := os.Create(SkusFullfilePath)
        var errorBuf bytes.Buffer
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Could not create file. Error: %v File: %s", err, SkusFullfilePath)
                return err
        }</span>
        <span class="cov0" title="0">defer outfile.Close()

        cmd.Stdout = outfile
        cmd.Stderr = &amp;errorBuf

        err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = cmd.Wait()
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Could not get skus. ExitCode: %v Error: %s", err, errorBuf.String())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// populateNodeCapabilities populates node capabilities from SkuInfo
func populateNodeCapabilities(sku *armcompute.ResourceSKU, nodeInfo *optimization.NodeInfo) (err error) <span class="cov8" title="1">{
        if sku.Capabilities != nil </span><span class="cov8" title="1">{
                for _, capability := range sku.Capabilities </span><span class="cov8" title="1">{
                        err = nil
                        if capability.Name != nil </span><span class="cov8" title="1">{
                                switch strings.ToLower(*capability.Name) </span>{
                                case UncachedDiskIOPSCapability:<span class="cov8" title="1">
                                        nodeInfo.MaxIops, err = strconv.Atoi(*capability.Value)</span>
                                case UncachedDiskBytesPerSecondCapability:<span class="cov8" title="1">
                                        bw, err := strconv.Atoi(*capability.Value)
                                        nodeInfo.MaxBwMbps = bw / (1024 * 1024)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("PopulateNodeCapabilities: Failed to parse node capability %s. Error: %v", *capability.Name, err)
                                        }</span>
                                case MaxDataDiskCountCapability:<span class="cov8" title="1">
                                        nodeInfo.MaxDataDiskCount, err = strconv.Atoi(*capability.Value)</span>
                                case VCPUsCapability:<span class="cov8" title="1">
                                        nodeInfo.VCpus, err = strconv.Atoi(*capability.Value)</span>
                                default:<span class="cov8" title="1">
                                        continue</span>
                                }
                        }

                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("PopulateNodeCapabilities: Failed to parse node capability %s. Error: %v", *capability.Name, err)
                        }</span>
                }
        }

        // If node doesn't support burst capabilities.
        // Set the burst limits as regular limits
        <span class="cov8" title="1">if nodeInfo.MaxBurstIops &lt; nodeInfo.MaxIops </span><span class="cov8" title="1">{
                nodeInfo.MaxBurstIops = nodeInfo.MaxIops
        }</span>

        <span class="cov8" title="1">if nodeInfo.MaxBurstBwMbps &lt; nodeInfo.MaxBwMbps </span><span class="cov8" title="1">{
                nodeInfo.MaxBurstBwMbps = nodeInfo.MaxBwMbps
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getDiskCapabilities gets disk capabilities from SkuInfo
func getDiskCapabilities(sku *armcompute.ResourceSKU) (diskSku optimization.DiskSkuInfo, err error) <span class="cov8" title="1">{
        diskSku = optimization.DiskSkuInfo{}
        diskSku.StorageAccountType = *sku.Name
        diskSku.StorageTier = *sku.Tier
        diskSku.DiskSize = *sku.Size

        if sku.Capabilities != nil </span><span class="cov8" title="1">{
                for _, capability := range sku.Capabilities </span><span class="cov8" title="1">{
                        err = nil
                        if capability.Name != nil </span><span class="cov8" title="1">{
                                switch strings.ToLower(*capability.Name) </span>{
                                case MaxValueOfMaxSharesCapability:<span class="cov8" title="1">
                                        diskSku.MaxAllowedShares, err = strconv.Atoi(*capability.Value)</span>
                                case MaxBurstIopsCapability:<span class="cov0" title="0">
                                        diskSku.MaxBurstIops, err = strconv.Atoi(*capability.Value)</span>
                                case MaxIOpsCapability:<span class="cov0" title="0">
                                        diskSku.MaxIops, err = strconv.Atoi(*capability.Value)</span>
                                case MaxBandwidthMBpsCapability:<span class="cov0" title="0">
                                        diskSku.MaxBwMbps, err = strconv.Atoi(*capability.Value)</span>
                                case MaxBurstBandwidthMBpsCapability:<span class="cov0" title="0">
                                        diskSku.MaxBurstBwMbps, err = strconv.Atoi(*capability.Value)</span>
                                case MaxSizeGiBCapability:<span class="cov8" title="1">
                                        diskSku.MaxSizeGiB, err = strconv.Atoi(*capability.Value)</span>
                                default:<span class="cov8" title="1">
                                        continue</span>
                                }
                        }

                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return diskSku, fmt.Errorf("GetDiskCapabilities: Failed to parse disk capability %s. Error: %v", *capability.Name, err)
                        }</span>
                }
        }

        // If disk doesn't support burst capabilities.
        // Set the burst limits as regular limits
        <span class="cov8" title="1">if diskSku.MaxBurstIops &lt; diskSku.MaxIops </span><span class="cov0" title="0">{
                diskSku.MaxBurstIops = diskSku.MaxIops
        }</span>

        <span class="cov8" title="1">if diskSku.MaxBurstBwMbps &lt; diskSku.MaxBwMbps </span><span class="cov0" title="0">{
                diskSku.MaxBurstBwMbps = diskSku.MaxBwMbps
        }</span>

        <span class="cov8" title="1">return diskSku, nil</span>
}

func appendWithErrCheck(sb *strings.Builder, strToAppend string) <span class="cov8" title="1">{
        if _, err := sb.WriteString(strToAppend); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
        "fmt"
        "os"
        "runtime"
        "sort"
        "strings"
        "sync"

        "k8s.io/apimachinery/pkg/util/sets"
)

const (
        GiB                        = 1024 * 1024 * 1024
        TagKeyValueDelimiter       = "="
        MaximumDataDiskExceededMsg = "attached to a VM of this size is"
)

// IsWindowsOS decides whether the driver is running on windows OS.
func IsWindowsOS() bool <span class="cov0" title="0">{
        return strings.EqualFold(runtime.GOOS, "windows")
}</span>

// IsLinuxOS decides whether the driver is running on linux OS.
func IsLinuxOS() bool <span class="cov0" title="0">{
        return strings.EqualFold(runtime.GOOS, "linux")
}</span>

// RoundUpBytes rounds up the volume size in bytes up to multiplications of GiB
// in the unit of Bytes
func RoundUpBytes(volumeSizeBytes int64) int64 <span class="cov8" title="1">{
        return RoundUpSize(volumeSizeBytes, GiB) * GiB
}</span>

// RoundUpGiB rounds up the volume size in bytes up to multiplications of GiB
// in the unit of GiB
func RoundUpGiB(volumeSizeBytes int64) int64 <span class="cov8" title="1">{
        return RoundUpSize(volumeSizeBytes, GiB)
}</span>

// BytesToGiB conversts Bytes to GiB
func BytesToGiB(volumeSizeBytes int64) int64 <span class="cov8" title="1">{
        return volumeSizeBytes / GiB
}</span>

// GiBToBytes converts GiB to Bytes
func GiBToBytes(volumeSizeGiB int64) int64 <span class="cov8" title="1">{
        return volumeSizeGiB * GiB
}</span>

// RoundUpSize calculates how many allocation units are needed to accommodate
// a volume of given size. E.g. when user wants 1500MiB volume, while AWS EBS
// allocates volumes in gibibyte-sized chunks,
// RoundUpSize(1500 * 1024*1024, 1024*1024*1024) returns '2'
// (2 GiB is the smallest allocatable volume that can hold 1500MiB)
func RoundUpSize(volumeSizeBytes int64, allocationUnitBytes int64) int64 <span class="cov8" title="1">{
        roundedUp := volumeSizeBytes / allocationUnitBytes
        if volumeSizeBytes%allocationUnitBytes &gt; 0 </span><span class="cov8" title="1">{
                roundedUp++
        }</span>
        <span class="cov8" title="1">return roundedUp</span>
}

// ConvertTagsToMap convert the tags from string to map, default tagDelimiter is ","
// the valid tags format is "key1=value1,key2=value2", which could be converted to
// {"key1": "value1", "key2": "value2"}
func ConvertTagsToMap(tags string, tagsDelimiter string) (map[string]string, error) <span class="cov8" title="1">{
        m := make(map[string]string)
        if tags == "" </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">if tagsDelimiter == "" </span><span class="cov8" title="1">{
                tagsDelimiter = ","
        }</span>
        <span class="cov8" title="1">s := strings.Split(tags, tagsDelimiter)
        for _, tag := range s </span><span class="cov8" title="1">{
                kv := strings.SplitN(tag, TagKeyValueDelimiter, 2)
                if len(kv) != 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("tags '%s' are invalid, the format should like: 'key1=value1%skey2=value2'", tags, tagsDelimiter)
                }</span>
                <span class="cov8" title="1">key := strings.TrimSpace(kv[0])
                if key == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("tags '%s' are invalid, the format should like: 'key1=value1%skey2=value2'", tags, tagsDelimiter)
                }</span>
                // &lt;&gt;%&amp;?/. are not allowed in tag key
                <span class="cov8" title="1">if strings.ContainsAny(key, "&lt;&gt;%&amp;?/.") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("tag key '%s' contains invalid characters", key)
                }</span>
                <span class="cov8" title="1">value := strings.TrimSpace(kv[1])
                m[key] = value</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}

func MakeDir(pathname string) error <span class="cov8" title="1">{
        err := os.MkdirAll(pathname, os.FileMode(0755))
        if err != nil </span><span class="cov8" title="1">{
                if !os.IsExist(err) </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func MakeFile(pathname string) error <span class="cov8" title="1">{
        f, err := os.OpenFile(pathname, os.O_CREATE|os.O_RDWR, os.FileMode(0755))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to open file %s: %v", pathname, err)
        }</span>
        <span class="cov8" title="1">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close file %s: %v", pathname, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type VolumeLocks struct {
        locks sets.String
        mux   sync.Mutex
}

func NewVolumeLocks() *VolumeLocks <span class="cov8" title="1">{
        return &amp;VolumeLocks{
                locks: sets.NewString(),
        }
}</span>

func (vl *VolumeLocks) TryAcquire(volumeID string) bool <span class="cov8" title="1">{
        vl.mux.Lock()
        defer vl.mux.Unlock()
        if vl.locks.Has(volumeID) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">vl.locks.Insert(volumeID)
        return true</span>
}

func (vl *VolumeLocks) Release(volumeID string) <span class="cov8" title="1">{
        vl.mux.Lock()
        defer vl.mux.Unlock()
        vl.locks.Delete(volumeID)
}</span>

func GetElementsInArray1NotInArray2(arr1 []int, arr2 []int) []int <span class="cov8" title="1">{
        sort.Ints(arr1)
        sort.Ints(arr2)

        i, j := 0, 0
        result := []int{}
        for i &lt; len(arr1) &amp;&amp; j &lt; len(arr2) </span><span class="cov8" title="1">{
                if arr1[i] &lt; arr2[j] </span><span class="cov8" title="1">{
                        result = append(result, arr1[i])
                        i++
                }</span> else<span class="cov8" title="1"> if arr1[i] &gt; arr2[j] </span><span class="cov0" title="0">{
                        j++
                }</span> else<span class="cov8" title="1"> {
                        i++
                        j++
                }</span>
        }
        <span class="cov8" title="1">for i &lt; len(arr1) </span><span class="cov8" title="1">{
                result = append(result, arr1[i])
                i++
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package credentials

import (
        "fmt"
        "html/template"
        "os"

        "k8s.io/apimachinery/pkg/util/uuid"
)

const (
        AzurePublicCloud            = "AzurePublicCloud"
        ResourceGroupPrefix         = "azuredisk-csi-driver-test-"
        TempAzureCredentialFilePath = "/tmp/azure.json"

        azureCredentialFileTemplate = `{
    "cloud": "{{.Cloud}}",
    "tenantId": "{{.TenantID}}",
    "subscriptionId": "{{.SubscriptionID}}",
    "aadClientId": "{{.AADClientID}}",
    "aadClientSecret": "{{.AADClientSecret}}",
    "resourceGroup": "{{.ResourceGroup}}",
    "location": "{{.Location}}",
    "vmType": "{{.VMType}}",
    "aadFederatedTokenFile": "{{.AADFederatedTokenFile}}"
}`
        defaultAzurePublicCloudLocation = "eastus2"
        defaultAzurePublicCloudVMType   = "vmss"

        // Env vars
        cloudNameEnvVar       = "AZURE_CLOUD_NAME"
        tenantIDEnvVar        = "AZURE_TENANT_ID"
        subscriptionIDEnvVar  = "AZURE_SUBSCRIPTION_ID"
        aadClientIDEnvVar     = "AZURE_CLIENT_ID"
        aadClientSecretEnvVar = "AZURE_CLIENT_SECRET"
        resourceGroupEnvVar   = "AZURE_RESOURCE_GROUP"
        locationEnvVar        = "AZURE_LOCATION"
        vmTypeEnvVar          = "AZURE_VM_TYPE"
        federatedTokenFileVar = "AZURE_FEDERATED_TOKEN_FILE"
)

// Config is used in Prow to store Azure credentials
// https://github.com/kubernetes/test-infra/blob/master/kubetest/azure.go#L116-L118
type Config struct {
        Creds FromProw
}

// FromProw is used in Prow to store Azure credentials
// https://github.com/kubernetes/test-infra/blob/master/kubetest/azure.go#L107-L114
type FromProw struct {
        ClientID           string
        ClientSecret       string
        TenantID           string
        SubscriptionID     string
        StorageAccountName string
        StorageAccountKey  string
}

// Credentials is used in Azure Disk CSI driver to store Azure credentials
type Credentials struct {
        Cloud                 string
        TenantID              string
        SubscriptionID        string
        AADClientID           string
        AADClientSecret       string
        ResourceGroup         string
        Location              string
        VMType                string
        AADFederatedTokenFile string
}

// CreateAzureCredentialFile creates a temporary Azure credential file for
// Azure Disk CSI driver tests and returns the credentials
func CreateAzureCredentialFile() (*Credentials, error) <span class="cov8" title="1">{
        // Search credentials through env vars first
        var cloud, tenantID, subscriptionID, aadClientID, aadClientSecret, resourceGroup, location, vmType, aadFederatedTokenFile string
        cloud = os.Getenv(cloudNameEnvVar)
        if cloud == "" </span><span class="cov8" title="1">{
                cloud = AzurePublicCloud
        }</span>
        <span class="cov8" title="1">tenantID = os.Getenv(tenantIDEnvVar)
        subscriptionID = os.Getenv(subscriptionIDEnvVar)
        aadClientID = os.Getenv(aadClientIDEnvVar)
        aadClientSecret = os.Getenv(aadClientSecretEnvVar)
        resourceGroup = os.Getenv(resourceGroupEnvVar)
        location = os.Getenv(locationEnvVar)
        vmType = os.Getenv(vmTypeEnvVar)
        aadFederatedTokenFile = os.Getenv(federatedTokenFileVar)

        if resourceGroup == "" </span><span class="cov0" title="0">{
                resourceGroup = ResourceGroupPrefix + string(uuid.NewUUID())
        }</span>

        <span class="cov8" title="1">if location == "" </span><span class="cov0" title="0">{
                location = defaultAzurePublicCloudLocation
        }</span>

        <span class="cov8" title="1">if vmType == "" </span><span class="cov0" title="0">{
                vmType = defaultAzurePublicCloudVMType
        }</span>

        <span class="cov8" title="1">if tenantID != "" &amp;&amp; subscriptionID != "" &amp;&amp; aadClientID != "" &amp;&amp; (aadClientSecret != "" || aadFederatedTokenFile != "") </span><span class="cov8" title="1">{
                return parseAndExecuteTemplate(cloud, tenantID, subscriptionID, aadClientID, aadClientSecret, aadFederatedTokenFile, resourceGroup, location, vmType)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("If you are running tests locally, you will need to set the following env vars: $%s, $%s, $%s, $%s, $%s, $%s",
                tenantIDEnvVar, subscriptionIDEnvVar, aadClientIDEnvVar, aadClientSecretEnvVar, resourceGroupEnvVar, locationEnvVar)</span>
}

// DeleteAzureCredentialFile deletes the temporary Azure credential file
func DeleteAzureCredentialFile() error <span class="cov8" title="1">{
        if err := os.Remove(TempAzureCredentialFilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("error removing %s %v", TempAzureCredentialFilePath, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parseAndExecuteTemplate replaces credential placeholders in azureCredentialFileTemplate with actual credentials
func parseAndExecuteTemplate(cloud, tenantID, subscriptionID, aadClientID, aadClientSecret, aadFederatedTokenFile, resourceGroup, location, vmType string) (*Credentials, error) <span class="cov8" title="1">{
        t := template.New("AzureCredentialFileTemplate")
        t, err := t.Parse(azureCredentialFileTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing azureCredentialFileTemplate %v", err)
        }</span>

        <span class="cov8" title="1">f, err := os.Create(TempAzureCredentialFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating %s %v", TempAzureCredentialFilePath, err)
        }</span>
        <span class="cov8" title="1">defer f.Close()

        c := Credentials{
                cloud,
                tenantID,
                subscriptionID,
                aadClientID,
                aadClientSecret,
                resourceGroup,
                location,
                vmType,
                aadFederatedTokenFile,
        }
        err = t.Execute(f, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error executing parsed azure credential file template %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;c, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
